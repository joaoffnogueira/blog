<!DOCTYPE html><html lang="pt-BR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Anotações sobre Recuperação de banco de dados e segurança" /><meta name="author" content="João F. F. Nogueira" /><meta property="og:locale" content="pt_BR" /><meta name="description" content="Estratégias de recuperação:" /><meta property="og:description" content="Estratégias de recuperação:" /><link rel="canonical" href="https://blog.joaonogueira.dev//posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/" /><meta property="og:url" content="https://blog.joaonogueira.dev//posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/" /><meta property="og:site_name" content="Flutter/Dart Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-01-17T09:00:00-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Anotações sobre Recuperação de banco de dados e segurança" /><meta name="twitter:site" content="@joaoffnogueira" /><meta name="twitter:creator" content="@João F. F. Nogueira" /><meta name="google-site-verification" content="G-7RCXJ5XJWN" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"João F. F. Nogueira"},"dateModified":"2022-03-22T20:20:28-03:00","datePublished":"2020-01-17T09:00:00-03:00","description":"Estratégias de recuperação:","headline":"Anotações sobre Recuperação de banco de dados e segurança","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaonogueira.dev//posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/"},"url":"https://blog.joaonogueira.dev//posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/"}</script><title>Anotações sobre Recuperação de banco de dados e segurança | Flutter/Dart Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Flutter/Dart Blog"><meta name="application-name" content="Flutter/Dart Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/logo.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Flutter/Dart Blog</a></div><div class="site-subtitle font-italic">por João Fernando Ferrari Nogueira - Desenvolvedor Flutter | Android | Windows | Web</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIAS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARQUIVOS</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>SOBRE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/joaoffnogueira" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/joaoffnogueira" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dev.joaonogueira','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Anotações sobre Recuperação de banco de dados e segurança</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Buscar..."> </span> <span id="search-cancel" >Cancelar</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Anotações sobre Recuperação de banco de dados e segurança</h1><div class="post-meta text-muted"><div> Por <em> João F. F. Nogueira </em></div><div class="d-flex"><div> <span> Postado em <em class="timeago" data-ts="1579262400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-01-17 </em> </span> <span> Atualizado <em class="timeago" data-ts="1647991228" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-03-22 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4298 palavras"> <em>23 min</em> de leitura</span></div></div></div><div class="post-content"><h2 id="estratégias-de-recuperação"><span class="mr-2">Estratégias de recuperação:</span><a href="#estratégias-de-recuperação" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li><p>Se houver dano extensivo a uma grande parte do banco de dados devido a uma falha catastrófica, como uma falha de disco, o método de recuperação restaura uma cópia antiga do banco de dados que teve backup para o arquivamento (normalmente, fita ou outro meio de armazenamento off-line de grande capacidade) e reconstrói um estado mais recente, reaplicando ou refazendo as operações das transações confirmadas do log em backup, até o momento da falha.</p><li><p>Quando o banco de dados no disco não está danificado fisicamente, por conta de uma falha não catastrófica, a estratégia de recuperação é identificar quaisquer mudanças que possam causar uma inconsistência no banco de dados. Por exemplo, uma transação que atualizou alguns itens do banco de dados no disco, mas não confirmou as necessidades de ter suas mudanças revertidas ao desfazer suas operações de gravação. Pode também ser preciso refazer algumas operações a fim de restaurar um estado consistente do banco de dados; por exemplo, se uma transação tiver sido confirmada, mas algumas de suas operações de gravação ainda não tiverem sido gravadas em disco. Para a falha não catastrófica, o protocolo de recuperação não precisa de uma cópia de arquivamento completa do banco de dados. Em vez disso, as entradas mantidas no log do sistema on-line no disco são analisadas para determinar as ações apropriadas para recuperação.</p></ol><h2 id="técnicas-de-atualização"><span class="mr-2">Técnicas de atualização:</span><a href="#técnicas-de-atualização" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="atualização-adiada"><span class="mr-2">Atualização adiada</span><a href="#atualização-adiada" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Não atualizam fisicamente o banco de dados no disco até que uma transação atinja seu ponto de confirmação; então as atualizações são registradas no banco de dados. Antes de atingir a confirmação, todas as atualizações de transação são registradas no espaço de trabalho de transação local ou nos buffers da memória principal que o SGBD mantém (o cachê da memória principal do SGBD). Antes da confirmação, as atualizações são gravadas persistentemente no log e, após a confirmação, elas são gravadas no banco de dados no disco. Se uma transação falhar antes de atingir seu ponto de confirmação, ela não terá alterado o banco de dados de forma alguma, de modo que o UNDO não é necessário. Pode ser preciso um REDO para desfazer o efeito das operações de uma transação confirmada com base no log, pois seu efeito pode ainda não ter sido registrado no banco de dados em disco. Assim, a atualização adiada também é conhecida como algoritmo NO-UNDO/REDO.</p><h3 id="atualização-imediata"><span class="mr-2">Atualização imediata</span><a href="#atualização-imediata" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>O banco de dados pode ser atualizado por algumas operações de uma transação antes que a transação alcance seu ponto de confirmação. Porém essas operações também precisam ser registradas no log no disco ao forçar a gravação antes que elas sejam aplicadas ao banco de dados no disco, tornando a recuperação ainda possível. Se uma transação falhar depois de gravadas algumas mudanças no disco, mas antes de atingir seu ponto de confirmação, o efeito de suas operações no banco de dados precisa ser desfeito; ou seja, a transação deve ser revertida. No caso geral da atualização imediata, tanto UNDO quanto REDO podem ser exigidos durante a recuperação. Essa técnica, conhecida como algoritmo UNDO/REDO, requer as duas operações durante a recuperação, e é usada na prática. Uma variação do algoritmo, em que todas as atualizações precisam ser registradas no banco de dados em disco antes que a transação se confirme, requer apenas UNDO, de modo que é conhecido como algoritmo UNDO/NOREDO.</p><p>Não atualizam fisicamente o banco de dados no disco até que uma transação atinja seu ponto de confirmação; então as atualizações são registradas no banco de dados. Antes de atingir a confirmação, todas as atualizações de transação são registradas no espaço de trabalho de transação local ou nos buffers da memória principal que o SGBD mantém (o cachê da memória principal do SGBD). Antes da confirmação, as atualizações são gravadas persistentemente no log e, após a confirmação, elas são gravadas no banco de dados no disco. Se uma transação falhar antes de atingir seu ponto de confirmação, ela não terá alterado o banco de dados de forma alguma, de modo que o UNDO não é necessário. Pode ser preciso um REDO para desfazer o efeito das operações de uma transação confirmada com base no log, pois seu efeito pode ainda não ter sido registrado no banco de dados em disco. Assim, a atualização adiada também é conhecida como algoritmo NO-UNDO/REDO. O banco de dados pode ser atualizado por algumas operações de uma transação antes que a transação alcance seu ponto de confirmação. Porém essas operações também precisam ser registradas no log no disco ao forçar a gravação antes que elas sejam aplicadas ao banco de dados no disco, tornando a recuperação ainda possível. Se uma transação falhar depois de gravadas algumas mudanças no disco, mas antes de atingir seu ponto de confirmação, o efeito de suas operações no banco de dados precisa ser desfeito; ou seja, a transação deve ser revertida. No caso geral da atualização imediata, tanto UNDO quanto REDO podem ser exigidos durante a recuperação. Essa técnica, conhecida como algoritmo UNDO/REDO, requer as duas operações durante a recuperação, e é usada na prática. Uma variação do algoritmo, em que todas as atualizações precisam ser registradas no banco de dados em disco antes que a transação se confirme, requer apenas UNDO, de modo que é conhecido como algoritmo UNDO/NOREDO.</p><p>Algoritmo de recuperação ARIES: o ARIES é um algoritmo de recuperação projetado para trabalhar com uma estratégia de roubo, sem imposição. Quando o gerenciador de recuperação é ativado após uma falha, o reinício ocorre em três fases:</p><ol><li>Análise: Identifica as páginas sujas no pool de buffers (isto é, alterações que não foram gravadas no disco) e as transações ativas no momento da falha.<li>Refazer: Repete todas as ações, partindo de um ponto apropriado no log, e restaura o banco de dados para o estado em que ele estava no momento da falha.<li>Desfazer: Desfaz as ações das transações que não foram efetivadas, para que o banco de dados reflita apenas as ações das transações efetivadas. Princípios do algoritmo de recuperação ARIES:<li>Gravação antecipada do Log (Write-Ahead Logging, WAL): Qualquer alteração em um objeto de banco de dados é primeiramente gravada no log; o registro que está no log deve ser gravado em um meio de armazenamento estável, antes que a alteração no objeto de banco de dados seja gravada no disco.<li>Repetição do Histórico durante a fase Refazer: Na inicialização após uma falha, o ARIES refaz todas as ações do SGBD antes da falha e coloca o sistema de volta no estado exato em que se encontrava no momento da falha. Ele então desfaz as ações das transações que ainda estavam ativas no momento da falha (cancelando-as efetivamente).<li>Registro das alterações durante a fase Desfazer: As alterações feitas no banco de dados, enquanto uma transação é desfeita, são registradas para garantir que essa ação não seja repetida no caso de reinícios (causando falhas) repetidos. A parte mais recente do log, chamada de cauda do log, é mantida na memória principal, e é periodicamente gravada no armazenamento estável. Desse modo, os registros do log e os registros dos dados são gravados no disco com a mesma granularidade (páginas ou conjuntos de páginas). Todo registro de log recebe um id exclusivo, chamado de número de sequência de log (NSL). Tabelas relacionadas à recuperação: Tabela de transações: Essa tabela contém uma entrada para cada transação ativa. A entrada contém (dentre outras coisas) o id da transação, o status e um campo chamado último NSL, que é o NSL do registro de log mais recente dessa transação. O status de uma transação pode indicar que ela está em andamento, foi efetivada ou foi cancelada. (Nos dois últimos casos, a transação será removida da tabela quando certas etapas de ‘limpeza’ forem completadas.) Tabela de páginas sujas: Essa tabela contém uma entrada para cada página suja no pool de buffers; isto é, cada página com alterações ainda não refletidas no disco. A entrada contém um campo NSLreg, que é o NSL do primeiro registro de log que fez a página tornar-se suja. Note que esse NSL identifica o registro de log mais recente que talvez tenha que ser refeito para essa página durante o reinício a partir de uma falha. Discos rígidos espelhados – arquitetura RAID - (Redundant Array Inexpensive/Independent Disk, ou “Conjunto Redundante de Discos Econômicos/Independentes”).</ol><h2 id="controle-de-concorrência"><span class="mr-2">Controle de concorrência</span><a href="#controle-de-concorrência" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Aplicação de diversas técnicas que são usadas para garantir a propriedade de não interferência ou isolamento das transações executadas simultaneamente. O protocolo de bloqueio mais amplamente usado é o bloqueio de duas fases restrito, ou Strict 2PL (do inglês, Strict Two-Phase Locking).</p><ol><li>Se uma transação T quer ler (respectivamente, modificar) um objeto, ela primeiro solicita um bloqueio compartilhado (respectivamente, exclusivo) sobre o objeto.<li><p>Todos os bloqueios mantidos por uma transação são liberados quando a transação termina.</p><li>Uma transação que tenha um bloqueio exclusivo também pode ler o objeto; não é exigido um bloqueio compartilhado adicional. Uma transação que solicita um bloqueio é suspensa até que o SGBD seja capaz de garantir-lhe o bloqueio solicitado. O SGBD monitora os bloqueios que concedeu e garante que, se uma transação mantiver um bloqueio exclusivo sobre um objeto, nenhuma outra transação manterá um bloqueio compartilhado ou exclusivo sobre o mesmo objeto.<li>Os pedidos para adquirir e liberar bloqueios podem ser inseridos automaticamente nas transações pelo SGBD; os usuários não precisam se preocupar com esses detalhes. Na verdade, o protocolo de bloqueio só permite intercalações “seguras” de transações. Se duas transações acessam partes completamente independentes do banco de dados, elas obtêm concorrentemente os bloqueios que precisam e seguem seu caminho normalmente. Por outro lado, se duas transações acessam o mesmo objeto e uma quer modificá-lo, suas ações são efetivamente ordenadas em série – todas as ações de uma dessas transações (aquela que recebe primeiro o bloqueio sobre o objeto comum) são concluídas antes (que esse bloqueio seja liberado) e que a outra transação possa prosseguir.</ol><p>Outro conjunto de protocolos de controle de concorrência, utiliza rótulos de tempo (timestamp). Um rótulo de tempo é um identificador exclusivo para cada transação gerado pelo sistema. Os valores de rótulo de tempo são gerados na mesma ordem que os tempos de início de transação.</p><h2 id="performance--conhecer-técnicas-de-otimização-de-consultas-consultas-índices"><span class="mr-2">Performance – conhecer técnicas de otimização de consultas (consultas, índices)</span><a href="#performance--conhecer-técnicas-de-otimização-de-consultas-consultas-índices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Enumerar planos alternativos para avaliar a expressão. Normalmente, o otimizador considera um subconjunto de todos os planos possíveis, pois o número deles é muito grande.<li>Estimar o custo de cada plano enumerado e escolher o plano com o custo estimado mais baixo. Para serem realizadas, as consultas SQL são otimizadas pela sua decomposição em um conjunto de unidades menores chamadas blocos. Um otimizador de consultas relacional típico se concentra na otimização de um único bloco por vez. Para isso, uma consulta é decomposta em blocos, e a otimização de um único bloco pode ser compreendida em termos de planos constituídos de operadores da álgebra relacional. Para cada nó na árvore, devemos estimar o custo da execução da operação correspondente. Os custos são afetados significativamente pelo fato de se usar pipelining ou se relações temporárias são criadas para passar a saída de um operador para seu ascendente. Para cada nó na árvore, devemos estimar o tamanho do resultado e verificar se ele está ordenado. Esse resultado é a entrada para a operação que corresponde ao ascendente do nó corrente e, por sua vez, o tamanho e a ordem afetam a estimativa de tamanho, o custo e a ordem do ascendente. Utilização de índices nos SGBDRs:</ul><p>IBM DB2: Ao criar um índice, o usuário pode especificar um conjunto de colunas ‘de inclusão’ que devem ser mantidas no índice, mas que não fazem parte da chave do índice. Isso possibilita que um conjunto mais rico de consultas somente de índice seja manipulado, pois as colunas acessadas frequentemente são incluídas no índice, mesmo que não façam parte da chave.</p><p>Microsoft SQL Server: Considerada uma classe interessante de planos somente de índice, suponha uma consulta que seleciona atributos salário e idade a partir de uma tabela, dado um índice em salário e outro em idade.</p><p>SQL Server: Associando as entradas por junção no rid dos registros de dados para identificar os pares (salário, idade) que aparecem na tabela.</p><p>Representação de índice:</p><ol><li><p>Caminho de acesso com um único índice: Se vários índices correspondem às condições de seleção na cláusula WHERE, cada índice correspondente oferece um caminho de acesso alternativo. Um otimizador pode escolher o caminho de acesso que, segundo sua estimativa, vai resultar na recuperação do menor número de páginas, e pode aplicar projeções e termos de seleção não primários (isto é, partes da condição de seleção que não correspondem ao índice), e pode passar a calcular as operações de agrupamento e agregação (ordenando nos atributos de GROUP BY).</p><li><p>Caminho de acesso com vários índices: Se vários índices usando as alternativas (2) ou (3) para entradas de dados corresponderem à condição de seleção, cada índice poderá ser usado para recuperar um conjunto de rids. Podemos fazer a intersecção desses conjuntos de rids e, depois, ordenar o resultado pelo id da página (supondo que a representação de rid inclua o id da página) e recuperar as tuplas que satisfazem os termos da seleção primária de todos os índices correspondentes. Todas as projeções e termos de seleção não primários podem, então, ser aplicados, seguidos das operações de agrupamento e agregação.</p><li><p>Caminho de acesso com índice ordenado: Se a lista de atributos de agrupamento for um prefixo de um índice de árvore, o índice pode ser usado para recuperar as tuplas na ordem exigida pela cláusula GROUP BY. Todas as condições de seleção podem ser aplicadas em cada tupla recuperada, os campos indesejados podem ser removidos e as operações agregadas podem ser calculadas para cada grupo. Essa estratégia funciona bem para índices agrupados.</p><li><p>Caminho de acesso somente de índice: Se todos os atributos mencionados na consulta (nas cláusulas SELECT, WHERE, GROUP BY ou HAVING) estiverem incluídos na chave de pesquisa para algum índice denso na relação da cláusula FROM, uma varredura somente de índice poderá ser usada para calcular as respostas. Como as entradas de dados no índice contêm todos os atributos de uma tupla necessários para essa consulta e há apenas uma entrada de índice por tupla, nunca precisamos recuperar tuplas reais da relação. Usando apenas as entradas de dados do índice, podemos executar os passos a seguir, conforme for necessário, em determinada consulta: aplicar as condições de seleção, remover os atributos indesejados, ordenar o resultado para obter agrupamento e calcular as funções agregadas dentro de cada grupo. Essa estratégia somente de índice funciona mesmo que o índice não corresponda às seleções da cláusula WHERE. Se o índice corresponder à seleção, precisamos examinar apenas um subconjunto das entradas de índice; caso contrário, devemos percorrer todas as entradas de índice. Em qualquer caso, podemos evitar a recuperação de registros de dados reais; portanto, o custo desta estratégia não depende de o índice ser agrupado. Além disso, se é um índice de árvore e a lista de atributos na cláusula GROUP BY forma um prefixo da chave do índice, podemos recuperar as entradas de dados na ordem necessária para a cláusula GROUP BY e, com isso, evitar a ordenação.</p></ol><h1 id="data-warehouse">Data warehouse</h1><p>Um data warehouse tem a característica distintiva de servir principalmente para a aplicação de apoio à decisão, sendo utilizados para recuperar dados e não para processamento de transação de rotina, o que implica diretamente que os data warehouse são muito distintos dos bancos de dados tradicionais em sua estrutura, funcionamento, desempenho e finalidade.</p><p>OLAP – Processamento analítico on-line: É um termo usado para descrever a análise de dados complexos do data warehouse. Nas mãos de trabalhadores do conhecimento habilidoso, as ferramentas OLAP utilizam capacidades de computação distribuída para análises que exigem mais armazenamento e poder de processamento do que pode estar localizada econômica e eficientemente em um desktop individual.</p><p>DSS sistema de apoio à decisão: Também conhecido como sistema de informações executivas. Não confunda com sistemas de integração empresarial; ajudam os principais tomadores de decisões de uma organização com dados de nível mais alto em decisões complexas e importantes.</p><p>Mineração de dados: É usada para descoberta do conhecimento – o processo de procurar novo conhecimento imprevisto nos dados. Estudaremos sobre este assunto em breve.</p><p>Mineração de dados É usada para descoberta do conhecimento – o processo de procurar novo conhecimento imprevisto nos dados. Estudaremos sobre este assunto em breve. Banco de dados tradicionais versus data warehouse:</p><ul><li>Banco de dados tradicionais: O suporte para processamento de transação on-line (OLTP) que lida com inserções, atualizações e exclusões, enquanto também tem suporte para requisitos de consulta de informação. Os bancos de dados relacionais tradicionais são utilizados para processar consultas que podem tocar em uma pequena parte do banco de dados e transações que lidam com inserções ou atualizações no processo de algumas duplas por relação, assim eles não podem ser utilizados para OLPA, DSS ou mineração de dados.<li>Data warehouses: São projetados exatamente para dar suporte à extração, processamento e apresentação eficiente para fins analíticos e de tomada de decisão. Em comparação com os bancos de dados tradicionais, os data warehouses em geral contêm quantidades muito grandes de dados de várias fontes, que podem incluir bancos de dados de diferentes modelos de dados, e às vezes arquivos adquiridos de sistemas e plataformas independentes.</ul><h2 id="modelagem-de-dados-para-data-warehouse"><span class="mr-2">Modelagem de dados para data warehouse</span><a href="#modelagem-de-dados-para-data-warehouse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Para modelagem de dados deve ser levada em consideração a tipologia. Em modelos multidimensionais ocorre o relacionamento dos dados em matrizes multidimensionais, que são chamadas de cubo de dados. Também pode ocorrer de haver mais de três dimensões e, nesse caso, a nominação é hipercubo. A mudança de hierarquia de uma orientação unidimensional para outra é algo feito com facilidade em um cubo de dados com uma técnica chamada de giro, que também pode ser chamada de rotação. Nessa técnica, o cubo de dados pode ser imaginado girando para mostrar uma orientação diferente dos eixos. Modelos multidimensionais atendem prontamente a visões hierárquicas, conhecidas como exibição roll-up ou exibição drill-down. Uma exibição roll-up sobe na hierarquia, agrupando em unidades maiores ao longo de uma dimensão. Uma exibição drill-down oferece a capacidade oposta, fornecendo uma visão mais detalhada. O modelo de armazenamento multidimensional envolve dois tipos de tabelas: a tabela de dimensão, que consiste em tuplas de atributos da dimensão, e a tabela de fatos, que pode ser imaginada como sendo tuplas, uma para cada fato registrado. Esse fato contém alguma variável observada e a identifica com ponteiros para tabelas de dimensão, podendo ser uma ou várias variáveis. A tabela de fatos contém os dados, e as dimensões identificam cada tupla nesses dados. Dois esquemas multidimensionais comuns são o esquema estrela e o esquema floco de neve. O esquema estrela consiste em uma tabela de fatos com uma única tabela para cada dimensão. O esquema floco de neve é uma variação do esquema estrela, em que as tabelas dimensões de um esquema estrela são organizadas em uma hierarquia ao normalizá-las.</p><h2 id="projeto-de-data-warehouse"><span class="mr-2">Projeto de data warehouse</span><a href="#projeto-de-data-warehouse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>Os dados precisam ser extraídos de várias fontes heterogêneas. Por exemplo, banco de dados ou outras entradas de dados, como aquelas que contêm dados do mercado financeiro ou dados ambientais.<li>Os dados precisam ser formatados por coerência dentro do data warehouse. Nomes, significados e domínios de dados de fontes não relacionadas precisam ser reconciliados. Por exemplo, empresas subsidiárias de grandes corporações podem ter diferentes calendários fiscais com trimestres terminados em datas diferentes, tornando difícil agregar dados financeiros por trimestre.<li>Os dados precisam ser limpos para garantir a validade. A limpeza de dados é um processo complicado e complexo, que tem sido identificado como componente que mais exige trabalho na construção do data warehouse. A entrada de dados precisa ser examinada e formatada de modo consistente, sendo verificada a validade e a qualidade. Reconhecer dados errôneos e incompletos é difícil de automatizar, e a limpeza que requer correção de erro automática pode ser ainda mais complicada. Por exemplo, pode-se exigir que “Cidade=Campinas” junto com o “Estado=RJ” seja reconhecido como uma combinação incorreta. Depois que tais problemas tiverem sido resolvidos, dados semelhantes de fontes diferentes precisam ser coordenados para carregar no data warehouse. O processo de retornar dados limpos para origem é chamado de fluxo reverso.<li>Os dados precisam ser ajustados ao modelo de dados do armazém. Baixar os dados de várias fontes que devem ser instalados no modelo de dados no data warehouse. Eles podem ter que ser convertidos de banco de dados relacionais, orientados a objetos ou legados (em rede e/ou hierárquico) para um modelo multidimensional.<li>Os dados precisam ser carregados no data warehouse. O grande volume de dados torna a carga dos dados uma tarefa significativa; são necessárias ferramentas de monitoramento para cargas, bem como métodos para recuperação de cargas incompletas ou incorretas. Com o imenso volume de dados no data warehouse, a atualização incremental normalmente é a única técnica viável. Processos armazenamento de dados:<ul><li>Armazenamento dos dados de acordo com o modelo de dados do armazém; * Criação e manutenção das estruturas de dados exigidas;<li>Criação e manutenção dos caminhos de acesso apropriados;<li>Fornecimento de dados variáveis no tempo à medida que novos dados são incluídos;<li>Suporte e atualização dos dados do data warehouse;<li>Atualização dos dados;<li>Eliminação dos dados. Elementos para projeto do data warehouse:<li>Projeções de uso;<li>O ajuste de modelo de dados;<li>Características das fontes disponíveis;<li>Projeto do componente de metadados;<li>Projeto de componente modular;<li>Projeto de facilidade de gerenciamento de mudança;<li>Considerações de arquitetura distribuída e paralela. Existem duas arquiteturas distribuídas básicas: o data warehouse distribuídos e o data warehouse federado.</ul></ol><p>Data warehouses em nível empresarial: São imensos projetos que exigem investimento maciço de tempo e recursos.</p><p>Data warehouses virtuais: Oferecem visões de banco de dados operacionais que são materializadas para acesso eficiente</p><p>Data marts: Em geral são voltados para um subconjunto da organização como um departamento e possuem um foco mais estreito.</p><p>Funcionalidades pré-programadas:</p><p>Roll-up: Os dados são resumidos com generalização cada vez maior, por exemplo: semanal para trimestral para anual.</p><p>Drill-down: Níveis cada vez maiores de detalhes são revelados (complemento de roll-up).</p><p>Giro: É realizada a tabulação cruzada, também conhecida como rotação.</p><p>Slice e dice: Operações de projeção são realizadas nas dimensões.</p><p>Ordenação: Os dados são ordenados por valor ordinal.</p><p>Seleção: Os dados estão disponíveis por valor ou intervalo.</p><p>Atributos derivados (calculados): Atributos são calculados por operações sobre valores armazenados e derivados.</p><h1 id="data-mining">Data Mining</h1><p>Consiste em encontrar tendências ou padrões interessantes em grandes conjuntos de dados para orientar decisões sobre atividades futuras. Há uma expectativa geral de que as ferramentas de mineração de dados deverão identificar esses padrões nos dados com entrada de usuário mínima. Os padrões identificados por essas ferramentas podem fornecer ao analista de dados ideias úteis e inesperadas que podem ser melhor investigadas subsequentemente, talvez se usando outras ferramentas de apoio à decisão. Objetivos da mineração de dados: previsão, identificação, classificação, otimização. Está relacionada à subárea da estatística chamada análise de dados exploratória, que tem objetivos semelhantes e conta com medidas estatísticas. Fases da descoberta de conhecimento nos bancos de dados (KDD - Knowledge Discovery in Database): Seleção dos dados, limpeza, mineração (enriquecimento e transformação), avaliação (limpeza). Nova informação gerada: regras de associação, padrões sequenciais e árvores de classificação. Conhecimento descoberto na mineração de dados: regras de associação, hierarquia de classificação, padrões sequenciais, padrões dentro da série temporal e agrupamento.</p><h1 id="banco-de-dados-distribuídos">Banco de dados distribuídos</h1><p>Uma coleção de múltiplos bancos de dados logicamente interrelacionados, distribuídos por uma rede de computadores, e um sistema de gerenciamento de banco de dados distribuído – SGBDD. Fatores para distribuição dos dados: Maior disponibilidade, Acesso distribuído aos dados, Análise de dados distribuídos. Propriedade esperada de um SGBDD: Independência dos dados distribuídos e Atomicidade da transação distribuída. Condições mínimas para um BDD: Conexões de nós de banco de dados por uma rede de computadores, Inter-relação lógica dos bancos de dados conectados e Ausência de restrição de homogeneidade entre os nós conectados. Problemas abordados no controle de usuário e recuperação de dados: Manipulação de várias cópias de itens de dados, Falhas em pontos da rede, Falhas na comunicação, Falha em commit e Deadlock. Funções adicionais dos bancos de dados distribuídos: Acompanhar a distribuição de dados, Processamento de consulta distribuído, Gerenciamento de transação distribuído, Gerenciamento de dados replicado, Recuperação de banco de dados distribuído, Segurança e Gerenciamento de diretório (catálogo) distribuído. Vantagens dos bancos de dados distribuídos: Maior facilidade e flexibilidade de desenvolvimento da aplicação, Maior confiabilidade e disponibilidade, Maior desempenho e Expansão mais fácil. Funções necessárias de um BDD:</p><ul><li>Controle de distribuição, fragmentação e replicação dos dados por meio de extensão no catálogo do SGBDD.<li>Capacidade de processar consultas distribuídas, acessando, por meio de uma rede de comunicação, localizações remotas para extrair os dados.<li>Gerenciamento de consultas e transações que acessam dados a partir de vários locais, ao mesmo tempo em que mantém o acesso sincronizado e a integridade do próprio banco de dados.<li>Capacidade de decidir qual cópia de um item de dado que se encontra replicado deve ser considerada.<li>Recuperação do banco de dados distribuído quando houver alguma falha ou colapso do sistema (os comumente denominados crashs).<li>Segurança na execução de transações distribuídas e gerenciamento de privilégios de autorização/acesso por parte dos usuários.<li>Gerenciamento do catálogo do banco de dados distribuído, de forma que contenha informação referente às localizações dos bancos. Esse catálogo pode ser geral a todo o banco ou local para cada nó da rede envolvida do processo. Desvantagens causadas por problemas com sistemas de gerenciamentos de bancos de dados federados: Diferenças nos modelos de dados, Diferenças nas restrições, Diferenças nas linguagens de consulta, Heterogeneidade semântica, Autonomia de projeto do sistema de bancos de dados. Desvantagens causadas por problemas encontrados no controle de concorrência e recuperação de um BDD: Lidar com múltiplas cópias dos itens de dados, Falha de sites individuais, Falha dos links de comunicação, Confirmação distribuída e Deadlock distribuído. Dois tipos de arquiteturas de sistema multiprocessador: Arquitetura de memória compartilhada (altamente acoplada) e Arquitetura de disco compartilhado (livremente acoplada).</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/estudos-faculdade/'>Estudos-faculdade</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/banco-de-dados/" class="post-tag no-text-decoration" >banco-de-dados</a> <a href="/tags/seguran%C3%A7a/" class="post-tag no-text-decoration" >segurança</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Esta postagem está licenciada sob <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> pelo autor.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Compartilhar</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Anota%C3%A7%C3%B5es+sobre+Recupera%C3%A7%C3%A3o+de+banco+de+dados+e+seguran%C3%A7a+-+Flutter%2FDart+Blog&url=https%3A%2F%2Fblog.joaonogueira.dev%2F%2Fposts%2Frecupera%25C3%25A7%25C3%25A3o-banco-dados-seguran%25C3%25A7a%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Anota%C3%A7%C3%B5es+sobre+Recupera%C3%A7%C3%A3o+de+banco+de+dados+e+seguran%C3%A7a+-+Flutter%2FDart+Blog&u=https%3A%2F%2Fblog.joaonogueira.dev%2F%2Fposts%2Frecupera%25C3%25A7%25C3%25A3o-banco-dados-seguran%25C3%25A7a%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.joaonogueira.dev%2F%2Fposts%2Frecupera%25C3%25A7%25C3%25A3o-banco-dados-seguran%25C3%25A7a%2F&text=Anota%C3%A7%C3%B5es+sobre+Recupera%C3%A7%C3%A3o+de+banco+de+dados+e+seguran%C3%A7a+-+Flutter%2FDart+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copie o link" data-title-succeed="Link copiado com sucesso!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Atualizados recentemente</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/arquitetura-android/">A arquitetura Android e componentes de aplicativo</a><li><a href="/posts/fluttererror-erro-ao-carregar-assets/">FlutterError - erro ao carregar assets</a><li><a href="/posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/">Anotações sobre Recuperação de banco de dados e segurança</a><li><a href="/posts/javascript/">Anotações sobre Javascript</a><li><a href="/posts/fundamentos-sistemas-informacao/">Anotações sobre Fundamentos de Sistemas de Informação</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/jakarta/">jakarta</a> <a class="post-tag" href="/tags/gest%C3%A3o/">gestão</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/banco-de-dados/">banco-de-dados</a> <a class="post-tag" href="/tags/seguran%C3%A7a/">segurança</a> <a class="post-tag" href="/tags/css/">css</a> <a class="post-tag" href="/tags/dados/">dados</a> <a class="post-tag" href="/tags/git/">git</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Conteúdo</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Leia também</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/firewalls/"><div class="card-body"> <em class="timeago small" data-ts="1582891200" > 2020-02-28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Tipos de firewalls e suas facilidades</h3><div class="text-muted small"><p> Tipos de Firewalls • (Stateless) Packet filtering – PF O PF é um firewall que realiza a filtragem de pacotes IP individuais baseado em regras que determinam se cada pacote será transmitido ou des...</p></div></div></a></div><div class="card"> <a href="/posts/aspectos-legais-computacao-forense/"><div class="card-body"> <em class="timeago small" data-ts="1587121200" > 2020-04-17 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Anotações sobre Aspectos legais da computação forense</h3><div class="text-muted small"><p> 1. Aspectos legais da computação forense Computação forense é a atividade técnica-científica capaz de colher informações que permitam identificar atividades realizadas dentro de um ambient...</p></div></div></a></div><div class="card"> <a href="/posts/banco-dados/"><div class="card-body"> <em class="timeago small" data-ts="1596798000" > 2020-08-07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Anotações sobre Banco de Dados</h3><div class="text-muted small"><p> 1 Conceitos Base de Banco de Dados Medeiros (2013, p. 15) define “banco de dados (ou, abreviadamente, BD) como sendo um conjunto de dados com certa organização característica, com o objetivo de ar...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/intera%C3%A7%C3%A3o-humano-computador/" class="btn btn-outline-primary" prompt="Anterior"><p>Anotações sobre Interação Humano-Computador</p></a> <a href="/posts/javascript/" class="btn btn-outline-primary" prompt="Próximo"><p>Anotações sobre Javascript</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/joaoffnogueira">João F. F. Nogueira</a>. <span data-toggle="tooltip" data-placement="top" title="Exceto onde indicado de outra forma, as postagens do blog neste site são licenciadas sob a Creative Commons Attribution 4.0 International (CC BY 4.0) License pelo autor.">Alguns direitos reservados.</span></p></div><div class="footer-right"><p class="mb-0"> Feito com <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> usando o tema <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> .</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/jakarta/">jakarta</a> <a class="post-tag" href="/tags/gest%C3%A3o/">gestão</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/banco-de-dados/">banco-de-dados</a> <a class="post-tag" href="/tags/seguran%C3%A7a/">segurança</a> <a class="post-tag" href="/tags/css/">css</a> <a class="post-tag" href="/tags/dados/">dados</a> <a class="post-tag" href="/tags/git/">git</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! Nenhum resultado encontrado.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/pt.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-7RCXJ5XJWN"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-7RCXJ5XJWN'); }); </script>

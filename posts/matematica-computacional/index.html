<!DOCTYPE html><html lang="pt-BR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Anotações sobre Matemática Computacional" /><meta name="author" content="João F. F. Nogueira" /><meta property="og:locale" content="pt_BR" /><meta name="description" content="1 Sistemas de Numeração, Lógica e Aritmética Binária, Conversão de Base" /><meta property="og:description" content="1 Sistemas de Numeração, Lógica e Aritmética Binária, Conversão de Base" /><link rel="canonical" href="https://blog.joaonogueira.dev//posts/matematica-computacional/" /><meta property="og:url" content="https://blog.joaonogueira.dev//posts/matematica-computacional/" /><meta property="og:site_name" content="Flutter/Dart Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-21T08:00:00-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Anotações sobre Matemática Computacional" /><meta name="twitter:site" content="@joaoffnogueira" /><meta name="twitter:creator" content="@João F. F. Nogueira" /><meta name="google-site-verification" content="G-7RCXJ5XJWN" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"João F. F. Nogueira"},"dateModified":"2022-03-22T20:20:28-03:00","datePublished":"2020-02-21T08:00:00-03:00","description":"1 Sistemas de Numeração, Lógica e Aritmética Binária, Conversão de Base","headline":"Anotações sobre Matemática Computacional","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joaonogueira.dev//posts/matematica-computacional/"},"url":"https://blog.joaonogueira.dev//posts/matematica-computacional/"}</script><title>Anotações sobre Matemática Computacional | Flutter/Dart Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Flutter/Dart Blog"><meta name="application-name" content="Flutter/Dart Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/logo.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Flutter/Dart Blog</a></div><div class="site-subtitle font-italic">por João Fernando Ferrari Nogueira - Desenvolvedor Flutter | Android | Windows | Web</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIAS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARQUIVOS</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>SOBRE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/joaoffnogueira" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/joaoffnogueira" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dev.joaonogueira','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Anotações sobre Matemática Computacional</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Buscar..."> </span> <span id="search-cancel" >Cancelar</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Anotações sobre Matemática Computacional</h1><div class="post-meta text-muted"><div> Por <em> João F. F. Nogueira </em></div><div class="d-flex"><div> <span> Postado em <em class="timeago" data-ts="1582282800" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-02-21 </em> </span> <span> Atualizado <em class="timeago" data-ts="1647991228" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-03-22 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="10480 palavras"> <em>58 min</em> de leitura</span></div></div></div><div class="post-content"><h2 id="1-sistemas-de-numeração-lógica-e-aritmética-binária-conversão-de-base"><span class="mr-2">1 Sistemas de Numeração, Lógica e Aritmética Binária, Conversão de Base</span><a href="#1-sistemas-de-numeração-lógica-e-aritmética-binária-conversão-de-base" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="sistemas-de-numeração"><span class="mr-2">Sistemas de numeração</span><a href="#sistemas-de-numeração" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Sistema de numeração decimal: posicional</p><p>N = {0,1,2,3,4,5,6,7,8,9}</p><p>$\beta =10$</p><p>A posição do símbolo no número refere-se ao expoente da base do sistema. Ex: $(153)_{10}=153=(1\times10^2)+(5\times10^1)+(3\times10^0)$</p><p>· Sistema de numeração octal</p><p>N = {0,1,2,3,4,5,6,7}</p><p>$\beta =8$</p><p>Ex: $(153)<em>8= (107)</em>{10} = (1\times8^2)+(5\times8^1)+(3\times8^0)$</p><p>· Sistema de numeração hexadecimal</p><p>N = {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}</p><p>$\beta =16$</p><p>Ex: $(153)<em>{16}=(339)</em>{10}=(1\times16^2)+(5\times16^1)+(3\times16^0)$</p><p>· Sistema de numeração binário</p><p>N = {0,1}</p><p>$\beta =2$</p><p>Ex: $(1001 1001)<em>2= (153)</em>{10}$</p><h3 id="conversão-entre-sistemas"><span class="mr-2">Conversão entre sistemas</span><a href="#conversão-entre-sistemas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>$(abc,de)<em>\beta=(a\beta^2+b\beta^1+c\beta^0+d\beta^{-1}+e\beta^{-2})</em>{10}$</p><p>Para convertermos um valor expresso no sistema decimal (base 10) para um sistema de base β fazemos divisões sucessivas do número na base 10 pela base β, até que o quociente seja menor que β. Isto se aplica à conversão da parte inteira do valor. Já para o valor fracionário devemos fazer multiplicações sucessivas pela base β até obtermos um valor exclusivamente inteiro. Ao efetuarmos cada multiplicação devemos descartar a parte inteira da multiplicação anterior.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-1.png" alt="Conversão entre sistemas" width="100" height="100" data-proofer-ignore></p><p>$(0,828125)<em>{10}=(?)_2$ $0,828125\times2=\textbf{1},65625$ $0,65625\times2=\textbf{1},3125$ $0,3125\times2=\textbf{0},625$ $0,625\times2=\textbf{1},25$ $0,25\times2=\textbf{0},50$ $0,50\times2=\textbf{1}$ $(0,828125)</em>{10}=(0,110101)_2$</p><p>Uma opção para fazer a conversão entre sistemas é a substituição direta, que é possível nos casos da conversão dos sistemas hexadecimal e octal para binário, ou vice-versa. Isso porque as bases destes sistemas, 16 e 8, são potências de 2.</p><p><strong>Três dígitos binários para cada dígito octal, já que 23 = 8</strong></p><p><strong>Quatro dígitos binários para cada digito hexadecimal, já que 24 = 16</strong></p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-2.png" alt="Conversão entre sistemas" width="100" height="100" data-proofer-ignore></p><h3 id="erros-de-conversão"><span class="mr-2">Erros de conversão</span><a href="#erros-de-conversão" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>1. Os erros de precisão, que ocorrem em função da quantidade insuficiente de dígitos para representar o valor. Nos sistemas de computação digital o número de dígitos binários usados para representar os números é geralmente pré-definido e limitado: caso haja a necessidade de representar um valor com uma quantidade de dígitos maior que o limite, ocorrerá um erro de precisão. Esta ocorrência é típica das variáveis em programas de computador.</p><p>2. Os erros de exatidão ocorrem quando há a aproximação, o arredondamento ou a ocorrência de dízimas periódicas. Neste caso, devido à limitação do número de dígitos ou da capacidade de cálculo, geralmente há uma interrupção inesperada da representação.</p><p>O limite de precisão resulta em truncamento, e afeta principalmente os cálculos com os números irracionais, com o número π (Pi). Em geral este número é representado com duas casas decimais, como 3,14, porém as calculadoras podem representá-lo com oito casas decimais (3,1415926), o que é razoável para maioria dos cálculos. Porém, em cálculos mais extensos é necessário usar uma maior precisão, tal como a representação do Pi com cinquenta e duas casas decimais</p><p>O erro absoluto é a diferença entre o valor real e a forma na qual foi expresso. Calculamos o erro absoluto pela seguinte fórmula: $EA_x=x-\overline{x}$</p><p>O erro relativo é a razão entre o erro absoluto EA e o valor real x, isto é: $ER_x=\frac{EA_x}{x}$</p><h3 id="lógica-binária"><span class="mr-2">Lógica binária</span><a href="#lógica-binária" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· NOT: “não” ou “negação” $\sim A$ ou $\overline{A}$</p><p>· AND: “e” &amp; (Ampersand) ^</p><p>· OR: “ou” + v</p><p>· XOR: “ou exclusivo” $\oplus$</p><p>· SHIFT: “deslocamento”</p><p>A operação binária de deslocamento (ou rotação) de bits efetua a divisão ou multiplicação por 2 (e por seus múltiplos). Dado um número binário, ao deslocarmos os bits da direta para a esquerda em uma posição (operação representada pelo sinal &lt;&gt;), dividimos o valor por 2, com o resultado inteiro.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-3.png" alt="operação binária de deslocamento" width="100" height="100" data-proofer-ignore></p><h3 id="aritmética-binária"><span class="mr-2">Aritmética Binária</span><a href="#aritmética-binária" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>A adição ou soma binária assemelha-se à soma decimal, incluindo a operação de “vai-um” – que aqui denominamos Carry Out, porém utilizando somente os dígitos do sistema de numeração binário (zero e um).</p><p>$0+0=0$</p><p>$0+1=1$</p><p>$1+0=1$</p><p>$1+1=0$ e “vai um” (<em>Carry Out</em>=1)</p><p>$1+1+1=1$ e “vai um” (<em>Carry Out</em>=1)</p><p>$0\times0=0$</p><p>$0\times1=0$</p><p>$1\times0=0$</p><p>$1\times1=1$</p><p>$0-0=0$</p><p>$0-1=1$ e “pede emprestado” 1 ao dígito da esquerda</p><p>$1-0=1$</p><p>$1-1=0$</p><p>O modelo da divisão binária segue o mesmo processo da divisão em decimal, operando inclusive com os mesmos componentes.</p><h2 id="2-estrutura-de-dados-ponto-flutuante-grafos-contagem"><span class="mr-2">2 Estrutura de Dados, Ponto Flutuante, Grafos, Contagem</span><a href="#2-estrutura-de-dados-ponto-flutuante-grafos-contagem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="estruturas-de-dados"><span class="mr-2">Estruturas de dados</span><a href="#estruturas-de-dados" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Vetores: Os vetores têm seus elementos posicionados em sequência, e esses elementos são acessados usando-se uma chave, o índice do vetor. Os vetores integram os elementos de dados que são fundamentais para a resolução de problemas por meio da organização dos dados em programas de computador. Vetores também representam segmentos de reta na geometria – uma sequência de pontos que forma a reta, sendo dessa forma um elemento gráfico. Em ambientes de computação, os vetores fazem parte das estruturas de dados homogêneas, por conter somente dados de um único tipo.</p><p>· Matrizes: Em computação as matrizes são um tipo de arranjo de vetores com duas ou mais dimensões, cujos dados contêm características comuns. Esses dados são organizados sequencialmente e, tal como os vetores, acessados por meio da chave – ou índice – da matriz. As matrizes também fazem parte das estruturas de dados essenciais para o tratamento de problemas matemáticos em ambientes computacionais, especialmente os de computação gráfica. As matrizes também são um tipo de estrutura de dados homogêneas, ou, como já dissemos, um tipo de arranjo de vetores, em que cada vetor corresponde à uma dimensão da matriz. As aplicações de planilhas de dados, como o Microsoft Excel, por exemplo, são a representação mais típica das matrizes. Também os elementos de imagens, tais como os desenhos, as fotografias e os filmes, são compostos por matrizes multidimensionais. A tela do computador que você está usando neste momento é uma matriz visível, na qual cada minúsculo ponto (ou pixel) representa um elemento com várias dimensões, tais como cor, posição e intensidade luminosa (brilho/contraste).</p><p>· Conjuntos: Os conjuntos são agrupamentos ou coleções de objetos – denominados elementos ou membros do conjunto –, cujas características são comuns entre si. Os conjuntos são geralmente representados por uma letra maiúscula, e os seus elementos são expressos entre chaves. Podemos também representar os conjuntos em sua forma gráfica com o diagrama de Venn.</p><h3 id="aritmética-de-ponto-flutuante"><span class="mr-2">Aritmética de ponto flutuante</span><a href="#aritmética-de-ponto-flutuante" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Os computadores representam os números reais, com a Aritmética de Ponto Flutuante, formulada por F[β, t, -p, p], representando o sistema F do sistema de numeração de base β com a quantidade t de dígitos na mantissa – ou dígitos significativos, e limites de expoente de -p até p. Os números desse sistema são então expressos no seguinte formato:</p><p>± (0,𝒅𝟏𝒅𝟐 … 𝒅𝒕 )$β^e$</p><p>No qual:</p><p>β é a base do sistema de numeração com o qual o computador opera (geralmente 2, ou binária, para a computação digital);</p><p>d é um dos dígitos da mantissa, cuja quantidade máxima é definida por t;</p><p>e representa o expoente, cujo intervalo é definido por p, variando de -p até p.</p><p>Por exemplo: Dado o sistema de representação F[10, 3, -5, 5], que significa β = 10, t = 3 e e ∈ [-5,5], temos então:</p><p>O menor número, em valores absolutos (m), é 0,001 x 10-5 , ou seja, 10-8 ;</p><p>O maior número, em valores absolutos (M), é 0,999 x 105 , ou seja, 99900.</p><p>Se usarmos esse sistema para representar um dado número, como por exemplo N = 227,68 ou seja, N = 0,22768 x 103, será representado como 0,227 x 103 – caso a opção seja o truncamento ou corte – ou 0,228 x 103 , caso a opção seja o arredondamento.</p><p>Tabela - A precisão numérica definida pela norma IEEE 754</p><div class="table-wrapper"><table><thead><tr><th>Propriedade<th style="text-align: center">Precisão<th style="text-align: center">Precisão<th style="text-align: center">Precisão<tbody><tr><td>Propriedade<td style="text-align: center">Simples<td style="text-align: center">Dupla<td style="text-align: center">Estendida<tr><td>Total de bits<td style="text-align: center">32<td style="text-align: center">64<td style="text-align: center">80<tr><td>Bits da mantissa<td style="text-align: center">23<td style="text-align: center">52<td style="text-align: center">64<tr><td>Bits do expoente<td style="text-align: center">8<td style="text-align: center">11<td style="text-align: center">15<tr><td>Base<td style="text-align: center">2<td style="text-align: center">2<td style="text-align: center">2<tr><td>Exp. Máximo<td style="text-align: center">127<td style="text-align: center">1023<td style="text-align: center">16383<tr><td>Exp. Mínimo<td style="text-align: center">-126<td style="text-align: center">-1022<td style="text-align: center">-16382<tr><td>Maior nº<td style="text-align: center">$\cong3,40\times10^{38}$<td style="text-align: center">$\cong1,80\times10^{308}$<td style="text-align: center">$\cong1,19\times10^{4932}$<tr><td>Menor nº<td style="text-align: center">$\cong1,18\times10^{-38}$<td style="text-align: center">$\cong2,23\times10^{-308}$<td style="text-align: center">$\cong3,36\times10^{-4932}$<tr><td>Decimais<td style="text-align: center">7<td style="text-align: center">16<td style="text-align: center">20</table></div><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-4.png" alt="Representação dos números de precisão simples" width="100" height="100" data-proofer-ignore></p><p>· Adição e subtração: 1. Comparamos a magnitude dos expoentes dos operadores e nivelamos esses expoentes, ajustando o do número de menor valor (alinhamento); 2. Realizamos a operação (adição ou subtração); 3. Ajustamos a mantissa e o expoente do número resultante (normalização).</p><p>· Multiplicação: multiplicam-se as bases e somam-se os expoentes. Nesse caso, a base é a mantissa.</p><p>· Divisão: dividem-se as bases e subtraem-se os expoentes, lembrado que a base é a mantissa.</p><h3 id="erros"><span class="mr-2">Erros</span><a href="#erros" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Temos erros de precisão, decorrentes da limitação de dígitos usados para representar os valores – o número de dígitos é geralmente pré-definido em decorrência da utilização do sistema binário e da constituição do hardware. Este tipo de erro é comum em programação, no caso das variáveis utilizadas nos programas de computador. Por outro lado, a aproximação, o arredondamento ou a ocorrência de dízimas periódicas geram os erros de exatidão, devido à interrupção abrupta ou forçada da representação.</p><p>Nos ambientes computacionais, as operações com ponto flutuante podem resultar em interrupção do processamento, o que não é algo esperado. Essas operações são decorrentes basicamente de cinco tipos de operações – ou exceções:</p><p>1. O overflow é um resultado apresentado quando é gerado um resultado infinito ou muito além da capacidade de representação do sistema.</p><p>2. O underflow ocorre quando é obtido um resultado zero após um arredondamento de um valor diferente de zero, ou seja, um valor muito menor do que a capacidade de representação do sistema.</p><p>3. A divisão por zero geralmente é o resultado de um cálculo com um underflow ou valor pouco significativo para o sistema. Uma divisão por zero não possibilita qualquer solução matemática.</p><p>4. Um resultado inexato, apesar de ser algo que pode acontecer com relativa frequência, pode resultar tanto de um cálculo que gere overflow quanto de arredondamentos. Geralmente, essas ocorrências não geram uma interrupção do processo, porém podem, caso façam parte de um processo recorrente ou recursivo, se transformar em algo mais crítico, e por isso pode ser tratado como uma exceção.</p><p>5. Um número inválido é o resultado de uma operação que não pode ser considerado um número, conhecido pela sigla em inglês NaN – Not a Number, como por exemplo a raiz quadrada de um número negativo, uma divisão de zero por zero ou de infinito por infinito.</p><p>O cancelamento catastrófico é o nome que se dá ao efeito que ocorre quando um cálculo atinge o épsilon ε do sistema computacional. O épsilon do sistema é o menor número que, somado a 1, resulta em um número diferente de 1; ou seja, não é arredondado. O épsilon representa a precisão aritmética relativa da máquina, e é consequência da precisão finita da aritmética de ponto flutuante.</p><h3 id="elementos-matemáticos-computacionais"><span class="mr-2">Elementos matemáticos computacionais</span><a href="#elementos-matemáticos-computacionais" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Grafos: A estrutura gráfica utilizada em matemática para apresentar as relações entre os elementos ou objetos de um conjunto é denominada grafo. Grafos são expressos na forma de equação como G (V,A), na qual são representados seus dois elementos: os vértices e as arestas. Os elementos do conjunto – ou componentes, objetos – são representados por círculos ou pontos e denominados vértices. Já as relações, ligações, dependências ou “caminhos” entre os vértices são representados por segmentos de reta ou linhas, as arestas.</p><p>· Os grafos que têm suas arestas direcionadas são denominados grafos orientados (ou ainda grafos dirigidos, direcionados ou dígrafos). Um vértice pode ser ligado a ele próprio, formando um laço ou loop. As arestas podem conter rótulos de identificação, de peso ou valor numérico. Um grafo G é um grafo dirigido G = (V, A), tal que V = {A, B, C, D, E, F, G} e A = {(A,B), (B,C), (B,D), (B,E), (C,E), (D,E), (E,F), (G,D)}. Neste exemplo, é possível identificar rotas ou fluxos entre os vértices, traçando caminhos entre eles.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-5.png" alt="grafos" width="100" height="100" data-proofer-ignore></p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-6.png" alt="grafos" width="100" height="100" data-proofer-ignore></p><p>A representação de um grafo finito com n vértices pode ser feita por uma matriz de adjacência. Essa matriz tem as dimensões definidas pelo número de vértices (n-por-n), e o valor na linha i e coluna j fornece o número de arestas que conectam o i-ésimo ao j-ésimo vértices.</p><p>Um Grafo dirigido rotulado:</p><pre><code class="language-mermaid">graph LR
    A((A)) --&gt;|9| B((B))
    A --&gt;|4| B
    B --&gt;|3| B
    B --&gt;|6| E((E))
    E --&gt;|8| D((D))
    D --&gt;|7|E
    D--&gt;|7| A
    E--&gt;|5| F((F))
    C((C))
</code></pre><p>Uma matriz de adjacência com o respectivo grafo:</p><p>$A=\begin{vmatrix} 1 1 0 0 1 0<br /> 1 0 1 0 1 0<br /> 0 1 0 1 0 0<br /> 0 0 1 0 1 1<br /> 1 1 0 1 0 0<br /> 0 0 0 1 0 0 \end{vmatrix}$</p><pre><code class="language-mermaid">graph LR
    1((1)) ---1
    1---2((2))
    1---5((5))
    2---5
    2---3((3))
    5---4((4))
    3---4
    4---6((6))
</code></pre><p>· Em um dígrafo, contemplamos os graus de saída (o número de arestas saindo de um vértice) e de entrada (o número de arestas entrando em um vértice);</p><p>· O grau de um vértice de um dígrafo é igual à soma dos graus de saída e de entrada.</p><p>· <strong>Árvores:</strong> Uma árvore é um grafo conexo, aquele no qual sempre existe uma aresta entre dois quaisquer de seus vértices, e que é também acíclico, isto é, não existem ciclos ou loops. As árvores correspondem a uma das mais importantes estruturas de dados não lineares da computação.</p><p>Com relação à definição de árvores, podemos afirmar que nem todo grafo é uma árvore, mas que toda árvore é um grafo. Além disso, é um grafo bipartido, isto é, apresenta pelo menos dois níveis. Toda árvore também é um grafo planar, que é representado em um plano, em apenas duas dimensões. Por outro lado, todo grafo conexo inclui ao menos uma árvore de extensão associada a si, composta de todos os seus vértices e de algumas de suas arestas.</p><p>Para considerarmos um grafo G com n vértices como uma árvore, devemos verificar se esse grafo: · É conexo, e há um único caminho entre dois vértices quaisquer; deixará de ser conexo se qualquer aresta for removida; · É acíclico, tem n – 1 arestas, e ao se incluir uma nova aresta fecha-se um novo ciclo.</p><p>Se um determinado vértice da árvore é escolhido como especial, a árvore é denominada enraizada, e o vértice escolhido é denominado raiz. Uma árvore livre é aquela que não tem raiz. O número máximo de arestas – ou ramos – em um vértice – ou elemento – é chamado de ordem ou grau, e a máxima sequência de vértices de grau um ou maior define a quantidade de níveis de uma árvore.</p><p>· Árvore binária: A árvore binária é o tipo de árvore que a computação mais utiliza, e é definida como um grafo acíclico, conexo, dirigido. Cada nó tem grau (ou ordem) menos ou igual a. Cada ramo da árvore é um vértice dirigido, sem peso, que chega ao próximo (sucessor ou filho) a partir do seu anterior (antecessor ou pai), formando uma hierarquia, e fazendo com que só exista um único caminho entre dois nós distintos.</p><p>Os percursos possíveis em uma árvore binária são a leitura em pré-ordem, em ordem e em pós-ordem. Em “pré-Ordem” (ou RED = raiz, esquerda, direita) é acessado um nó raiz, depois seu sucessor da esquerda e em seguida o da direita. No acesso “em ordem” (In-Order ou ERD = esquerda, raiz, direita) é acessada uma folhada esquerda, sua raiz (ou predecessor), e depois o nó da direita. Já no acesso em “pós-ordem” (ou EDR = esquerda, direita, raiz), o acesso inicia-se pelo nó da esquerda, desloca-se para o da direita e então segue à raiz deles. A Figura 14 apresenta uma árvore binária com o acesso em pré-ordem (RED): F,B,A,D,C,E,G,I,H. Nessa mesma árvore, podemos ter o acesso em pósordem (EDR): A,C,E,D,B,H,I,G,F ou em ordem (ERD): A,B,C,D,E,F,G,H,I.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-7.png" alt="Árvore binária com acesso EDR" width="100" height="100" data-proofer-ignore></p><h3 id="contagem"><span class="mr-2">Contagem</span><a href="#contagem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Existe um princípio, denominado princípio fundamental da contagem, ou também princípio multiplicativo, que estabelece o seguinte: “quando um evento é composto por n etapas sucessivas e independentes, de tal modo que as possibilidades da primeira etapa é x e as possibilidades da segunda etapa é y, resulta no número total de possibilidades de o evento ocorrer, dado pelo produto (x) . (y)”</p><p>· Arranjo: Os arranjos são subconjuntos nos quais a ordem e a natureza fazem a diferença. Considerando um conjunto de n elementos, organizados em subconjuntos de p elementos, sendo p ≤ n, utilizamos a seguinte fórmula para o arranjo: $A_{n,p}=\frac{n!}{(n-p)!}$</p><p><strong>Permutação:</strong> A permutação nada mais é do que um caso específico de arranjo, no qual o número de elementos do conjunto (n) é igual ao número total de elementos. Isso resulta em que o denominador, na fórmula do arranjo, seja igual a uma unidade (1). A consequência é que a permutação é representada pela seguinte fórmula: $P_n=n!$</p><p><strong>Combinação:</strong> Diferentemente dos arranjos, as combinações são subconjuntos para os quais a ordem dos elementos não importa, porém, a sua natureza, sim. Deste modo, para obtermos uma combinação simples de n elementos combinados p a p, sendo ($p\le n$), recorremos à seguinte fórmula: $C_{n,p}=\frac{n!}{p!(n-p)!}$</p><h2 id="3-probabilidade"><span class="mr-2">3 Probabilidade</span><a href="#3-probabilidade" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Denomina-se probabilidade o processo pelo qual conseguimos estimar as chances de ocorrência de determinado fato determinado ou evento. É também a denominação de um ramo ou área da matemática que usa modelos para o estudo de experimentos ou ocorrências dos fenômenos ditos aleatórios. Estes eventos são aqueles nos quais há incerteza no que se refere às possibilidades de ocorrerem, ou seja, são prováveis ou improváveis.</p><p>O conjunto de resultados possíveis é denominado Espaço Amostral, e é representado pela letra S ou por Ω, a letra grega ômega.</p><p>Quando todos os elementos têm a mesma chance de ocorrência, são denominados equiprováveis.</p><h3 id="eventos"><span class="mr-2">Eventos</span><a href="#eventos" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Denominamos Evento qualquer elemento ou subconjunto, mesmo um unitário – que faz parte do espaço amostral.</p><p>Caso um evento coincida com a totalidade do espaço amostral, é chamado de evento certo, e o oposto, que resulta em um conjunto vazio, é dito evento impossível. Quando dois eventos não podem ocorrer de modo simultâneo, ou quando a ocorrência de um elimina a possibilidade da ocorrência de outro, então são chamados de eventos mutuamente exclusivos.</p><p>· Eventos complementares, isto é, a união deles resulta no espaço amostral e a interseção resulta em um conjunto vazio.</p><p>· Eventos mutuamente exclusivos: quando interseção de dois eventos resulta em um conjunto vazio isto significa que a ocorrência de um implica na impossibilidade da ocorrência do outro. $P(A)=\frac{n(A)}{n(S)}$</p><p>Dois eventos são ditos independentes quando a ocorrência ou a não ocorrência de um deles não influi na probabilidade da ocorrência do outro, e vice-versa.</p><p>União de eventos: $n(A\cup B)=n(A)+n(B)-n(A\cap B)$</p><p>Probabilidade de eventos complementares: $A\cup\overline{A}=S; A\cap\overline{A}=\emptyset$</p><h2 id="4-modelagem-matemática-máquinas-de-estado-autômatos-máquinas-de-mealy-e-turing"><span class="mr-2">4 Modelagem Matemática, Máquinas de Estado, Autômatos, Máquinas de Mealy e Turing</span><a href="#4-modelagem-matemática-máquinas-de-estado-autômatos-máquinas-de-mealy-e-turing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="máquina-de-estados"><span class="mr-2">Máquina de estados</span><a href="#máquina-de-estados" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· As máquinas de estado são uma forma matemática de abstrair processos ou o funcionamento de equipamentos reais, sejam eletrônicos ou mecânicos, e ainda dos softwares. Em outras palavras, as máquinas de estado são um modelo matemático de sistemas que possuem entradas e saídas discretas e a capacidade de representar, em um certo momento, um estado preestabelecido.</p><p>· As máquinas de estado também são chamadas autômatos, ou máquinas de estado finito (FSM – Finite State Machine, em inglês). Apesar de possuir a capacidade de representar múltiplos estados, uma FSM só pode apresentar-se em um estado por vez, denominado estado atual, sendo esta é principal característica de uma máquina de estados.</p><p>· Uma FSM pode ser representada por uma quíntupla (Q, ∑, δ, q0, F):</p><p>a. Q é um conjunto finito de estados;</p><p>b. ∑ é conjunto finito de símbolos, chamado de alfabeto da FSM;</p><p>c. δ é a função de transição, na qual δ: Q × ∑ → Q;</p><p>d. q0 é o estado inicial no qual qualquer entrada é processada (q0 ∈ Q);</p><p>e. F é um conjunto de estado/estados finais de Q (F ⊆ Q).</p><p>· A terminologia aplicada às FSM inclui os seguintes termos:</p><p>a. Alfabeto é um conjunto finito de símbolos. Por exemplo: ∑ = {a, b, c, d} é um conjunto do alfabeto no qual ‘a’, ‘b’, ‘c’, e ‘d’ são símbolos.</p><p>b. String é uma sequência finita de símbolos obtidos de ∑. Por exemplo, a string ‘cabcad’ é uma string válida do conjunto do alfabeto ∑ = {a, b, c, d}.</p><div class="table-wrapper"><table><tbody><tr><td>c. Comprimento de uma string é o número de elementos presentes na string, denotado por<td>S<td>. Por exemplo, se S = ‘cabcad’,<td>S<td>= 6. Se<td>S<td>= 0, então a string é chamada string vazia, denotada por λ or ε).</table></div><p>d. Fecho de Kleene ou Operador de Kleene, ∑*, é um operador unário ou um conjunto de símbolos ou strings ∑, dado um infinito conjunto de todas as possíveis strings de todos os possíveis comprimentos sobre ∑ incluindo λ. A representação: ∑* = ∑0 ∪ ∑1 ∪ ∑2 ∪……. ∑p é o conjunto de todas as strings possíveis de comprimento p. Por exemplo, se ∑ = {a, b}, ∑* = {λ, a, b, aa, ab, ba, bb, ………..}.</p><p>e. Fecho de Kleene / Mais, ∑+ é um conjunto infinito de possíveis strings de todos os possíveis comprimentos sobre ∑ excluindo λ. A representação é: ∑+ = ∑1 ∪ ∑2 ∪ ∑3 ∪……. ∑+ = ∑* − { λ }. Por exemplo, se ∑ = { a, b }, então ∑+ = { a, b, aa, ab, ba, bb, ………..}.</p><p>f. Linguagem é um subconjunto de ∑* para algum alfabeto ∑, que pode ser finito ou infinito. Por exemplo, se a linguagem L compreende todas as strings possíveis de comprimento 2 sobre ∑ = {a, b}, então L = { ab, aa, ba, bb}.</p><p>· A base do funcionamento de uma FSM é justamente isso: considerar que um estado armazena informações sobre as etapas anteriores, isto é, o passado do processo. Além disso, o estado reflete as mudanças ocorridas desde a entrada neste estado até o momento presente. Uma mudança de estado - geralmente descrita ou especificada por uma condição que precisa ser atendida ou ocorrer – refere-se à uma transição. Uma ação refere-se à uma atividade a ser realizada para gerar a transição, ou mesmo à uma atividade que ocorre em função de uma transição.</p><p>· Um diagrama de estado é a forma gráfica que utilizamos para representar o funcionamento de uma máquina de estado. As tabelas de transição de estado também podem representar as FSM - máquinas de estado.</p><pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; No_Térreo
    No_Térreo--&gt;Subindo: subir (andar)
    Subindo--&gt;Parado: subir (andar)
    Subindo--&gt;Parado: Chegar no andar
    Parado--&gt;Descendo: descer(andar)
    Descendo--&gt;Parado: Chegar no andar
    Parado--&gt;Indo_para_o_térreo: tempo de espera
    Indo_para_o_térreo--&gt;No_Térreo: Chegar no térreo
</code></pre><p>Tabela de Transição de Estados:</p><div class="table-wrapper"><table><thead><tr><th>Condição<th>Estado A<th>Estado B<th>Estado C<tbody><tr><td>1<td>…<td>…<td>…<tr><td>2<td>…<td>Estado C<td>…<tr><td>3<td>…<td>…<td>…</table></div><p>· As máquinas de estado podem ser de dois tipos: as do tipo aceitadoras (ou reconhecedoras), que produzem uma saída binária, restrita a sim ou não, para informar se a entrada é aceita pela máquina ou não, e as do tipos transdutoras que produzem uma informação na saída baseada em um estímulo ou informação de entrada e/ou um estado utilizando ações, e que geralmente são utilizadas para aplicações de controle.</p><p>· Máquina de Estado Finito M = [E, I, O, fE, fO] é uma máquina de estado finito se E é um conjunto finito de estados, I é um conjunto finito de símbolos de entrada (o alfabeto de entrada), O é um conjunto finito de símbolos de saída (o alfabeto de saída) e fE, fO são funções, onde: fE: E x I →E e fO : E → O A máquina sempre começa inicializada por um estado inicial fixo e0 .</p><p>· os exemplos utilizados até aqui tratam de um tipo de FSM que denominamos AFD – Autômato Finito Determinístico, ou seja, uma estrutura matemática constituída por três tipos de elementos: um conjunto de estados, um alfabeto (com os símbolos reconhecidos como entrada e saída) e um conjunto de transições. Entre os estados destacamos um único estado inicial e um subconjunto composto dos estados finais.</p><p>· Ex: Q = {a, b, c}; ∑ = {0, 1}; q0 = {a}; F = {c}.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Estado atual<th style="text-align: center">Próximo estado para uma entrada 0<th style="text-align: center">Próximo estado para uma entrada 1<tbody><tr><td style="text-align: center">a<td style="text-align: center">a<td style="text-align: center">b<tr><td style="text-align: center">b<td style="text-align: center">c<td style="text-align: center">a<tr><td style="text-align: center">c<td style="text-align: center">b<td style="text-align: center">c</table></div><pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; a
    a--&gt;a: 0
    a--&gt;b: 1
    b--&gt;a: 1
    b--&gt;c: 0
    c--&gt;b: 0
    c--&gt;c: 1
</code></pre><p>· Em um AFD, para cada par (estado, símbolo) há uma transição para um único estado, o que confere um caráter determinístico ao funcionamento deste autômato. Caso eliminemos essa restrição, ou seja, se para um determinado par (estado, símbolo) for possível haver transições para dois ou mais estados, passamos a denominar a FSM como AFN – Autômato Finito não Determinístico. Ou seja, em um AFN é possível haver um conjunto com várias operações possíveis para a mesma palavra ou símbolo de entrada em um estado. Os componentes de um AFN são basicamente os mesmos de um AFD, porém um AFN contempla as seguintes definições:</p><p>a. Um AFN pode ter mais que um estado inicial;</p><p>b. A função de transição apresenta, para cada par (estado, símbolo), um conjunto de estados.</p><p>· Um AFN - Autômato Finito Não-Determinístico é representado por uma quíntupla (Q, ∑, δ, q0, F), na qual:</p><p>a. Q é um conjunto finito de estados;</p><p>b. ∑ é um conjunto finito de símbolos chamado alfabeto;</p><p>c. δ é a função de transição, na qual δ: Q × ∑ → 2 Q (2 elevado a Q deve-se ao fato de que a transição de um estado pode para qualquer combinação de Q);</p><p>d. q0 é o estado inicial a partir do qual qualquer entrada é processada (q0 ∈ Q);</p><p>e. F é um conjunto de estado/estados finais de Q (F ⊆ Q).</p><p>· Ex: Q = {a, b, c}; ∑ = {0, 1}; q0 = {a}; F = {c};</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Estado atual<th style="text-align: center">Próximo estado para uma entrada 0<th style="text-align: center">Próximo estado para uma entrada 1<tbody><tr><td style="text-align: center">a<td style="text-align: center">a,b<td style="text-align: center">b<tr><td style="text-align: center">b<td style="text-align: center">c<td style="text-align: center">a,c<tr><td style="text-align: center">c<td style="text-align: center">b,b<td style="text-align: center">c</table></div><pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; a
    a--&gt;a: 0
    a--&gt;b: 0,1
    b--&gt;a: 1
    b--&gt;c: 0,1
    c--&gt;b: 0
    c--&gt;c: 0,1
</code></pre><p>· Comparativo entre AFD e AFN</p><div class="table-wrapper"><table><thead><tr><th>AFD<th>AFN<tbody><tr><td>A transição de um estado ocorre para um único estado próximo particular, para cada símbolo de entrada. Por isso, é chamado determinístico.<td>A transição de um estado pode ocorrer para vários estados seguintes, para cada símbolo de entrada. Por isso, é chamado de não-determinístico.<tr><td>Transições de strings vazias não existem.<td>Transições de strings vazias podem ocorrer.<tr><td>O retrocesso é permitido.<td>O retrocesso nem sempre é possível.<tr><td>Requer mais espaço.<td>Requer menos espaço.<tr><td>Uma string é aceita se passar para um estado final.<td>Uma string é aceita se pelo menos uma das transições possíveis terminar em um estado final.</table></div><p>· Um AFD pode ser representado pela arquitetura mostrada na figura: uma máquina que opera com uma leitura sequencial – em uma fita – e em apenas uma direção: para a direita. Esta fita contém os símbolos distribuídos em células, sendo um único símbolo em cada célula. A máquina também tem um registrador para armazenar o estado atual, um conjunto de instruções – a função de transição do AFD – e uma unidade de controle. É possível também que se possa fazer a leitura bidirecional da fita, permitindo que a transição possa avançar ou retroceder na leitura dos símbolos. Nesse caso, para evitar que a leitura avança para além do final, ou retroceda para antes do começo, é necessário que existam mais duas células com símbolos especiais &lt; e &gt;, que, na prática, limitam as transições.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-8.png" alt="fita unidirecional" width="100" height="100" data-proofer-ignore></p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-9.png" alt="fita bidirecional" width="100" height="100" data-proofer-ignore></p><h3 id="autômatos-de-pilha"><span class="mr-2">Autômatos de pilha</span><a href="#autômatos-de-pilha" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Apesar da sua extensa aplicação, as máquinas de estado finito – FSM, ou autômatos finitos, não atendem à totalidade dos problemas. É o caso, por exemplo, de aplicações para as quais é necessário usar expressões aritméticas. Nesses casos, falta aos autômatos uma memória que permita registrar todos os valores – ou as ocorrências dos símbolos. Para atender à essa necessidade são utilizados os AP – Autômatos de Pilha (pushdown automata, em inglês).</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-10.png" alt="pilha" width="100" height="100" data-proofer-ignore></p><p>· Diferentemente dos autômatos finitos, um autômato de pilha não determinístico tem uma abrangência muito superior a dos AP determinísticos. Um autômato de pilha é uma máquina de estados bastante semelhante à um AFD, porém com o adicional de uma pilha.</p><p>· A pilha, tal como uma fita, compõe-se de células que são capazes de receber apenas um símbolo por vez. A leitura, porém, é feita apenas na célula do topo da pilha. No início do processo, o registrador contém o estado inicial do AP. A fita então recebe a palavra de entrada da sua primeira célula, pois o cabeçote de leitura está posicionado na primeira célula da fita. Neste momento, a pilha está vazia. À medida em que a leitura da fita prossegue e as transições resultam em um uso da pilha, um símbolo de fim de pilha (F) é inserido na pilha, de modo a identificar esse status novamente quando a pilha for lida.</p><p>· A principal diferença entre um APD – Autômato de Pilha Determinístico e um APN – Autômato de Pilha Não-Determinístico reside no fato de que o APN pode contemplar transições compatíveis entre si.</p><h3 id="máquina-de-mealy"><span class="mr-2">Máquina de Mealy</span><a href="#máquina-de-mealy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Uma máquina de Mealy é uma FSM cuja saída depende do estado atual, bem como da entrada. Pode ser descrita por uma sêxtupla (Q, ∑, O, δ, X, q0) em que:</p><p>a. Q: conjunto finito de estados;</p><p>b. ∑: conjunto finito de símbolos denominado alfabeto de entrada;</p><p>c. O: conjunto finito de símbolos denominado alfabeto de saída;</p><p>d. δ: função de entrada de transição em que δ: Q × ∑ → Q;</p><p>e. X: função de saída da transição em que X: Q × ∑ → O;</p><p>f. q0: estado inicial a partir do qual qualquer entrada é processada (q0 ∈ Q).</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Próximo estado$\rightarrow$<th style="text-align: center">Entrada=0<th style="text-align: center">Entrada=0<th style="text-align: center">Entrada=1<th style="text-align: center">Entrada=1<tbody><tr><td style="text-align: center">Estado atual$\downarrow$<td style="text-align: center">Estado<td style="text-align: center">Saída<td style="text-align: center">Estado<td style="text-align: center">Saída<tr><td style="text-align: center">-&gt;a<td style="text-align: center">b<td style="text-align: center">x1<td style="text-align: center">c<td style="text-align: center">x1<tr><td style="text-align: center">b<td style="text-align: center">b<td style="text-align: center">x2<td style="text-align: center">d<td style="text-align: center">x3<tr><td style="text-align: center">c<td style="text-align: center">d<td style="text-align: center">x3<td style="text-align: center">c<td style="text-align: center">x1<tr><td style="text-align: center">d<td style="text-align: center">d<td style="text-align: center">x3<td style="text-align: center">d<td style="text-align: center">x2</table></div><pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; a
    a--&gt;b: 0
    a--&gt;c: 1
    b--&gt;b: 0
    b--&gt;d: 1
    c--&gt;d: 0
    c--&gt;c: 1
    d--&gt;d: 0, x3, 1
</code></pre><h3 id="máquina-de-moore"><span class="mr-2">Máquina de Moore</span><a href="#máquina-de-moore" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Uma máquina de Moore é uma FSM cujas saídas dependem apenas do estado atual. Pode ser descrita por uma sêxtupla (Q, ∑, O, δ, X, q0) em que:</p><p>a. Q: conjunto finito de estados;</p><p>b. ∑: conjunto finito de símbolos denominado alfabeto de entrada;</p><p>c. O: conjunto finito de símbolos denominado alfabeto de saída;</p><p>d. δ: função de entrada de transição em que δ: Q × ∑ → Q;</p><p>e. X: função de saída da transição em que X: Q → O;</p><p>f. q0: estado inicial a partir do qual qualquer entrada é processada (q0 ∈ Q).</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Estado atual<th style="text-align: center">Entrada=0<th style="text-align: center">Entrada=1<th style="text-align: center">Saída<tbody><tr><td style="text-align: center">-&gt;a<td style="text-align: center">b<td style="text-align: center">c<td style="text-align: center">x2<tr><td style="text-align: center">b<td style="text-align: center">b<td style="text-align: center">d<td style="text-align: center">x1<tr><td style="text-align: center">c<td style="text-align: center">c<td style="text-align: center">d<td style="text-align: center">x2<tr><td style="text-align: center">d<td style="text-align: center">d<td style="text-align: center">d<td style="text-align: center">x3</table></div><pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; a/x2
    a/x2--&gt;b/x1: 0
    a/x2--&gt;c/x2: 1
    b/x1--&gt;b/x1: 0
    b/x1--&gt;d/x3: 1
    c/x2--&gt;d/x3: 0
    c/x2--&gt;c/x2: 1
    d/x3--&gt;d/x3: 0, 1
</code></pre><h3 id="máquina-de-turing"><span class="mr-2">Máquina de Turing</span><a href="#máquina-de-turing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· A Máquina de Turing é um dispositivo inventado em 1936 por Alan Turing, matemático inglês, que aceita as linguagens (conjunto recursivamente enumerável) geradas por gramáticas tipo 0. Uma máquina de Turing é um modelo matemático que consiste em uma fita de comprimento infinito, dividida em células, pelas quais a entrada é dada, e de uma cabeça de leitura que lê a fita de entrada. Um registrador de estado armazena o estado da máquina de Turing. Depois de ler um símbolo de entrada, este é substituído por outro símbolo, o estado interno da máquina é alterado, e a cabeça de leitura se move uma célula, para a direita ou para a esquerda. Se a máquina atingir o estado final, a string de entrada será aceita; caso contrário, será rejeitada.</p><p>· Uma máquina de Turing pode ser formalmente descrita com uma sétupla (Q, X, ∑, δ, q0, B, F), em que:</p><p>a. Q é um conjunto finito de estados;</p><p>b. X é o alfabeto da fita;</p><p>c. ∑ é o alfabeto de entrada</p><p>d. δ é a função de transição δ: Q × X → Q × X × {deslocamento à esquerda, deslocamento à direita}.</p><p>e. q0 é o estado inicial;</p><p>f. B é o símbolo de ‘Espaço em Branco’;</p><p>g. F é o conjunto de estados finais.</p><p>· Comparação:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Tipo de Máquina<th style="text-align: center">Estrutura de Pilha de Dados<th style="text-align: center">Determinística?<tbody><tr><td style="text-align: center">Autômatos Finitos<td style="text-align: center">N/A<td style="text-align: center">Sim<tr><td style="text-align: center">Autômato de Pilha<td style="text-align: center">Último a entrar, primeiro a sair (LIFO)<td style="text-align: center">Não<tr><td style="text-align: center">Máquina de Turing<td style="text-align: center">Fita infinita<td style="text-align: center">Sim</table></div><p>· Ex: Q = {q0, q1, q2, qf}; X = {a, b}; ∑ = {1}; q0 = {q0}; B = espaço em branco; F = {qf}</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Símbolo do Alfabeto da Fita<th style="text-align: center">Estado atual ‘$q_0$’<th style="text-align: center">Estado atual ‘$q_1$’<th style="text-align: center">Estado atual ‘$q_2$’<tbody><tr><td style="text-align: center">a<td style="text-align: center">$1Rq_1$<td style="text-align: center">$1Lq_0$<td style="text-align: center">$1Lq_f$<tr><td style="text-align: center">b<td style="text-align: center">$1Lq_2$<td style="text-align: center">$1Rq_1$<td style="text-align: center">$1Rq_f$</table></div><p>· A complexidade do tempo pode ser representada por T (n) = O 16 (n log n). A complexidade do espaço da máquina de Turing pode ser representada por S (n) = O (n).</p><p>· Quanto à linguagem, uma máquina de Turing aceita uma linguagem se entrar em um estado final para qualquer string de entrada escrita. Uma linguagem é dita recursivamente enumerável (gerada pela gramática Tipo 0) se for aceita por uma máquina de Turing. Uma MT decide por uma linguagem se o aceita e entra em um estado de rejeição para qualquer entrada que não esteja nessa linguagem. Uma linguagem é recursiva se for decidida por uma máquina de Turing. Podem haver alguns casos em que uma máquina de Turing não para. Então essa máquina de Turing aceita a linguagem, mas não a decide.</p><h2 id="5-criptografia"><span class="mr-2">5 Criptografia</span><a href="#5-criptografia" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="introdução-à-criptografia"><span class="mr-2">Introdução à Criptografia</span><a href="#introdução-à-criptografia" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Criptografia é a ciência de transformar a informação para restringi-la, de forma que possa ser armazenada e transportada de maneira segura, e, assim, torne-se imune a modificações e acesso indevido. Forouzan (2008) acrescenta que “a criptografia também pode ser usada para autenticação do emissor e do receptor da mensagem entre si”, ou seja, quando emissores e receptores precisam de reconhecimento mútuo.</p><p>· A criptografia é uma ciência que pertence ao domínio da Matemática, destinada ao estudo de técnicas e princípios de transformação da informação de sua forma original para outra, ininteligível, de forma que possa ser conhecida e utilizada apenas quando autorizado. Esse processo de transformação da informação em seu estado original, chamado de texto plano (plain text), para um formato protegido pela ocultação de seu significado, chamado de texto cifrado ou codificado, é denominado cifragem (ou também criptografia, encriptação). O processo oposto é denominado decifragem (ou descriptografia, descriptação). Quando é feito à revelia dos interessados ou proprietários da informação – de forma maliciosa ou não – é chamado de quebra da criptografia ou do código.</p><p>· A criptografia emprega os termos texto claro (ou texto plano), que se refere à mensagem original, não modificada pelo processo criptográfico. Já o texto cifrado é a mensagem submetida a um algoritmo criptográfico, isto é, o código ou o programa de computador que transforma o texto plano em texto cifrado. Esse algoritmo criptográfico é também chamado de cifra, e geralmente faz uso de uma chave, um valor numérico que será aplicado à mensagem para produzir uma modificação controlada e reversível. Uma chave pode ser usada para criptografar (cifrar) ou para descriptografar (decifrar).</p><p>· O processo de criptografia pode ser realizado por meio de dois tipos básicos de cifragem/decifragem: a criptografia simétrica, de chave única ou de chave secreta, e a criptografia assimétrica ou de chave pública. Na criptografia simétrica a mesma chave é utilizada para a cifragem e a decifragem da mensagem, e o algoritmo de cifragem e decifragem é o mesmo.</p><p>· Já na criptografia de chave assimétrica são utilizadas duas chaves no processo de cifragem/decifragem, a chave pública e a chave privada. A chave pública, usada para cifrar a mensagem, é compartilhada com os possíveis emissores de mensagem para o receptor, que guarda consigo a chave privada para decifrar a mensagem recebida. Essas chaves são diferentes entre si.</p><h3 id="criptografia-simétrica"><span class="mr-2">Criptografia Simétrica</span><a href="#criptografia-simétrica" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Os algoritmos utilizados para a criptografia simétrica apresentam desempenho muito superior, razão pela qual são preferidos em processos de criptografia de bloco e de fluxo.</p><p>· Data Encryption Standard (DES), criado pela IBM em 1974. Mais tarde ele evoluiu para o 3DES ou Triple DES. O algoritmo RC4, desenvolvido por Ronald Rivest, é utilizado no SSL e é um dos mais empregados na criptografia de fluxo de dados. Já o RC5, do mesmo autor, é empregado para cifragem de blocos de extrema facilidade. Ambos têm a chave de tamanho fixo.</p><p>· O Blowfish é um algoritmo de criptografia de blocos com chave de tamanho variável, desenvolvido em 1993 por Bruce Schneier. O International Data Encryption Algorithm (IDEA) foi criado em 1991 por James Massey e Xuejia Lai. É também um algoritmo de bloco semelhante ao DES e de fácil implementação.</p><p>· O algoritmo Advanced Encryption Standard (AES) é um algoritmo de criptografia de bloco padronizado pelo NIST em 2001. É usado pelo governo dos Estados Unidos em substituição ao DES/3DES, sendo um dos mais populares algoritmos da atualidade, por combinar características de segurança, desempenho, facilidade de implementação e flexibilidade.</p><p>· As cifras simétricas são utilizadas desde os primórdios da história, quando a humanidade passou a utilizar a comunicação escrita, e continuam populares. Essas cifras compreendem as cifras de substituição e as cifras de transposição.</p><p>· Nas cifras de substituição um símbolo da mensagem – uma letra, sinal ou número – é substituído por um outro símbolo. Na cifragem monoalfabética essa troca é constante, ou seja, em qualquer posição da mensagem acontece a mesma troca. A chave criptográfica, nesse caso, contempla uma simples tabela de equivalência, que é usada em ambos os processos – cifragem e decifragem.</p><p>· Já em uma cifra polialfabética a substituição de símbolos é variável, sendo um mesmo símbolo substituído por vários outros no decorrer da cifragem, configurando uma relação de um-para-muitos. Nesse caso a chave e o processo de cifragem devem tratar das possibilidades de substituição. Uma forma de fazer isso é a divisão do texto em blocos de tamanho fixo, e a repetição da chave para completar o tamanho desses blocos.</p><p>· Cifras de transposição: Nesse processo a chave é uma relação entre as posições dos símbolos no texto plano e no texto cifrado. A cifragem consiste em uma transposição com base em uma tabela DePara, na qual a chave numérica representa as posições dos símbolos e a sequência na qual serão transpostas.</p><p>· Cifras modernas simples:</p><p>a. XOR: A cifra XOR é um processo que aplica a operação aritmética lógica OuExclusivo (XOR), comparando os bits do texto plano com os da chave para gerar o texto cifrado. Além da elevada velocidade, por tratar-se de uma operação muito simples, essa cifra tem a vantagem de que o processo de cifragem e decifragem é exatamente o mesmo, ou seja: M Ꚛ K = C tanto quanto C Ꚛ K = M.</p><p>b. Rotação: Na cifra de rotação os bits de um símbolo ou bloco são deslocados para a esquerda ou para a direita. Esse processo pode ser fixo, com o número de posições do deslocamento sendo constante, ou variável, em função do valor da chave. Uma característica interessante desse processo é que, se aplicarmos um deslocamento idêntico ao número de bits do fluxo de entrada (N), o resultado é inócuo. Portanto o número de deslocamentos deve ficar entre 1 e N-1. Para a decifragem, é necessária a chave, se houver, e uma operação de deslocamento no sentido contrário ao da cifragem.</p><p>c. Substituição S-Box: Esse processo é semelhante à cifra de substituição de símbolos ou caracteres, porém realizado com bits. Não são utilizadas chaves, e o processo geralmente serve como um estágio intermediário para outros tipos de cifragens mais complexas.</p><p>d. Transposição P-Box: A caixa de permutação (Permutation Box) é a correspondente, para bits, da cifra de transposição. Geralmente implementado por hardware, por ser mais ágil, esse processo não requer chave, e realiza a permutação direta, por expansão ou por compressão.</p><p>· Cifras modernas cíclicas: O uso da computação na aplicação de cifragem possibilitou o surgimento de cifras complexas, nas quais o processo de cifragem simples é repetido inúmeras vezes, usando toda a chave, partes ou variações dela de forma cíclica, até produzir o resultado cifrado.</p><p>a. DES: O Data Encryption Standard (DES), ou Padrão de Criptografia de Dados, é uma cifra de bloco de chave simétrica publicada pelo Instituto Nacional de Padrões e Tecnologia (NIST). O DES é uma implementação de uma Cifra Feistelque utiliza 16 ciclos da estrutura de Feistel. O tamanho do bloco de dados a ser criptografado é de 64 bits. Embora o tamanho da chave seja de 64 bits, o DES usa um comprimento de chave efetivo de 56 bits, pois 8 dos 64 bits da chave não são usados pelo algoritmo de criptografia, e funcionam apenas como bits de verificação. O DES satisfaz ambas as propriedades desejadas da cifra de bloco. Duas propriedades tornam a cifra muito forte: o efeito avalanche – uma pequena mudança no texto simples resulta na grande mudança no texto cifrado; e a completude – cada bit de texto cifrado depende de muitos bits de texto simples. A criptoanálise já encontrou alguns pontos fracos no DES, especialmente quanto ao tamanho da chave, considerada muito curta.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-11.png" alt="Data Encryption Standard" width="100" height="100" data-proofer-ignore></p><p>a. 3DES (Triple DES) : existem duas variantes do Triple DES, conhecidas como 3- chave Triple DES (3TDES) e 2-chave Triple DES (2TDES).</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-12.png" alt="3DES" width="100" height="100" data-proofer-ignore></p><p>a. AES: O algoritmo de criptografia simétrica mais popular e mais adotado atualmente é o Advanced Encryption Standard (AES) – Padrão Avançado de Criptografia, cujo desempenho é cerca de seis vezes mais rápido que o do 3DES. Com o aumento do poder de computação, um substituto para o DES tornou-se necessário, pois a chave do DES era muito pequena, o que o tornava vulnerável a ataques de busca de chave exaustivos. O 3DES foi projetado para superar essa desvantagem, mas foi considerado lento. Então, em função de uma solicitação do governo americano, foi desenvolvido o AES, cujas características principais são as seguintes: · Chave simétrica de bloco simétrico; · Dados de 128 bits, chaves de 128/192/256 bits; · Mais forte e mais rápido que o 3DES; · Fornece detalhes completos de especificação e design; · Software implementável em C e Java.</p><p>b. O algoritmo AES é uma cifra iterativa que, em vez de Feistel, baseia-se na “rede de substituição-permutação”. É composto por uma série de operações vinculadas, algumas das quais envolvem a substituição de entradas por saídas específicas (substituições) e outras envolvem a divisão aleatória de bits (permutações). Porém, o AES executa todos os seus cálculos em bytes, em vez de bits. O AES trata os 128 bits de um bloco de texto simples como 16 bytes. Esses 16 bytes são organizados em quatro colunas e quatro linhas para processamento como uma matriz.</p><p>c. Ao contrário do DES, o número de rodadas no AES é variável e depende do tamanho da chave. O AES usa 10 rodadas para chaves de 128 bits, 12 rodadas para chaves de 192 bits e 14 rodadas para chaves de 256 bits. Cada uma dessas rodadas usa uma chave redonda de 128 bits diferente, que é calculada com base na chave AES original. O esquema da estrutura AES é mostrado abaixo.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-13.png" alt="AES" width="100" height="100" data-proofer-ignore></p><p>· Cifras de bloco: Uma cifra de bloco processa os blocos de dados de tamanho fixo. Geralmente o tamanho de uma mensagem é maior que o tamanho do bloco. Portanto, a mensagem longa é dividida em uma série de blocos de mensagens sequenciais, e a cifra opera nesses blocos, um de cada vez. As principais cifras de bloco são: · Livro de Código Eletrônico (ECB – Electronic Code Book); · Encadeamento de Blocos de Cifras (CBC - Cipher Block Chaining); · Codificação com feedback (CFB - Cipher Feedback); · Feedback de Saída (OFB - Output Feedback); · Contador (CTR - Counter).</p><h3 id="criptografia-assimétrica"><span class="mr-2">Criptografia assimétrica</span><a href="#criptografia-assimétrica" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li><p>Chaves diferentes são usadas para criptografia e descriptografia, propriedade que a diferencia da criptografia simétrica;</p><li><p>Cada receptor possui uma chave de descriptografia exclusiva, geralmente referida como sua chave privada;</p><li><p>O receptor precisa publicar uma chave de criptografia, conhecida como sua chave pública;</p><li><p>Alguma garantia da autenticidade de uma chave pública é necessária neste esquema para evitar a falsificação do adversário como receptor;</p><li><p>A criptografia assimétrica pode envolver terceiros confiáveis, que certificam que uma determinada chave pública pertence apenas a uma pessoa ou entidade específica;</p><li><p>O algoritmo de criptografia é complexo o suficiente para impedir que o invasor consiga produzir um texto simples com base no texto cifrado e a chave de criptografia (pública).</p></ol><p>Embora as chaves pública e privada estejam relacionadas matematicamente, não é possível calcular a chave privada com base na chave pública. Na verdade, a parte inteligente de qualquer sistema criptográfico de chave pública está no projeto da relação entre as duas chaves.</p><p>· Criptografia RSA: A criptografia RSA é um dos primeiros sistemas criptográficos de chave pública e o mais empregado atualmente.</p><p>o Geração de par de chaves:</p><p>· Selecione dois primos grandes, p e q;</p><p>· Calcule n = p * q. Para criptografia forte e inquebrável, deve ser um número grande, normalmente um mínimo de 512 bits.</p><p>· Encontre o Número Derivado (e): O número e deve ser maior que 1 e menor que (p - 1) (q - 1);</p><p>· Não deve haver nenhum fator comum para e e (p - 1) (q - 1), exceto para 1. Em outras palavras, dois números e e (p - 1) (q - 1) são primos;</p><p>· Forme a chave pública: O par de números (n, e) forma a chave pública RSA e é tornada público.</p><p>o Embora n seja parte da chave pública, a dificuldade em fatorar um grande número primo assegura que um atacante não encontre em tempo finito os dois primos (p &amp; q) usados para obter n. Essa é a força do RSA. Para a geração da chave privada, eis os passos:</p><p>· A chave privada d é calculada com base em p, q e e. Para dado n e e, existe um número único d;</p><p>· O número d é o inverso de e módulo (p - 1)(q - 1). Isso significa que d é um número menor que (p - 1)(q - 1), tal que, quando multiplicado por e, é igual a 1 módulo (p - 1) (q - 1);</p><p>· Essa relação é escrita matematicamente da seguinte maneira: e . d = 1 mod (p - 1) (q - 1)</p><p>· O Algoritmo Euclidiano Estendido toma p, q e e como entrada e fornece d como saída.</p><p>o Cifragem RSA: Um emissor que deseje enviar uma mensagem de texto para alguém cuja chave pública seja (n, e) representa o texto simples como uma série de números menor que n. Para criptografar o primeiro texto simples P, que é um número módulo n, o processo de criptografia é simples, representado matematicamente como: C = Pe mod n Ou seja, o texto cifrado C é igual ao texto simples P multiplicado por si mesmo e vezes e depois reduzido ao módulo n. Isso significa que C também é um número menor que n.</p><p>o Decifragem RSA: O processo de descriptografia do RSA é igualmente simples. Considerando que o receptor, que gerou o par de chaves públicas (n, e), recebeu o texto cifrado C, basta então que eleve C à potência de sua chave privada d. O resultado no módulo n será o texto claro P, originalmente transmitido. Representando matematicamente: P = Cd mod n</p><p>o A segurança do RSA depende da complexidade de duas funções separadas. O sistema de criptografia RSA é o mais popular sistema criptográfico de chave pública, baseado na dificuldade prática de fatorar números primos muito grandes. Sua função de criptografia é considerada uma função unidirecional de conversão de texto simples em texto cifrado que pode ser revertida somente com o conhecimento da chave privada d. A geração da chave é baseada na dificuldade de determinar uma chave privada de uma chave pública RSA, o que é o equivalente a fatorar o módulo n. Portanto, não se pode usar o conhecimento de uma chave pública RSA para determinar uma chave privada RSA, a menos que se consiga fatorar n.</p><p>o Também é uma função unidirecional: passar dos valores de p e q para o módulo n é fácil, mas o inverso é praticamente impossível. Se qualquer uma dessas duas funções for provada não unidirecional, o RSA será quebrado. De fato, se uma técnica de fatoração eficiente for desenvolvida, o RSA não será mais seguro. A força da criptografia RSA é reduzida drasticamente se os números p e q não forem primos grandes, mas também se a chave pública escolhida e for um número pequeno.</p><p>· Criptografia ElGamal: Existem diversos modelos de criptografia baseados em diferentes versões do Problema do Logaritmo Discreto. O ElGamal, chamado de Variante de Curva Elíptica, é um deles, e a sua força vem do pressuposto de que os logaritmos discretos não podem ser encontrados em um período curto, para determinado número, ao passo que a operação inversa de potenciação pode ser calculada eficientemente.</p><p>o Geração do par de chaves ElGamal :</p><p>· Escolhe um grande primo p. Geralmente, um número primo de 1024 a 2048 bits de comprimento é escolhido;</p><p>· Escolhe um elemento gerador g. Esse número deve estar entre 1 e p - 1, mas não pode ser qualquer número: é um gerador do grupo de múltiplos inteiros de módulo p. Isto significa que para todo inteiro m co-primo para p, existe um inteiro k tal que g k = a mod n. Por exemplo, 3 é gerador do grupo 5 (Z5 = {1, 2, 3, 4}), como podemos ver na tabela a seguir:</p><div class="table-wrapper"><table><thead><tr><th>n<th>$3^n$<th>$3^n mod5$<tbody><tr><td>1<td>3<td>3<tr><td>2<td>9<td>4<tr><td>3<td>27<td>2<tr><td>4<td>81<td>1</table></div><p>· Escolhe a chave privada: a chave privada x é qualquer número maior que 1 e menor que p – 1;</p><p>· Calcula parte da chave pública: o valor y é calculado com base nos parâmetros p, g e da chave privada x pela seguinte fórmula: y = gx mod p</p><p>· Obtém a chave pública: a chave pública ElGamal consiste nos três parâmetros (p, g, y).</p><p>o Cifragem ElGamal : A geração de um par de chaves ElGamal é comparativamente mais simples que o processo equivalente para RSA, porém a criptografia e a descriptografia são um pouco mais complexas que o RSA. Vamos supor que um emissor deseja enviar um texto simples para alguém, cuja chave pública ElGamal seja (p, g, y). Ele representa o texto plano como uma série de números módulo p. Para criptografar o primeiro texto simples P – que é representado como um número módulo p – de modo a obter o texto cifrado C, ele faz o seguinte:</p><p>· Gera aleatoriamente um número k;</p><p>· Calcula dois valores C1 e C2, de modo que: C1 = gk mod p C2 = (P*yk) mod p</p><p>· Envia o texto cifrado C, consistindo nos dois valores separados (C1, C2), enviados juntos.</p><p>o Decifragem ElGamal: Para descriptografar o texto cifrado (C1, C2) usando a chave privada x, devemos:</p><p>· Calcular o inverso modular de (C1) x módulo p, que é (C1) -x, chamado de fator de decodificação.</p><p>· Obter o texto original (texto plano P) com base no seguinte cálculo: P = C2 × (C1)-x mod p</p><p>· Criptografia de curva elíptica (ECC) : conjunto de ferramentas e protocolos criptográficos cuja segurança é baseada em versões especiais do problema do logaritmo discreto. Não usa números módulo p. O ECC é baseado em conjuntos de números associados a objetos matemáticos chamados curvas elípticas.</p><h3 id="assinatura-digital"><span class="mr-2">Assinatura Digital</span><a href="#assinatura-digital" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>As assinaturas digitais são as formas primitivas de chave pública de autenticação de mensagens. Assinatura digital é um valor criptográfico calculado com base em dados e uma chave secreta conhecida apenas pelo signatário. O receptor da mensagem precisa ter certeza de que a mensagem pertence ao remetente, sem poder negar a origem dessa mensagem. Esse requisito é crucial no mundo dos negócios para manter a confiança nas negociações.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-14.png" alt="Assinatura Digital" width="100" height="100" data-proofer-ignore></p><p>A chave privada usada para assinatura é referida como chave de assinatura e a chave pública, como chave de verificação.</p><p>Deve-se notar que, em vez de assinar os dados diretamente com o algoritmo da assinatura, isso é feito com o hash dos dados. Como o hash de dados é uma representação única de dados, basta assinar o hash no lugar dos dados. A razão mais importante do uso de hash em vez de dados diretamente para assinatura é a eficiência do processo.</p><p>· Os objetivos da assinatura digital: Autenticação da mensagem; Integridade de dados; Não repúdio; Privacidade.</p><h3 id="infraestrutura-de-chaves-públicas"><span class="mr-2">Infraestrutura de Chaves Públicas</span><a href="#infraestrutura-de-chaves-públicas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>A principal característica da Infraestrutura de Chave Pública (ICP) – ou Public Key Infrastructure (PKI) – é que ela usa um par de chaves para prover os serviços de segurança subjacentes. Como já vimos, o par de chaves é composto por chave privada e chave pública. Como as chaves públicas estão em domínio aberto e podem ser violadas, é necessário estabelecer e manter algum tipo de infraestrutura confiável para gerenciar essas chaves.</p><p>Além disso, existem dois requisitos específicos de gerenciamento de chaves para criptografia de chave pública: 1. O segredo das chaves privadas; 2. A garantia das chaves públicas.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-15.png" alt="Chaves Públicas" width="100" height="100" data-proofer-ignore></p><p>· A PKI fornece garantia de chave pública. Ela fornece a identificação de chaves públicas e sua distribuição. Uma estrutura de PKI compreende os seguintes componentes:</p><p>o Certificado de chave pública, comumente chamado de “certificado digital”;</p><p>o Tokens de chave privada;</p><p>o Autoridade Certificadora;</p><p>o Autoridade de Registro;</p><p>o Sistema de Gerenciamento de Certificados.</p><p>· Certificados digitais: Por analogia, um certificado pode ser considerado como a carteira de identidade de uma pessoa. Os certificados digitais são baseados no padrão X.509 da ITU, que define um formato de certificado padrão para certificados de chave pública e validação de certificação. A chave pública referente ao cliente do usuário é armazenada em certificados digitais pela Autoridade Certificadora (CA – Certification Autority), juntamente com outras informações relevantes, como informações do cliente, data de validade, uso, emissor etc. A CA assina digitalmente toda essa informação e inclui uma assinatura digital no certificado. Qualquer pessoa que precise da garantia sobre a chave pública e as informações associadas do cliente pode realizar o processo de validação de assinatura usando a chave pública da CA.</p><p>· Autoridade certificadora (CA): a CA emite o certificado para um cliente e ajuda outros usuários a verificar o certificado. A CA assume a responsabilidade de identificar corretamente a identidade do cliente que está solicitando a emissão de um certificado, garante que as informações contidas no certificado estejam corretas e as assina digitalmente.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C/svg%3E" data-src="https://raw.githubusercontent.com/joaoffnogueira/joaoffnogueira.github.io/main/assets/img/posts/2021-01-22-16.png" alt="Gerenciamento de Certificados" width="100" height="100" data-proofer-ignore></p><p>· Classes de certificados</p><p>o Classe 1: Podem ser facilmente adquiridos pelo fornecimento de um endereço de e-mail;</p><p>o Classe 2: Exigem informações pessoais adicionais;</p><p>o Classe 3: Só podem ser adquiridos após a verificação da identidade do solicitante;</p><p>o Classe 4: Usados por governos e organizações financeiras que precisam de níveis muito altos de confiança.</p><p>· Autoridade de registro (RA) : A CA pode usar uma Autoridade de Registro (Registration Authority – RA) terceirizada para executar as verificações necessárias da pessoa ou organização que solicita o certificado, para confirmar sua identidade. A RA pode parecer uma autoridade certificadora para o cliente, porém não assina o certificado emitido. O Sistema de Gerenciamento de Certificados (Certificate Management System – CMS) é o sistema de gestão pelo qual os certificados são publicados, temporariamente ou permanentemente suspensos, renovados ou revogados.</p><p>· Token de chave privada: Enquanto a chave pública de um cliente é armazenada no certificado, a chave privada secreta associada pode ser armazenada no computador do proprietário da chave. Esse método geralmente não é adotado. Se um invasor obtiver acesso ao computador, ele poderá obter acesso à chave privada com facilidade. Por esse motivo, uma chave privada é armazenada em um acesso seguro, vinculado ao token de armazenamento removível protegido por uma senha. Diferentes fornecedores costumam usar formatos de armazenamento diferentes e, por vezes, proprietários, para armazenar chaves. Por exemplo, o Entrust usa o formato proprietário .epf, ao passo que a Verisign, GlobalSign e Baltimore usam o formato padrão .p12.</p><p>· Hierarquia de Cas: A CA Raiz está no topo da hierarquia da CA e o certificado da CA raiz é um certificado auto assinado. As autoridades certificadoras secundárias, subordinadas diretamente à autoridade certificadora raiz, possuem certificados de autoridade certificadora assinados pela autoridade certificadora raiz.</p><p>· No Brasil, a Infraestrutura de Chaves Públicas ICP-Brasil, vinculada ao Instituto Nacional de Tecnologia da Informação da Casa Civil da Presidência da República, é quem responde pela AC-Raiz. A ela estão vinculadas todas as Autoridades Certificadoras (ACs) de 1º e 2º nível, e as Autoridades de Registro (ARs), da ICP-Brasil (ITI, 2018).</p><h2 id="6-ferramentas-de-computação-matemática-algoritmos-de-euclides-teorema-de-euler"><span class="mr-2">6 Ferramentas de Computação Matemática, Algoritmos de Euclides, Teorema de Euler</span><a href="#6-ferramentas-de-computação-matemática-algoritmos-de-euclides-teorema-de-euler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="aritmética-modular"><span class="mr-2">Aritmética Modular</span><a href="#aritmética-modular" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Seja um número n inteiro e positivo, que faz parte de um conjunto {0,…,n1}, o qual representamos como ℤn. Podemos considerar que dois inteiros desse conjunto, x e y, são os mesmos se x e y diferem por um múltiplo de n, o que escrevemos assim:</p><p>o x = y (mod n)</p><p>· E dizemos que x e y são congruentes módulo n. Quando o mod n está claramente definido pelo contexto, então pode ser omitido. Todo inteiro x é congruente para determinados y em ℤn. Quando somamos ou subtraímos múltiplos de n de um inteiro x para determinar y ∈ ℤn, então dizemos que estamos reduzindo x módulo n e y é o resto (ou residual).</p><p>· A aritmética com elementos de ℤn é a mais natural possível. Dados dois elementos x e y ∈ ℤn podemos realizar somas, subtrações e multiplicações e o resultado será congruente com um elemento de ℤn., como nos exemplos a seguir: 6 + 7 = 1 (mod 12) 3 x 20 = 10 (mod 50) 12 – 14 = 16 (mod 18)</p><p>· Entretanto não há nenhuma noção de grandeza ou proporção.</p><p>· A divisão, porém, é um caso à parte, posto que está fora dessa constatação.</p><p>· Caso esse resultado não seja obtido, concluímos que y não tem um inverso. De certa forma, a aritmética modular é mais fácil do que a aritmética com inteiros, posto que existem apenas muitos elementos finitos. Então, para encontrar uma solução de um problema, podemos sempre tentar todas as possibilidades. Agora temos uma boa definição para divisão: x dividido por y é x multiplicado por y-1, se o inverso de y existe. Caso contrário a resposta é indefinida.</p><p>· Para evitar confusão com a divisão de números inteiros, é comum evitar o uso da barra “/” como símbolo de divisão na aritmética modular: para expressar a divisão de x por y escreve-se xy-1. Como exemplo, temos a seguinte equação: 2 x 3 + 4(5-1) = 2 (mod 6)</p><h3 id="algoritmo-de-euclides"><span class="mr-2">Algoritmo de Euclides</span><a href="#algoritmo-de-euclides" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>O algoritmo de Euclides é uma forma eficiente e simples para encontrar o MDC (Máximo Divisor Comum) para dois inteiros diferentes de zero, sem exigir a fatoração.</p><p>· mdc (x, y) = mdc (y, r) Onde r é o resto da divisão de x por y</p><p>· Primeiro, se d divide x e d divide y então d divide também a soma de x e y. De modo semelhante, divide também a diferença entre eles, (x – y), considerando que x é o maior dos dois números. E isso significa que diminuímos o tamanho do problema inicial. Agora só precisamos calcular mdc (x, x – y), e o processo pode repetir-se até zerar o resto, e obter o resultado.</p><h3 id="logaritmos-discretos"><span class="mr-2">Logaritmos Discretos</span><a href="#logaritmos-discretos" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Seja p um número primo, e g, h dois elementos de ℤ𝐩𝐩 ∗ (ou seja, números inteiros menores que p). Suponhamos que saibamos que gx = h (mod p). Então, qual é o valor de x?</p><p>· O algoritmo de Euclides nos fornece uma maneira mais efetiva de computar inversos, porém não conhecemos nenhum algoritmo rápido para encontrar os logaritmos discretos. Os melhores algoritmos conhecidos para calcular logaritmos discretos são muito mais rápidos do que tentar todos os elementos, mas mesmo assim não são equivalentes ao tempo do cálculo polinomial.</p><p>· Esse conceito de logaritmos discretos é de fundamental importância, na atualidade, para os mecanismos de chave pública e assinatura digital. O entendimento desse conceito e de sua aplicação no contexto computacional passa pelos conhecimentos básicos da teoria dos números que estamos apresentando. Em função desse entendimento, dizemos que dois números são relativamente primos se não tiverem fatores primos em comum, isto é, se seu máximo divisor comum for 1.</p><h3 id="teoremas-de-euler-e-fermat"><span class="mr-2">Teoremas de Euler e Fermat</span><a href="#teoremas-de-euler-e-fermat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>· Como já dissemos, o problema do logaritmo discreto pode ser complexo, porém temos a nosso favor alguns pontos sobre a potência de uma unidade a ∈ ℤ𝒏 ∗ . Primeiramente, $a^k = 1$ para algum valor de k: uma vez que existem diversas unidades, em quantidade finita, é possível que devamos ter $a^x = a^y$ para algum x &lt; y eventualmente, e uma vez que existe um a − 1 podemos encontrar $a^{x – y} = 1$.</p><p>· Os teoremas apresentados a seguir reduzem drasticamente o conjunto dos valores possíveis para a ordem de uma unidade.</p><p>· Pequeno Teorema de Fermat:</p><p>o Então, em resumo, o pequeno teorema de Fermat afirma que se p é um número primo, então para qualquer inteiro a, o número ap - a é um inteiro múltiplo de p. Em notação aritmética modular escrevemos deste modo: $a^p ≡ a (mod p)$</p><p>o $a^{p-1} ≡ 1 (mod p)$</p><p>· Teorema de Euler: é, de certa forma, um modo genérico do pequeno teorema de Fermat, que vimos antes. O modo formal de expressar o teorema de Euler é o seguinte: se a ∈ ℤ𝒏 ∗ então $a^{ϕ(n)} = 1 (mod n)$. Isso reduz o pequeno teorema de Fermat quando n é primo.</p><p>· Teorema de Euler e o problema do logaritmo discreto: Uma vez que já fomos apresentados ao Teorema de Euler, vamos retomar o problema do logaritmo discreto. Se t e n são números relativamente primos, então: $t^{Φ(n)} = 1 ( mod n)$ Vamos considerar a seguinte equação: $t^x = 1 ( mod n)$</p><p>· Cálculo do logaritmo discreto: O cálculo do logaritmo discreto consiste em solucionar o seguinte problema: “Dados três números primos, b, t e p, encontrar x de modo que b = t x mod p”.</p><p>· Multiplicação e Ordem: “para os elementos com ordens de coprimos, a ordem de seu produto é igual ao produto de suas ordens”.</p><h3 id="testes-de-fermat-e-miller-rabin"><span class="mr-2">Testes de Fermat e Miller-Rabin</span><a href="#testes-de-fermat-e-miller-rabin" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>O uso de números primos grandes é essencial para alguns algoritmos de criptografia. Porém um dos complicadores do uso desses números é exatamente a identificação deles. Por definição, um número primo é aquele divisível apenas por 1 e por ele mesmo. Imaginemos um inteiro qualquer n: como podemos afirmar que n é primo? Vamos assumir que n seja ímpar, já que o único caso de número par e primo é o do número 2. A forma mais corriqueira de verificar se n é primo seria procurar os fatores de n, entretanto, como já sabemos, ainda não conhecemos nenhum algoritmo de fatoração eficiente para essa operação.</p><p>· Teste de Fermat: Conhecemos como teste de Fermat ou teorema de Fermat o seguinte enunciado: se o número n é primo, então para qualquer a temos que $a^{n-1} = 1 (mod n)$.</p><p>· Teste de Miller-Rabin:</p><p>o Dado n, encontramos s de modo que $n − 1 = 2^sq$ para algum q ímpar.</p><p>o Escolhemos um valor aleatório para a de tal modo que a ∈ {1, …, n − 1}</p><p>o Se $a^q = 1$, então n passa no teste, e finalizamos o teste.</p><p>Para toda iteração i=0,…,s-1 verificamos se $a^{2^{i}q}=-1$. Caso seja, n passa no teste, e finalizamos o teste.</p><p>o Caso contrário, n é um número composto, e, portanto, não é primo.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/estudos-faculdade/'>Estudos-faculdade</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/matem%C3%A1tica/" class="post-tag no-text-decoration" >matemática</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Esta postagem está licenciada sob <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> pelo autor.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Compartilhar</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Anota%C3%A7%C3%B5es+sobre+Matem%C3%A1tica+Computacional+-+Flutter%2FDart+Blog&url=https%3A%2F%2Fblog.joaonogueira.dev%2F%2Fposts%2Fmatematica-computacional%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Anota%C3%A7%C3%B5es+sobre+Matem%C3%A1tica+Computacional+-+Flutter%2FDart+Blog&u=https%3A%2F%2Fblog.joaonogueira.dev%2F%2Fposts%2Fmatematica-computacional%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.joaonogueira.dev%2F%2Fposts%2Fmatematica-computacional%2F&text=Anota%C3%A7%C3%B5es+sobre+Matem%C3%A1tica+Computacional+-+Flutter%2FDart+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copie o link" data-title-succeed="Link copiado com sucesso!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Atualizados recentemente</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/arquitetura-android/">A arquitetura Android e componentes de aplicativo</a><li><a href="/posts/fluttererror-erro-ao-carregar-assets/">FlutterError - erro ao carregar assets</a><li><a href="/posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/">Anotações sobre Recuperação de banco de dados e segurança</a><li><a href="/posts/javascript/">Anotações sobre Javascript</a><li><a href="/posts/fundamentos-sistemas-informacao/">Anotações sobre Fundamentos de Sistemas de Informação</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/jakarta/">jakarta</a> <a class="post-tag" href="/tags/gest%C3%A3o/">gestão</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/banco-de-dados/">banco-de-dados</a> <a class="post-tag" href="/tags/seguran%C3%A7a/">segurança</a> <a class="post-tag" href="/tags/css/">css</a> <a class="post-tag" href="/tags/dados/">dados</a> <a class="post-tag" href="/tags/git/">git</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Conteúdo</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Leia também</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/fundamentos-matematicos-ciencia-computacao/"><div class="card-body"> <em class="timeago small" data-ts="1592564400" > 2020-06-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Anotações sobre Fundamentos Matemáticos para a Ciência da Computação</h3><div class="text-muted small"><p> ​Baseado em Fundamentos Matemáticos para a Ciência da Computação (Gersting). 1 Lógica Formal 1.1 Sentenças, Representação Simbólica e Tautologias Tecnicamente, uma sentença (ou proposição) é uma ...</p></div></div></a></div><div class="card"> <a href="/posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/"><div class="card-body"> <em class="timeago small" data-ts="1579262400" > 2020-01-17 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Anotações sobre Recuperação de banco de dados e segurança</h3><div class="text-muted small"><p> Estratégias de recuperação: Se houver dano extensivo a uma grande parte do banco de dados devido a uma falha catastrófica, como uma falha de disco, o método de recuperação restaura uma cóp...</p></div></div></a></div><div class="card"> <a href="/posts/javascript/"><div class="card-body"> <em class="timeago small" data-ts="1579867200" > 2020-01-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Anotações sobre Javascript</h3><div class="text-muted small"><p> Comentários // This is an in-line comment. /* This is a multi-line comment */   Declaração de variáveis var ourName;   Tipos: undefined, null, boolean, string, symbol, bigint, number, and o...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/inteligencia-artificial-aplicada/" class="btn btn-outline-primary" prompt="Anterior"><p>Anotações sobre Inteligência Artificial Aplicada</p></a> <a href="/posts/firewalls/" class="btn btn-outline-primary" prompt="Próximo"><p>Tipos de firewalls e suas facilidades</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/joaoffnogueira">João F. F. Nogueira</a>. <span data-toggle="tooltip" data-placement="top" title="Exceto onde indicado de outra forma, as postagens do blog neste site são licenciadas sob a Creative Commons Attribution 4.0 International (CC BY 4.0) License pelo autor.">Alguns direitos reservados.</span></p></div><div class="footer-right"><p class="mb-0"> Feito com <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> usando o tema <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> .</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/jakarta/">jakarta</a> <a class="post-tag" href="/tags/gest%C3%A3o/">gestão</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/banco-de-dados/">banco-de-dados</a> <a class="post-tag" href="/tags/seguran%C3%A7a/">segurança</a> <a class="post-tag" href="/tags/css/">css</a> <a class="post-tag" href="/tags/dados/">dados</a> <a class="post-tag" href="/tags/git/">git</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! Nenhum resultado encontrado.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/pt.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-7RCXJ5XJWN"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-7RCXJ5XJWN'); }); </script>

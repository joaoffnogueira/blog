[ { "title": "A arquitetura Android e componentes de aplicativo", "url": "/posts/arquitetura-android/", "categories": "Flutter, Android", "tags": "android, arquitetura", "date": "2022-05-27 09:00:00 -0300", "snippet": " Baseado no material da minha disciplina da graduaçãoA arquitetura AndroidLinux KernelEsta camada contém os serviços essenciais. Gerenciamento de processos e de memória são feitos nesta camada. O Linux Kernel também contém os drivers de dispositivos e a Arquitetura de Permissões, que restringe o acesso a dados ou recursos somente a processos que foram autorizados. Aqui, também, encontramos componentes específicos para Android, como, por exemplo, gerenciamento de bateria, compartilhamento e gerenciamento.LibrariesNa camada de libraries (bibliotecas), temos as bibliotecas de sistema, normalmente escritas em C e C++, e que são utilizadas para o bom funcionamento do sistema operacional. Também encontramos bibliotecas Java criadas especificamente para Android.Algumas das bibliotecas: Surface Manager – atualização da tela SQLite – utilizada para acesso a dados publicados por provedores de conteúdo e que inclui também as classes de gerenciamento do banco de dados SQLite SSL – (Secure Sockets Layer), que é utilizada para prover segurança na internet OpenGL – que dá acesso para interface Java aos gráficos 3D OpenGL/ES e a API de renderização Media Framework – utilizada para fornecer acesso à diferentes codecs (programas utilizados para codificar e decodificar arquivos de mídia), que possibilitam a gravação e execução de formatos diferentes WebKit – utilizada para mostrar conteúdo da internet ou conteúdo HTMLAndroid RuntimeÉ o terceiro componente da arquitetura Android, e é colocado na segunda camada (a partir de baixo). Este componente é responsável por fornecer a Core Java Library e a Dalvik Virtual Machine. As aplicações Android são normalmente criadas na linguagem de programação Java e, para tornar mais simples o desenvolvimento destas aplicações, o Android fornece uma grande gama de blocos reutilizáveis Java, como por exemplo java.* e javax.*, os pacotes android.*, responsáveis pelo ciclo de vida dos aplicativos Android e os pacotes org.*, que suportam operações de rede. A Dalvik Virtual Machine é o software que executa as aplicações Android, e é similar ao Java Virtual Machine (JVM), mas desenvolvida e otimizada para esta plataforma. A Dalvik utiliza funções principais do Java, como gerenciamento de memória e multi threading, que possibilita que cada aplicação Java rode em seu próprio processo.Application FrameworkA terceira camada interage diretamente com o framework de aplicação, que gerencia as funções básicas de um dispositivo Android, como gerenciamento de recursos, gerenciamento de chamadas, etc. Blocos importantes do framework de aplicação são: Activity Manager – bloco utilizado para gerenciar o ciclo de vida completo das aplicações Content Providers – utilizado para gerenciar o compartilhamento de dados entre as aplicações Telephony Manager – utilizado para gerenciar chamadas de voz Location Manager – utilizado para gerenciar as localizações obtidas utilizando-se o GPS ou uma torre de celular Resource Manager – este bloco é responsável por gerenciar os tipos diferentes de recursos utilizados em uma aplicação AndroidApplicationsNesta camada estão as aplicações criadas por diferentes fornecedores ou desenvolvedores.Pacote Android: Android Application Package (APK)Este pacote normalmente possui a seguinte estrutura: META-INF MANIFEST.MF – arquivo de manifesto da aplicação CERT.RSA – O certificado da aplicação CERT.SF – Contém os hashes SHA1 para os arquivos incluídos no pacote lib – diretório que contém o código compilado específico para o tipo de processador armeabi – código compilado para processadores ARM armeabi-v7a – código compilado para todos os processadores ARMv7 e acima arm64-v8a – código compilado para processadores ARMv8 e superior x86 – código compilado para processadores x86 x86_64 – código compilado para processadores x86 64 mips – código compilado para processadores MIPS res – diretório que contém todos os recursos não compilados no diretório resources.arsc assets – diretório contendo todos os arquivos de componente bruto necessários para o funcionamento da aplicação, os quais podem recuperados através do AssetManager AndroidManifest.xml – um arquivo de manifesto adicional, que descreve o nome, versão, direitos de acesso e bibliotecas utilizadas pela aplicação. Classes.dex – as classes compiladas para o formato dex, que é entendido pela máquina virtual Dalvik Resources.arsc – arquivo pré-compilado de recursos, como por exemplo XML binárioComponentes de aplicativoAtividades (Activity)Representam uma tela única de interface de usuário. É implementada como uma subclasse de Activity. Estas fornecem a tela com a qual os usuários podem interagir. Cada atividade recebe uma janela, que representa a interface do usuário, com botões e caixas de texto, por exemplo. Aplicativos geralmente possuem várias atividades vinculadas entre si. Um aplicativo normalmente possui uma atividade principal, que é mostrada ao usuário quando este o executa pela primeira vez. Após isso, cada atividade pode iniciar uma nova atividade para executar diferentes ações.As atividades são ordenadas em forma de pilha no formato UEPS (último a entrar, primeiro a sair). A cada nova atividade criada, a atividade anterior é interrompida, mas é armazenada na pilha, para que possa ser restabelecida quando o usuário pressionar o botão de retorno.Serviços (Services)Componentes executados em segundo plano para realizar operações de longa duração ou executar trabalhos remotos. Não representam uma interface com o usuário. Um serviço pode ter duas formas: Iniciado – um componente do aplicativo, como uma activity, por exemplo, inicia-o chamando startService(). Após iniciado, o serviço pode ficar em segundo plano indefinidamente, mesmo que o componente que o chamou seja destruído. Neste modelo, normalmente não temos o retorno da operação para o componente que originou a chamada. Vinculado – neste caso, o componente vincula-se ao serviço, iniciando-o pela chamada bindService(). Ao ser vinculado, o serviço criará uma interface cliente-servidor, que permitirá que os componentes interajam com este, enviando solicitações e recolhendo resultados. Este tipo de serviço somente permanece em execução enquanto o componente que criou o vínculo mantiver o vínculo com o mesmo. Ao se destruir o componente, ou ao se desvincular o serviço, o mesmo é destruído. Provedores de Conteúdo (Content Providers)São responsáveis por prover às aplicações o conteúdo das quais elas necessitam para funcionar, ou seja, os dados. Ao utilizarmos provedores de conteúdo, tornamos a forma como os dados são gravados transparentes à aplicação, o que permite que esta mantenha o foco nas interações com os usuários. Através do provedor de conteúdo, os aplicativos acessam e até modificam os dados gerados por outros aplicativos instalados, como, por exemplo, a lista de contatos, caso o provedor de conteúdo permita seu acesso.Receptores de Transmissão (Broadcast Receivers)Este é o componente que responde (e inicia) anúncios a todo o sistema Android. Transmissões de que o sistema está com a bateria baixa ou que a tela está ligada são originados no sistema. Aplicativos podem iniciar transmissões, como, por exemplo, de que uma imagem foi capturada, informando a outros aplicativos sobre este evento, possibilitando assim que os mesmos disparem alguma ação. Ao contrário de uma Activity, um BroadcastReceiver não possui qualquer tipo de interface com o usuário, mas possibilita a criação de uma notificação na barra de status. A intenção é de que os receptores de transmissão efetuem a menor quantidade de serviços possível, delegando seu trabalho para os Services" }, { "title": "Lançar app Flutter na Google Play - alerta de ausência de debug symbols", "url": "/posts/flutter-google-play-no-debug-symbols-alerta/", "categories": "Flutter, Android", "tags": "android, google-play", "date": "2022-05-26 08:00:00 -0300", "snippet": "Se você está tentando lançar seu app flutter na Google Play e está recebendo o seguinte alerta: Este App Bundle contém código nativo e você não carregou símbolos de depuração. Recomendamos que você carregue um arquivo de símbolo para tornar suas falhas e ANRs mais fáceis de analisar e depurar. veja a seguir a solução.Alguma documentação recomenda a inclusão, no app/build.gradle do seu projeto, da instrução android.buildTypes.release.ndk.debugSymbolLevel = 'FULL', para que o gradle inclua os símbolos de depuração no app bundle, no entanto esta solução não é compatível com o flutter 2.10.Você pode pegar os arquivos diretamente para fazer o envio para o Google Play.Vá para [seu projeto]\\build\\app\\intermediates\\merged_native_libs\\release\\out\\lib.Selecione as pastas arm64-v8a, armeabi-v7a, x86_64 e compacte-as em um arquivo zip.Faça o upload desse arquivo zip como arquivo de símbolos de depuração, esta opção vai estar junto com o pacote que você incluiu como app bundle na Google Play.Com isso, o alerta vai desaparecer!" }, { "title": "FlutterError - erro ao carregar assets", "url": "/posts/fluttererror-erro-ao-carregar-assets/", "categories": "Flutter, Dependências", "tags": "flutter, pubspec, yaml", "date": "2022-05-01 11:15:00 -0300", "snippet": "Se você criou seu projeto flutter usando o assistente do Android Studio e está recebendo o seguinte erro FlutterError: Unable to load asset ao tentar utilizar uma imagem como asset, verifique o seu arquivo pubspec.yaml.É lá onde você indica o caminho para pastas e arquivos que deverão ser inclusos como assets no projeto.Eu havia criado o projeto-base com o assistente do Android Studio e o pubspec.yaml estava com erro de indentação, sendo esta a origem do erro.Indentação incorreta (arquivo recém-gerado para o projeto):flutter:uses-material-design: trueassets: - images/test.pngIndentação correta:flutter: uses-material-design: true assets: - images/test.pngPerceba que a indentação é necessária para demarcar a hierarquia das dependências (já que não há tags que marquem o fechamento).Então cada asset precisa estar indentado como “filho” de assets:, e este deve estar indentado como “filho” de flutter:Outros problemas relativos ao carregamento de assets podem ser resolvidos executando:flutter cleanTenha cuidado também com as barras ao indicar o caminho dos arquivos no pubspec.yaml.O Windows utiliza barras invertidas por padrão para indicar caminhos (\\), e isso pode fazer com que o seu arquivo não seja interpretado corretamente.Sempre utilize barras direitas (/) para indicar o caminho dos arquivos. No Visual Studio Code você pode configurar as preferências para que a opção “Copiar caminho relativo” dos arquivos do projeto utilize sempre a barra normal." }, { "title": "Criar novo projeto Flutter não está aparecendo no assistente do Android Studio", "url": "/posts/criar-novo-projeto-flutter/", "categories": "Flutter, IDE", "tags": "android, android-studio, solução-de-problemas", "date": "2022-04-29 11:15:00 -0300", "snippet": "Se você faz questão de utilizar o Android Studio para criar o seu projeto, talvez você se depare com este problema (principalmente se estiver utilizando uma versão antiga do Android Studio):Você instalou o Flutter, o Android Studio e dentro dele os plugins do Dart e do Flutter, e mesmo assim, quando você reinicia a IDE, não aparece a opção de criar um novo projeto Flutter.Normalmente, o problema é que o plugin Android APK Support está desativado e habilitando-o deve resolver o problema.Assistente do Android Studio, com a opção “Criar novo Projeto Flutter” em destaque.Tente isso: Em Configurar -&gt; Plugins verifique se: a. Os plugins do Dart e Flutter estão habilitados. b. Android APK Support está habilitado. Reinicie o Android Studio. Se ainda não estiver aparecendo, remova e reinstale os plugins do Dart e Flutter." }, { "title": "Como instalar sua distro Linux no Windows+WSL em um disco/diretório personalizado", "url": "/posts/wsl-diretorio-personalizado/", "categories": "Diversos", "tags": "windows, wsl", "date": "2022-01-07 08:00:00 -0300", "snippet": "Se você quer usar WSl mas seu computador, assim como o meu, tem o Windows instalado em um SSD minúsculo e espaço sobrando no HD, você já deve saber que a instalação de uma distro Linux pela Microsoft Store ou pelas instruções da documentação oficial sempre ocorre no mesmo drive do sistema, sem opção. Aqui vai um modo de você instalar sua distro no disco/diretório que você quiser:Se você ainda não habilitou o WSL comece aqui: https://docs.microsoft.com/pt-br/windows/wsl/install-manualWSL habilitado, você pode baixar a distro de sua escolha aqui: https://docs.microsoft.com/pt-br/windows/wsl/install-manual#downloading-distributionsO arquivo baixado será um ´appx´, que você pode renomear como ´zip´ e extrair no local onde a instalação deverá ficar (D:/wsl por exemplo):No terminal/PowerShell:Rename-Item .\\Ubuntu.appx Ubuntu.zipExpand-Archive .\\Ubuntu.zip -VerboseDepois que terminar de extrair, localize na pasta o executável .exe e execute. Você já vai poder criar seu usuário e definir a senha:Installing, this may take a few minutes...Please create a default UNIX user account. The username does not need to match your Windows username.For more information visit: https://aka.ms/wslusersEnter new UNIX username: joaoEnter new UNIX password:Retype new UNIX password:passwd: password updated successfullyInstallation successful!Está pronto! Você pode remover o .zip que baixou pra economizar ainda mais espaço ;)Ah, e se você já tem uma distribuição instalada e quer tentar mover ela, eu não fiz (então não posso dizer se é ok) mas encontrei como aqui:https://avinal.space/posts/development/wsl1.htmlFontes:https://docs.microsoft.com/pt-br/windows/wsl/install-manualhttps://damsteen.nl/blog/2018/08/29/installing-wsl-manually-on-non-system-drivehttps://avinal.space/posts/development/wsl1.html" }, { "title": "Anotações sobre Auditoria de Sistemas", "url": "/posts/anotacoes-auditoria-de-sistemas/", "categories": "Estudos-faculdade", "tags": "gestão, segurança", "date": "2021-12-17 11:14:00 -0300", "snippet": "AULA 1TEMA 1 – DEFINIÇÕES DE AUDITORIA DE SISTEMASA primeira e elementar definição é a de auditoria: “Exame analítico, minucioso, de investigação e validação de um sistema, atividade ou informação” (Michaelis, 2017).Atualmente, auditoria define-se como “um ramo de estudo das ciências de negócios, que avalia determinadas informações com o objetivo de trazer maior eficácia e eficiência, seguindo princípios e normas com aplicações próprias e direcionando a entidade a melhores resultados” (Oliveira, 2015).Imoniana (2016) define o sistema como […] um conjunto de elementos programados, inter-relacionados e interatuantes, que, quando processados, auxiliam na consecução dos objetivos dos negócios por meio de sistemas de informação; por exemplo, os sistemas de informações contábeis que orientam as transações econômicas e financeiras, produzindo relatórios que nortearão a tomada de decisões gerenciais. (Imoniana, 2016)Os sistemas são abertos ou fechados. Os sistemas abertos podem receber dados controlados e não controlados, uma vez que recebem influência do ambiente interno e externo onde operam. Os sistemas fechados, devido à sua natureza, não têm interferência do ambiente e somente poderiam receber os dados controlados.TEMA 2 – OS OBJETIVOS• Melhorar a eficiência e reduzir os custos;• Melhorar a qualidade do trabalho de auditoria, reduzindo, assim, os níveis de risco de auditoria;• Atender às expectativas dos clientes, que esperam de seus auditores o mesmo grau de automatização que utilizam em seu próprio negócio;• Preparar-se para a globalização dos negócios, que vem exigindo uma globalização dos auditores;• Manter-se entre as maiores e mais reconhecidas pelo mercado;• Criar valor agregado para seus clientes, ajudando-os a reduzir os riscos nos processos operacionais.Os benefícios da automação que incluem também os processos de auditoria compreendem, entre outros:• Treinamento de pessoal e superação de resistências à tecnologia;• Melhoria na decisão de quais tarefas devem ser automatizadas em termos prioritários;• Avaliação, escolha e implantação de softwares e hardwares;• Gerenciamento dos recursos eletrônicos: dispositivos de segurança e backup;• Disponibilização de equipamentos para toda a equipe de auditores, podendo trabalhar em redes;• Instalação e manutenção de uma malha de comunicações;• Maior transferência de conhecimento entre os membros da equipe e entre trabalhos de equipes diferentes;• Independência das limitações impostas pelos arquivos de auditoria em papel;• Produtividade e economia de tempo das atualizações;• Melhor qualidade na apresentação;• Liberação de funcionários mais experientes para que se dediquem a áreas mais técnicas e de maior risco;• Agregação de valor ao trabalho de auditoria;• Formação de equipes virtuais (groupware), maximizando a especialização;• Fluxo de informações mais rápido;• Maior satisfação profissional;• Maior respeito pelo auditado;• Maior produtividade;• Conectividade com os parceiros de negócios;• Realização das tarefas sem a automatização pelos profissionais menos experientes, que antes somente poderiam ser executadas por profissionais mais experientes.Lyra (2015) destaca os objetivos globais da auditoria de sistemas de informação: “integridade, confidencialidade, privacidade, acuidade, disponibilidade, auditabilidade, versatilidade e manutenabilidade”. A seguir, são conceituados os objetivos globais, segundo Lyra (2015):1) Integridade: “dentro deste conceito, o auditor verifica se as transações são confiáveis ao serem processadas. Podem verificar se o sistema evidencia claramente a completa e correta exibição dos dados sem que os usuários tenham de se preocupar com a veracidade dos mesmos”.2) Confidencialidade: “Confidencialidade de um sistema consiste em existir mecanismos que barrem pessoas não autorizadas, a terem acesso a informações restritas, de forma acidental ou intencional. Para maior controle, devem existir procedimentos que autorizem o acesso. O auditor pode se basear em como a empresa se preocupa com a organização das informações dentro do sistema. Outra verificação que pode ser feita para medir a confidencialidade de um sistema ERP é através de questionários. Estes questionários devem ser bem elaborados pela equipe de TI, abrangendo as diversas formas de contornar possíveis informações falsas. Eles podem denunciar se os usuários estão com acessos indevidos a informações que não condizem às suas funções. No COBIT, são descritos, pelo objetivo PO2.3 - Esquema de Classificação de Dados, os detalhes sobre o grau de importância que a informação pode ter (pública, confidencial, altamente secreta). Essa diretriz pode ajudar a organização a manter um controle sobre seus dados e informações, criando mecanismos de controles de acesso a informações, arquivamentos e criptografias.” Já o item 12.4.3 Controle de acesso ao código-fonte do programa, da Norma ABNT (2005), frisa a importância restrita aos códigos fonte, evitando riscos de alterações não solicitadas.3) Privacidade: “o auditor deverá certificar-se de que os dados do sistema estão seguros por algum tipo de controle. Este controle visa a liberação de usuários a terem acesso a determinados programas, telas ou rotinas no sistema ERP, que realmente sejam necessários para exercer suas funções na empresa. Procedimento para acesso ao sistema é um exemplo de controle de privacidade”. O item 11.5.1 - Procedimentos Seguros para entrada no sistema da Norma ABNT (2005), foca mais precisamente o login no sistema. O auditor deve discutir a política de usuários do sistema ERP, se existe algum controle para as senhas e qual a periodicidade de trocas.4) Acuidade: “o sistema ERP deve possuir procedimentos internos de controle de entrada de dados, não permitindo a inserção de dados que invalidem as informações resultantes nos relatórios emitidos”. O item 12.2 que trata do Processamento Correto das Aplicações. Este item da Norma ABNT (2005) tem por objetivo garantir que não haja perdas, erros, modificações não autorizadas ou mal-uso de informações em aplicações. (Lyra, 2015)Para isso, o sistema deve possuir, da mesma forma que existe no objetivo global de Integridade, alguns meios de validações, que são:• Validações dos dados de entrada;• Controle do processamento interno;• Integridade de mensagens;• Validação de dados de saída.Estes meios de validação asseguram para o corpo de auditores que o processamento atual está falho ou condizendo ao que se propõe.5) Disponibilidade: “de alguma forma, o sistema deve estar online na maior parte do tempo para não comprometer transações. Na empresa deve existir algum modo em que seja medida a disponibilidade do sistema, para que usuários possam se precaver e para que a própria equipe de infraestrutura de TI possa ter documentado em um repositório em comum junto a analistas de sistemas e analistas de negócios”. Dentro dos domínios do COBIT, existe um processo que trata sobre continuidade de serviços. Este processo chama-se Assegurar a continuidade dos serviços – DS4, o qual tem por objetivo assegurar que as informações estejam disponíveis para usuários e processos autorizados. O ITIL, também faz referência à disponibilidade dos serviços, neste caso disponibilidade do sistema, chamando o processo de Gerenciamento de Disponibilidade.6) Auditabilidade: “o auditor verifica a existência de registros referentes ao sistema. O custo pode ser elevado para o armazenamento de registros, dependendo o tamanho do sistema ERP a ser verificado, e também por causa do número de transações diárias. As trilhas de auditoria podem ser aplicadas neste contexto, também chamadas de audit trails por alguns autores”. A auditabilidade de um sistema, segundo o COBIT, pode ser descrita pelo objetivo AI2 Adquirir e Manter software Aplicativo, e detalhado através do item AI2. 3 - Controle e Auditabilidade do aplicativo. Este item explica a importância em assegurar que os controles de negócio sejam expressos adequadamente nos controles dos aplicativos. Estes controles garantem que o processamento ocorra no prazo correto e seja exato, completo, autorizado e auditável.O controle de aplicação e de auditabilidade é responsável por diversos mecanismos, e para um sistema ERP podem ser citados:• Mecanismos de autorização;• Integridade da informação;• Controle de acessos ao sistema;• Esquemas de rastreamento de auditorias.No item A.15.1, que trata de conformidade com requisitos legais da ABNT (2005), “são destacados os objetivos de evitar violações no sistema que estejam relacionadas com crimes que afetem estatutos, regulamentações ou obrigações”. Alguns dos subitens deste item que são aplicáveis a sistemas ERP em produção são:• Proteção de dados e privacidade da informação pessoal, neste caso do sistema ERP e do usuário;• Prevenção de mau uso de recursos de processamento da informação, em que os usuários devem estar conscientes de que o uso inadequado dos dados extraídos do sistema pode acarretar sérios problemas.Como foi citada pelo COBIT e pela ABNT, a auditabilidade aborda diversos controles dentro de um sistema para poder ser considerada um objetivo alcançável em uma auditoria de sistema ERP. Para um sistema ser considerado auditável, existe certa complexidade devido ao alto nível de conhecimento que exigirá de auditores e sua experiência em poder adequar ferramentas para levantamento de evidências capazes de relacionar pontos de auditoria e serem tratados posteriormente.7) Versatilidade: “a versatilidade está ligada a usabilidade do sistema. Deve ser dada a atenção para disposição dos elementos que compõem o software. Através de questionários aplicados aos usuários podem ser levantadas possíveis melhorias. Além disso, deve ser feita uma análise se novos workflows operacionais de negócio da empresa podem ser adaptados ao software ERP”. Outro importante ponto que LYRA (2015) “pondera é que deve ser observada se a sincronia de aplicativos independentes é fácil de ser feita com o sistema ERP”.8) Manutenabilidade: “durante a manutenção dos sistemas é importante a existência de documentos que descrevam os passos de como proceder em atualização do sistema. Nestes documentos é importante que sejam destacados os responsáveis pelas atualizações, testes que devem ser feitos para certificar a atualização, análise de módulos impactados, formas de restauração de dados caso ocorra algo inesperado e meio de divulgação para as áreas interessadas”. O COBIT trata dentro do domínio de Adquirir e Implementar, o objetivo AI 2.2 - Projeto Detalhado, que visa a prática de revisão de se sistemas estão tendo relevantes discrepâncias técnicas e lógicas. O objetivo apresenta ações que podem ser tomadas para que sejam verificadas falhas que ocorrem em momentos de atualizações de versões de módulos, troca de procedimentos etc.Além disso, dentro do objetivo AI2 – Adquirir e Manter Software Aplicativo, no COBIT é encontrado um item que sugere às empresas estratégia e planos de manutenção do software aplicativo ou software ERP. Isso é importante, pois, no momento em que há atualizações de estrutura do software e de base de dados, a organização pode seguir um passo a passo de como efetuar as atualizações de forma mais organizada.Outros itens deste mesmo objetivo seriam AI6 - Gerenciar Mudanças e AI7 – Instalar e Homologar Soluções e Mudanças, em que o primeiro visa controlar as alterações em ambiente de produção de sistemas aplicativos, de forma adequada e com um gerenciamento controlado. Já o segundo processo prevê um ambiente de homologação para testes e análise de impactos. Na questão de manutenabilidade, no item 12.5.3 - Restrições em atualização de software da norma ABNT (2005), é explicado que mudanças em pacotes de software devem ser limitadas.TEMA 3 – AS COMPETÊNCIAS DO AUDITORTabela 1 – Competência e perfis do auditor de sistemas Tarefas do auditor de sistemas de informação Conhecimentos de tecnologia e sistemas de informações Conhecimentos de auditoria Planejar a auditoria de sistemas documentando nível de risco aparente do ambiente. Definir escopo de auditoria de sistemas e limitações para atender a ISAs, ITGC etc. Definir escopo e apontamento de engagement charter para atender a ISAs e NBC-TAs. Compreender os negócios, o setor, as unidades, os comitês, os executivos, a gerência, o organograma operacional e as partes interessadas, além do plano de valor agregado. Conhecer a governança de TI como adicional de valor e também para definir riscos de controles internos, atentando para alinhamento com os objetivos dos negócios. Conhecer COBIT, COSO. Conhecer a governança corporativa e definir o nível de riscos inerentes, controles e detecção de seu impacto nas demonstrações contábeis. Compreender e certificar-se dos processos-chave e dos procedimentos operacionais para mitigar os riscos. Conhecer os sistemas ERP e suas redes de operações e a relação de infraestruturas que suportam as atividades. Conhecer as aplicações dos negócios e comparar sua função com padrões exigidos pelos organismos reguladores. Compreender e certificar-se da integridade da comunicação de dados interinstituição e intrainstituição e certificar-se do controle. Conhecer o ICT e redes; conectividades e seus funcionamentos. Deve-se incluir roteadores e switches de operabilidade de internet. Conhecer os controles e como podem afetar os testes substantivos de auditoria, tomando como base os conceitos de riscos e materialidade. Compreender e certificar-se da classificação de informações, de pessoas, dados conforme aplicações essenciais para negócios. Conhecer a estrutura de dados da empresa, os bancos de dados em uso como Big Data e sua manutenção. Compreender os procedimentos de controles internos referentes ao funcionamento e às operações, tomando como base as assertivas de controles internos. Verificar a proteção de dados, informações, pessoas e ativos em geral em TI e certificar-se do controle, de SLAs, da disponibilidade e das políticas Conhecer a segurança de informações físicas, lógicas e os requisitos de implementação de políticas de segurança de informações e monitoramento. Compreender os princípios e as práticas contábeis, os processos de compliance das regulamentações de auditoria, além de atenuar os riscos de certificação das contas constantes no Lead schedule. Compreender e verificar o suporte para usuários, para atender às funções críticas aos negócios. Conhecer a operação do computador, o planejamento de capacidade e processamentos, a manutenção de sistemas operacionais e utilitários. Obter conhecimento de geração de relatórios para comparação com dados originais, a fim de testar a integridade dos cálculos e confirmação de saldos, além de outros procedimentos substantivos. Verificar a consistência e a confiabilidade da evolução de sistemas aplicativos em pró tendências dos negócios e seus funcionamentos. Conhecer o processo de aquisição, desenvolvimento, manutenção e documentação de sistemas; em suma, o SDLC– Systems Development Life Cycle. Saber como rodar CAAT e Data Analytics. Obter a confiabilidade das transações processadas em relação às contas contábeis ou aos grupos de contas com ajuda de testes substantivos e procedimentos analíticos, tendo como base as assertivas de integridade (correto e completo), validade, classificação, direito e obrigação, cut-off, existência, valorização e disclosure. Certificar-se da continuidade em caso de contingências nas operações gerais dos negócios. Conhecer os processos de elaboração de implementação de Business Continuity Planning e também de Disaster Recovery Planning. Conhecer o processo de garantia dos funcionamentos essenciais das operações econômicas, financeiras e contábeis em casos de interrupções parciais e prolongadas de TI, a fim de cumprir necessidades de regulamentos, compliance, entre outros. Certificar-se dos contratos de disponibilidades de operações com outsourcing e cloud computing. Conhecer o processo de elaboração de contratos de serviços de TI, SLAs e o monitoramento.   Fonte: Adaptado de Imoniana, 2015.TEMA 4 – ROTEIRO E PLANEJAMENTO PARA ELABORAÇÃOSilva (2007) cita o CobiT (Control Objectives for Information and related Technology) como “ponto de partida para a identificação das atividades de Auditoria de Sistemas de Informação”. Aborda também referenciais ITIL (Information Technology Infrastructure Library) e ISO 17799/27002 para a identificação de atividades, uma vez que estes referenciais são mais específicos em alguns aspectos ligados a sistemas de gestão. A norma ABNT 19011 - Diretrizes para auditoria de gestão de sistemas - também é um referencial para a condução de auditoria.PlanejamentoDesde os primeiros trabalhos deve ser desenhada uma “matriz de risco” que seja permanentemente atualizada a partir dos resultados obtidos nos testes e nas avaliações dos auditores.A título de exemplo, é apresentado a seguir um memorando de planejamento de auditoria de sistemas:(Nome do cliente)MEMORANDO DE PLANEJAMENTO DEAUDITORIA DE SISTEMAS DE INFORMAÇÕESIntroduçãoEste memorando descreve os objetivos, o escopo (abrangências) dos procedimentos a serem avaliados e as abordagens que devem ser adotadas pela equipe de auditoria de sistemas de informações como suporte aos trabalhos de auditoria das demonstrações financeiras do (nome do cliente) para o ano findo em 31 de dezembro de 2015.Conforme o memorando de planejamento de auditoria geral para o cliente, a extensão do uso de informática pelo (nome do cliente) foi classificada como (classificação que pode ser significante, moderada ou pequena). A equipe de auditoria das demonstrações financeiras adotou a estratégia de confiança nos controles internos de todos os sistemas de informações computadorizados, exceto o sistema (nome do sistema), descrito nas seções de riscos específicos identificados (documentar uma seção para riscos identificados quando for necessário).EscopoConforme acordado na reunião de planejamento, o escopo do trabalho de auditoria de sistemas obedecerá ao seguinte: Entendimento global e atualização das seguintes informações: (1) processo e workflow das transações contábeis; (2) ambiente de sistemas de informações; e (3) estrutura de controles computadorizados:•identificar e atualizar a compreensão dos controles de sistemas aplicativos e os controles gerais do computador;•programar testes nos controles que minimizam os riscos identificados para o sistema aplicativo de (nome do sistema);•utilizar de ferramenta ACL (Audit Command Language) para extração de dados do sistema de (nome do sistema) para análises substantivas.Administração de considerações especiaisData para realização dos trabalhos; formalização do no do serviço para controle de horas; endereço da empresa e pessoa-chave para contato; data limite para entregas do relatório final; formato do relatório (padrão específico); destinatário do relatório final e comentários da gerência.Estimativa de horasDe acordo com o tempo de execução das tarefas e os profissionais envolvidos, estimamos o trabalho em 9.999 horas.De acordo:Gerente de Auditoria de SistemasGerente de Auditoria FinanceiraSócio ResponsávelTEMA 5 – PROCEDIMENTOS: ETAPAS DA AUDITORIAA metodologia pode ser composta pelas seguintes etapas:a. Planejamento e controle do projeto de auditoria de sistemas;b. Levantamento do sistema de informação a ser auditado;c. Identificação e inventário dos pontos de controle;d. Priorização e seleção dos pontos de controle do sistema auditado;e. Avaliação dos pontos de controle;f. Conclusão da auditoria;g. Acompanhamento da auditoria.Os procedimentos de auditoria devem contemplar a avaliação de:• Dados e informações, que compõe os resultados do sistema, e• Rotinas de processos do sistema.AULA 2TEMA 1 – DEFINIÇÃO DA EQUIPE DE AUDITORIATEMA 2 – TREINAMENTO E CAPACITAÇÃO PARA FORMAÇÃO DE MÃO DE OBRAO treinamento do grupo com experiência em tecnologia de informação deve incluir:∙ Revisão dos controles gerais (operações, aquisição, desenvolvimento e manutenção, controles de acessos, hardwares, controles organizacionais e suporte técnico); auditoria de sistemas aplicativos, princípios e práticas de auditoria com ênfase nos controles gerenciais e organizacionais, monitoramento e emissão de relatórios;∙ Gerenciamento de riscos, privacidade, desenvolvimento e implementação de políticas e estratégias de segurança de informações;∙ Avaliação dos sistemas on Une com relação ao processamento em tempo real, controles de recall e identificação de programas, verificação das autenticações e autorizações de acessos e registros (contabilização) das transações. Também inclui correção, detecção de erros e manutenção de diários (journaling) das operações;∙ Transmissão de dados, proteção de informações, segurança associada ao uso dos sistemas, teleprocessamentos, redes internet e intranet etc.;∙ Controles de operações, processamento interativo em atividades de negócios e e-commerce;∙ Iniciação de trilha de auditoria em ambiente de tecnologia de informação e propriedade intelectual, abordagens aos métodos existentes e supervisão necessária;∙ Controles de acesso à biblioteca de dados ou programas, armazenamento e recuperação desses dados a partir de bases hierárquicas, relacionais ou data warehousing, plano de contingência e de recuperação de desastres;∙ Software de auditoria, distinguindo-se os softwares generalistas dos específicos, com o apoio dos experts em tecnologia de informação para desenvolver softwares que atentem para as metodologias próprias.Foram classificados em cinco níveis os planos de desenvolvimento de carreira do auditor de TI: Nível 1, básico para os trainees. Nível 2, para os assistentes de auditoria. Nível 3, para os seniores e supervisores. Nível 4, para os gerentes de auditoria. Nível 5, para os sócios. 2.1 Nível 1 – básicoO estágio básico contempla a introdução à tecnologia de informação, com ênfase no objetivo da auditoria, em princípios e práticas, padrões e éticas, papéis de trabalhos, amostragem estatística e sua aplicação em auditoria, controles internos e testes substantivos, além de auditoria das demonstrações financeiras. Contempla também o aprendizado sobre diversas formas de processamento e as tecnologias envolvidas, arquiteturas e plataformas, sistemas operacionais e linguagens de programação. Cabe ressaltar que o auditor apenas precisa aprender aquelas linguagens que achar mais úteis no decurso de seu trabalho.2.2 Nível 2 – fundaçãoEste nível ensina o uso de pacotes de auditoria como ferramenta importante e distingue pacotes específicos dos gerais. Também esclarece que periodicamente o auditor pode se defrontar com dificuldade de encontrar softwares específicos; dessa forma, a necessidade de desenvolver esse software seria inevitável. São abordados neste nível os conceitos de controles de sistemas aplicativos, os controles de entrada de dados, processamentos, saídas e documentação. Nessa fase, ainda, o auditor passa pelos procedimentos de avaliação do ciclo de vida de um sistema, contemplando especificação e justificativa do sistema, desenho, programação, testes e conversão, além da implantação. As responsabilidades dos envolvidos neste processo são normalmente delineadas para facilitar a implementação em consonância com os objetivos e evitar problemas pós-operacionais. Ademais, isso orienta o auditor quanto à aplicação dos conceitos de segregação das funções incompatíveis. O auditor deve estar a par do uso de CASE (Computer Aided Software Engineering), no que diz respeito aos procedimentos de padronização dos processos de produção de softwares. No ambiente de big data que temos hoje, este profissional deverá implementar os recursos de data mining e data analytics. A implementação desses recursos deve incluir trilhas de auditoria.2.3 Nível 3 – focalO estágio consiste no ponto crucial do aprendizado sobre auditoria de tecnologia de informações. Embora no estágio anterior haja demonstração de habilidades envolvendo liderança da equipe, neste estágio devem-se consolidar métodos avançados de auditoria, ferramentas e técnicas. Há ênfase muito grande em torno de detalhes sobre auditoria de controle de acessos e políticas de segurança de informações, inclusive dos gerenciamentos de riscos. O auditor aprende a polêmica sobre barreiras (firewalls) físicas e lógicas, necessárias em ambiente de tecnologia de informação, atentando para seu custo e benefício. Entre os softwares de controle de acessos vistos, incluem-se: RACF, ACF2, UNIX Security, TOPSECRET. É a parte mais técnica da auditoria de tecnologia de informações. Esta fase inclui ainda avaliação dos processos, customização de protocolos de comunicação, análises e monitoramento dos processos de funcionamento de e-commerce, assinatura digital, projetos e gerenciamento de mudanças, teleprocessamentos e auditoria de banco de dados. Adicionalmente, a implementação do sistema baseado em ERP (Enterprise Resource Planning) é avaliada. Ademais, o líder gerencia o relacionamento com seus auditados através de uma comunicação formalizada, no sentido de facilitar as aplicações de técnicas assistidas por computador, quando necessita gravar arquivos junto aos usuários em formatos adequados para testes. Cabe a este profissional desenvolver os planos de otimização de recursos e promover a melhor documentação dos papéis de trabalho.2.4 Nível 4 – integraçãoEste estágio articula todas as funções da organização, controle e monitoramento de recursos de auditoria, com o intuito de alcançar os objetivos de auditoria, apresentando auditores com o know-how necessário para a avaliação do ambiente. Ao profissional cabe a responsabilidade de concluir o trabalho, sobretudo em relação à satisfação ou não da equipe de auditoria a respeito do cumprimento dos passos de auditoria que são documentados nos papéis de trabalho. Juntamente com a equipe, deve decidir sobre a viabilidade dos comentários e as pendências de auditoria, associando o senso crítico de julgamento profissional, tendo em vista a eliminação de possíveis perdas financeiras adicionais para o auditado, que são normalmente resultantes das contingências ou da interrupção das operações rotineiras da empresa. Utilizando-se de suas habilidades gerenciais para administrar os serviços a ele alocados, estabelece planos de treinamento e promoções para sua equipe, planejamento dos serviços, administração de riscos e divulgação das políticas da empresa.2.5 Nível 5 – aconselhamentoEste é o nível mais alto da pirâmide. Uma vez constatado que durante sua carreira profissional adquiriu conhecimentos e preparos para tal, é o momento que o auditor de TI tem para prestar serviços de orientação empresarial a seu cliente, dando insights nas condições de negócios que estão sendo auditados. Nas empresas de auditoria independentes, quem ocupa este cargo é o sócio de auditoria. O sócio desenvolve o relacionamento com seu cliente, adquirindo, no entanto, o direito de ser orientador, tendo conquistado a credibilidade de seu cliente durante certo tempo. Observa-se que vários executivos gostam mais de se abrir com as pessoas que se sentam à vontade, explicando suas ideias e estratégias. “Neste estágio, o sócio coloca em prática sua criatividade, atentando para a identificação de informações relevantes que possam agregar valores aos negócios de seu cliente” (Gil, 1999). Contudo, para que o desenvolvimento dessa carreira tenha êxito, a citação de experiência prática, resolução de estudo de casos, inclusive de workshops com jogos de empresas em todas as fases, seria muito importante. Ainda quando da iniciação de novos trabalhos, aconselha-se uma revisão dos papéis de trabalho anteriores pelos trainees, preparando-os para as tarefas, como também garantindo a qualidade cultivada pelos auditores.TEMA 3 – AS COMPETÊNCIAS DO(A) AUDITOR(A)3.1 Experiência3.2 Capacidade3.3 Conhecimento3.4 DesempenhoEm síntese, o desempenho não é determinado diretamente pela experiência em auditoria (é indiretamente via conhecimento), sendo a capacidade do auditor determinante. Assim, é possível afirmar que a capacidade do auditor é a base, sendo a experiência e o conhecimento (em conjunto) os determinantes do desempenho do auditor.TEMA 4 – AS ÁREAS DE CONHECIMENTO DO AUDITOR DE SICapacidades interpessoaisConhecimentos gerais de gestãoConhecimentos de auditoriaFunções especializadas relacionadas com SIDefinem-se dois grandes tipos de competências, relacionando-se posteriormente com cada uma das quatro áreas de conhecimento fundamentais anteriormente referidas: competências de gestão e competências técnicas.TEMA 5 – AS COMPETÊNCIAS DE GESTÃO VERSUS AS COMPETÊNCIAS TÉCNICASAULA 3TEMA 1 – O PLANEJAMENTO DE AUDITORIA DE SISTEMASPara o planejamento de uma auditoria de sistemas, a principal atividade de início é conhecer o ambiente a ser auditado. Trata-se de entender a estrutura de hardware, software, área de programação e análise, se há operações de TI, estrutura da TI e produtos obtidos através do sistema.Na elaboração do planejamento devem se escolher para serem auditados os processos e os SI que maior risco trazem ou poderão vir a trazer para o negócio em determinado período.Para a compreensão do sistema a ser auditado, a documentação inicial de como está estruturado o ambiente do sistema deve seguir alguns pontos. Imoniana (2015) elenca os seguintes:a) identificação dos sistemas-chaves, neste caso o sistema ERP;b) descrição do sistema;c) descrição do perfil do sistema;d) documentação da visão geral do processamento;e) descrição de riscos dos sistemas aplicativos.”Após estar esclarecido sobre a estrutura inicial do ambiente a ser auditado, o auditor exerce a atividade de análise de riscos. Esta análise de risco é efetuada por meio de investigações nos controles internos, quando se poderão identificar as possíveis fraquezas e seu correto cumprimento.O IIA (2006) tece um conjunto de considerações sobre o modo como as auditorias de SI devem ser definidas que são relevantes quando da elaboração do planejamento:• Evitar o uso de definições/designações de Auditorias de SI muito abrangentes – É comum existir nos planejamentos da Auditoria de SI as chamadas “Auditorias de Controles Gerais”. Estas podem tornar se relativamente inúteis, sobretudo em grandes organizações, dado que, ou não cobrem todo o universo dos SI, ou para fazê-lo, tornam se intermináveis no tempo. Por outro lado, há que ter muito cuidado na designação que se atribui às Auditorias pois podem induzir em erro a Gestão de Topo e a Gestão dos SI quanto à verdadeira abrangência do plano de Auditorias.• O planejamento deve tocar todos os níveis de SI - O planejamento deve considerar a cada ano, pelo menos uma Auditoria em cada um dos níveis de controle dos SI: Governo, Gestão, Técnico. Caso não ocorra, existe sempre o risco de a organização considerar o planejamento omisso ou incompleto como um todo.• O planejamento deve prever Auditorias que formem conjuntos lógicos de relatórios sobre determinados temas - As Auditorias devem ser planejadas de modo a fornecer um reporte eficaz e lógico dos resultados. Para ilustração, as Auditorias aplicacionais raramente são eficazes se forem divididas em Auditorias independentes (exemplo: auditar todos os módulos de SAP e não apenas o módulo financeiro). De modo semelhante, as Auditorias às tecnologias da rede corporativa tendem a ser mais eficazes quando efetuadas ao nível de toda a organização (exemplo: não auditar a segurança da rede em uma só localização/instalação).• O planejamento e respectivo orçamento devem cobrir os riscos de forma apropriada – O planejamento das Auditorias e o orçamento do departamento devem ser um resultado do processo de avaliação de riscos de SI, não devendo ser definidos antes de se proceder a essa avaliação. Esta deve ser efetuada no contexto da avaliação de riscos feita para toda a organização. Ao contrário do que acontece com outros tipos de Auditoria Interna com histórico mais longo nas organizações (exemplos: Auditoria Financeira, Auditoria de Qualidade, etc.), a estimativa de um orçamento para Auditoria de SI pode ser induzida em erro caso utilize técnicas de comparação com outras Auditorias ou se guie por ordens de grandeza. O orçamento da Auditoria de SI deve ser estimado em função da avaliação dos riscos de SI, deve possuir um processo de pré-planejamento robusto e deve contar com os contributos da Gestão dos SI (IIA, 2006)TEMA 2 – OS DETALHES DO PLANEJAMENTOA razão deste planejamento inicial é o direcionamento e a coordenação para a execução da auditoria. Este planejamento agrega todos os processos de auditoria elencados:a. Conhecimento do ambiente.b. Estabelecimento de estratégias.c. Aplicação de técnicas.d. Análise de etapas executadas.e. Relatórios finais.A norma da ABNT (2002) considera que “para o início dos trabalhos é importante o desenvolvimento de um plano de auditoria que contemple o maior número de detalhes possíveis”. A flexibilidade deve ser considerada, de modo que, conforme evoluam as atividades de auditoria, o plano possa sofrer modificações. A seguir, são elencados alguns itens considerados pela norma:• Objetivos da auditoria.• Escopo da auditoria.• Datas e lugares onde as atividades de auditoria serão realizadas.• Definição de funções e responsabilidades dos membros da equipe de auditoria e das áreas auditadas.• Principais pontos do relatório de auditoria.• Quaisquer ações de acompanhamento de auditoria.A primeira atividade é interpretar esse modelo, definindo que o risco(Recognition and Appreciation of Business Risks) é o elo entre o lado do negócio e o lado da auditoria. No lado do negócio, constata-se que os objetivos de negócio determinam o plano estratégico (Strategic Planning Process), que, por sua vez, determina o plano anual de negócios (Annual Business Plan), o qual tem impacto nos processos e nas áreas de negócio (Process or Work Unit Objectives). Uma vez que a auditoria de SI deverá estar alinhada com as necessidades do negócio, então do lado da auditoria o planejamento deverá seguir um raciocínio semelhante. No lado da auditoria, partindo do universo da auditoria (Audit Universe Process), deverá ser elaborado um plano anual de auditorias (Annual Audit Plan) que determinará o âmbito de cada auditoria individual (Individual Audit Scope) e terá impacto no modo como as áreas de negócio avaliam e gerem os seus riscos (Evaluate How Business Risks are Managed).O modelo vai ainda mais longe quando afirma que as metodologias de avaliação de risco a utilizar (fatores de risco, modelos de risco etc.) podem ser derivadas diretamente da especificidade de cada processo de negócio (Industry Specific Scenarios Approaches Models) em vez de serem determinadas unicamente pelos processos de auditoria.Esse modelo prevê dois órgãos de governo da organização (a Gestão de Topo e o Comité de Auditoria) que têm como responsabilidades contribuir para a elaboração e dar aprovação ao universo da auditoria e ao seu planeamento anual. É, no entanto, da responsabilidade do departamento de auditoria da organização transmitir a esses órgãos de governo cultura e percepção de risco, alinhadas com as restantes áreas da organização, e informá-los sobre as exposições aos riscos da organização.A função de auditoria de SI deve reportar ao responsável do departamento de Auditoria e Gestão de Risco. Por sua vez, este deverá reportar ao Comité de Auditoria e Gestão de Risco e, por via deste, ao responsável máximo da organização, que é o CEO (Chief Executive Officer). Note-se que o modelo de reporte aqui defendido difere ligeiramente face à maior parte das organizações em que a Auditoria e Gestão de Risco reporta ao CFO (Chief Financial Officer) ou, nalguns casos, diretamente ao CEO. No sentido de garantir maior coerência com a abrangência das funções de Auditoria e Gestão de Risco, defende-se um reporte ao CEO, e não ao CIO.Diferentemente, os responsáveis pelo departamento de SI deverão reportar diretamente à gestão de topo da organização, nomeadamente ao CIO (Chief Information Officer). Este papel (CIO) justifica-se com o fato de existir um processo de negócio responsável pela gestão dos recursos associados à informação, incluindo os SI e as TIC.Figura 1 – Posicionamento e organização da funçãoFonte: Silva, 2007.TEMA 3 – A CRIAÇÃO DO PLANO DE AUDITORIAAs técnicas que Imoniana (2005) cita “seriam por meio de visitas ou entrevistas junto a gestores ou analistas das áreas”. Os resultados dessas atividades servirão como base para a montagem do plano de auditoria, o relacionamento e o início da análise dos pontos de controle.3.1 Criação do plano de auditoriaO plano de auditoria é um artefato elaborado durante toda a auditoria e deve ser preenchido conforme o roteiro determina, sendo geralmente no fim de cada uma das fases. Seu principal objetivo é agregar informações e dados a respeito do programa de auditoria, de forma que seja simples de ser utilizado dentro de um programa de auditoria e para consultas de gestores interessados nas informações contidas. O plano de auditoria é composto basicamente pelos tópicos que aparecem na figura 3.Figura 3 – Tópicos básicos de um plano de auditoriaFonte: ABNT, 2002.Planos de auditoria são flexíveis, sendo modificados durante o processo de auditoria. Com a criação do plano de auditoria, a fase atual pode ser dada como encerrada.É demonstrado na Figura 4 um modelo de um plano de auditoria básico, que pode ser adaptado para auditorias de sistemas específicos.Figura 4 – Modelo de um plano de auditoria básicoFonte: Brandalise, 2012.TEMA 4 – ANÁLISE E DEFINIÇÃO DOS PONTOS DE CONTROLENesta fase, começam a ser trabalhados os pontos de controle do sistema. A fase está dividida em atividades que têm por objetivo tratar os pontos de controle, de modo que se tenham diversas etapas antes da definição de quais vão ser trabalhados, observando os objetivos estabelecidos no plano de auditoria para as etapas de identificação e definição dos pontos de controle a serem utilizados no programa de auditoria.Na Figura 5 é apresentado o ciclo de definição de um ponto de controle, que ao fim se torna um ponto de auditoria e é utilizado como evidência de auditoria no processo.Figura 5 – Ciclo de vida dos pontos de controleFonte: Brandalise, 2012.4.1 Organização, identificação e definição dos pontos de controle Na Figura 6, é apresentado recorte da atividade de organização, identificação e definição dos pontos de controle. Dentro dessa atividade, existem artefatos de entrada que apresentam matrizes, em que serão tratados os pontos de controle envolvidos, dividido por etapas para sua seleção.Figura 6 – Atividades dos pontos de controle| Análise e definição dos pontos de controle | Organização, identificação e definição de pontos de controle | • Criação de arquivo que contém os pontos levantados e critérios estabelecidos • Reuniões com a comissão • Análise de auditorias passadas e pontos considerados importantes | Etapa 1 – Matriz de ponto de controle identificado Etapa 2 – Matriz ponto de controle identificado Etapa 3 – Matriz de ponto de controle definido | Modelo matriz pontos de controle identificados Matriz pontos de controle de auditoria | Equipe de auditoria, auditor líder, gestão ||———————————————-|—————————————————————-|——————————————————————————————————————————————————————————–|——————————————————————————————————————————————————–|—————————————————————————————-|———————————————-|Fonte: Brandalise, 2012.“O artefato inicial a ser utilizado será chamado Matriz Pontos de Controle Identificados e será composto por pontos de controle, seus detalhes específicos e os riscos de cada ponto apontado pelos participantes da seleção” (GIL, 99).A avaliação de riscos será baseada nas etapas existentes na identificação de riscos, que são:• Identificação de pontos.• Identificação de ameaças.• Identificação de vulnerabilidades.• Identificação de consequências.As identificações de vulnerabilidades e consequências de risco estarão relacionados ao conhecimento de negócio que o gestor e usuários envolvidos apontarão como sendo razões para o ponto elencado, e constarão na coluna de riscos do artefato Modelo Matriz Pontos de Controle Identificados.Após o artefato Modelo Matriz de Pontos de Controle Identificados estar preenchido, parte-se para a etapa de seleção de pontos de controle a serem trabalhados. O artefato que contempla estas informações é o de Matriz Pontos de Controle Definidos. Este artefato conta basicamente com os pontos de controle a serem analisados pela comissão e gestores, os riscos já identificados e uma coluna para o grau de importância a ser preenchido.A lógica de avaliação segue a importância que representa para a empresa o ponto de controle registrado. É importante que seja avaliado com cautela e baseado nos objetivos definidos no plano de auditoria. Através de reunião, o líder de equipe convoca gestores e usuários chave para o preenchimento individual do anexo e a definição dos pontos definidos. Durante a avaliação individual, o participante avalia os campos já preenchidos. Nesta avaliação existe a atividade de análise de risco agregada, onde cada participante deve considerar o risco do ponto elencado no momento de avaliar os graus de cada um deles.Após realizada a votação a partir do artefato Matriz Ponto de ControleDefinidos, fica a critério da comissão ou dos auditores a formalização em um documento simples, sobre os pontos de controle selecionados para os trabalhos de auditoria. Para o andamento das atividades de programa de auditoria ocorrer, quando finalizado o processo de escolha dos pontos, deve ser criado um novo artefato. Este novo artefato chamado Modelo de Matriz Pontos de Controle Auditoria, trata basicamente da listagem dos pontos de controle definidos anteriormente e será usado também na fase de preparação e execução de atividades. Neste documento o auditor líder irá delegar as responsabilidades para a equipe de auditoria interna. Ele conterá registros dos auditores responsáveis por cada ponto, uma coluna para serem citadas as técnicas a serem aplicadas nos pontos, características, referências pesquisadas, considerações sobre a aplicação das técnicas e descrição de sugestões de melhoria para cada evidência relatada no ponto.Portanto, nesta fase de Análise e Definição dos Pontos, serão preenchidos os campos de ponto de controle e responsáveis, deixando os demais para a próxima fase, que contará com as informações geradas após a aplicação das técnicas de auditoria aqui elencadas. (Brandalise, 2012)TEMA 5 – PREPARAÇÃO E EXECUÇÃO DE ATIVIDADESNesta fase, começa a acontecer a auditoria propriamente dita com o exame dos pontos de controle definidos.O artefato Modelo de Matriz Pontos de Controle Auditoria possui a listagem de pontos de controle definidos. Esse documento deve vir com alguns campos preenchidos pela equipe de auditoria, como os próprios pontos de controle, as técnicas de auditoria e o responsável por cada ponto.O ponto de controle passa a ser chamado de ponto de auditoria. É na atual fase que serão aplicadas as principais técnicas de auditoria elencadas na fase anterior, para o levantamento de evidências e não conformidades de auditoria.“Antes de emitir relatórios finais, é imprescindível solicitar a compreensão ou não dos auditados para dirimir as dúvidas que porventura tenham persistido durante o processo de auditoria” Imoniana (2005). Os artefatos usados neste momento são a carta-comentário e o rascunho preliminar do relatório final de auditoria.A ABNT (2006) apresenta a etapa de comunicação de risco, “que no âmbito da auditoria pode ser associada a comunicação de evidências de auditoria. O objetivo é semelhante, fazer com que as partes envolvidas no processo de auditoria tenham conhecimento do que foi abordado e evidenciado ao longo dos trabalhos”.Para a pré-formalização do fechamento do programa de auditoria por parte dos auditores, pode ser utilizada a carta comentário. Ela é um artefato sucessor ao rascunho preliminar de auditoria, o qual estes apenas dependem da aprovação por parte dos destinatários, que podem ser os gestores responsáveis pelas áreas envolvidas. (Brandalise, 2012)Para que a carta-comentário contenha uma base de informações consistente, a equipe de auditoria elabora o artefato chamado Rascunho Preliminar do Relatório de Auditoria. Esse artefato é um arquivo gerado e preenchido pela equipe de auditores com base na avaliação de artefatos gerados em outras fases do roteiro, principalmente dos resultados dos pontos de auditoria, e que será enviado anexo à carta-comentário, onde constarão os tópicos que seguem:a. Objetivo do controle;b. Considerações no ponto;c. Descrição dos procedimentos executados;d. Resultados;e. Não conformidades e evidências achadas;f. Recomendações;g. Aval dos responsáveis internos.Dentro destes tópicos, o destinatário, que provavelmente será algum responsável pelo acompanhamento de auditoria ou um gestor, terá apenas de preencher o último tópico. Com a aprovação deste rascunho de relatório e o conhecimento de todas as partes interessadas, a próxima atividade é a criação do relatório final. Este relatório final é de responsabilidade do Líder da Equipe de Auditoria. Além de informações contidas no rascunho inicial, devem ser citados outros elementos que compõe o processo de auditoria, são eles:a) relação de normas, instruções, procedimentos e outros documentos utilizados como base (referência) para as avaliações;b) relação dos membros de equipe de auditoria;c) nomes de quaisquer outros observadores, participantes e de pessoas que foram contatadas em qualquer fase da auditoria;d) constatações finais, dando ênfase para deficiências detectadas. Devem ser fornecidos detalhes suficientes para permitirem avaliação, ação corretiva e providências complementares pela organização/setor auditado.O relatório pode ser distribuído aos gestores e responsáveis no momento da comunicação de encerramento do programa de auditoria, para que tenham o conhecimento dos resultados e pareceres finais extraídos do programa implantado. (Brandalise, 2012).Conforme citado na norma da ABNT (2002), “as ações corretivas, preventivas ou de melhoria, que podem ser aplicáveis ao fim da apresentação dos resultados fica a critério do auditado e não são consideradas como parte da auditoria”. A norma também enfatiza que, para a verificação das ações, pode ser criado outro programa de auditoria, para que sejam verificadas as ações tomadas e a sua eficácia.AULA 4TEMA 1 – FUNDAMENTOS DE CONTROLES INTERNOS EM SISTEMAS DE INFORMAÇÕESO conceito de controle interno em um sistema de informação, conforme declaração do Instituto Americano de Contadores Públicos (AICPA, 2017) significa […] planos organizacionais e coordenação de um conjunto de métodos e medidas adotado numa empresa, a fim de salvaguardar o ativo, verificar a exatidão e veracidade de registros contábeis, promover a efetividade de sistema de informação contábil e eficiência operacional, assim como fomentar uma grande adesão às políticas da organização. (AICPA, 2017)A auditoria de sistema de controle interno de uma organização inclui verificações dos processos e confirmação quanto à sua efetividade, e é por isso que é regida pela lei da variedade de requisitos. Entretanto, esta última característica deveria ser observada se a organização, devido a seu sistema dinâmico operacional claramente definido, tem que manter fidelidade e/ou integridade de informação, eficiente e eficaz.A eficácia de um sistema tem sido visualizada quanto à consecução da missão de tecnologia de informação. Vejam: se o objetivo do sistema for reduzir headcount ou agilizar o processo de tomada de decisão, este tem que ser atingido, ou o sistema não virá ao encontro da sua expectativa e poderá ser julgado a partir da função de fornecer informação necessária ao processo de tomada de decisão da gerência.1.1 A importância dos controles internosA importância do controle interno pode ser resumida, segundo Attie (1992, p. 61), considerando-se os seguintes fatores:Para controlar as operações eficientemente, a administração necessita de relatórios e análises concisos, que reflitam a situação da companhia; um sistema de controle interno que funcione adequadamente constitui a melhor proteção para a companhia contra as fraquezas humanas. As rotinas de verificação e revisão são características de um bom controle interno, que reduzem a possibilidade de que erros ou tentativas fraudulentas permaneçam por muito tempo e permitem à administração possuir maior confiança na adequação dos dados. (Attie1992)1.2 Princípios fundamentais de controles internosOs princípios fundamentais de controle interno são:É necessário fixar as responsabilidades – para ter clara delimitação de responsabilidade em um sistema bem planejado. Caso contrário não haverá́ eficiência;∙ os registros devem estar separados das operações – as funções de operações e registro são incompatíveis entre si e, por conseguinte, não devem ser executadas pela mesma pessoa;∙ o ciclo completo de uma transação não deve ser executado apenas por uma única pessoa – nenhuma pessoa deve ter a seu cargo a realização de todas as fases de uma transação comercial. Qualquer pessoa, seja funcionário ou administrador, comete erros, deliberados ou não, porém é muito provável que o erro seja descoberto quando a transação, para sua completa concretização, necessariamente envolva duas ou mais pessoas;∙ o pessoal envolvido com funções de controle deve ser criteriosamente selecionado, bem treinado – antes de contratar qualquer funcionário com vista ao preenchimento de cargos que tem função de controle é necessário que o seu passado seja investigado e suas referências conferidas. O treinamento é imprescindível para familiarizar o novo empregado com suas tarefas;∙ sempre que possível, promover o rodízio de funcionários – periodicamente deve ser promovido um rodízio de funcionários, de modo que cada um possa ser capaz de executar outras tarefas. Isso aumenta a segurança do sistema, ao eliminar os chamados funcionários imprescindíveis, além de estimular a criatividade de cada um, mediante os desafios implícitos que as novas funções trazem. Todos necessitam de férias regulares, o que resulta em maior produtividade operacional e reduz a possibilidade de ocultação de fraudes;∙ as tarefas devem estar previstas no manual da organização – preferencialmente todas as instruções necessárias ao desempenho funcional dentro do sistema devem ser escritas e catalogadas em um manual de organização. Aqui também se espera conseguir aumento de eficiência operacional, juntamente com a diminuição do risco de erros;∙ os responsáveis pela custódia de numerários e outros ativos devem ter seguro-fidelidade – além de proteger o patrimônio da entidade em caso de desvio, o seguro-fidelidade é um freio psicológico para as tentativas de desfalques, pois os funcionários sabem que a companhia seguradora somente indenizará prejuízo quando houver comunicação da ocorrência à autoridade policial, e assim as responsabilidades serão apuradas;∙ devem ser utilizados equipamentos informatizados para registro automático de operações – sua utilização evita erros e aumenta consideravelmente a eficiência do sistema de controle, permitindo a realização simultânea de vários procedimentos de registro. (CEAD, 2017)TEMA 2 – CONTROLES INTERNOS EM TI, PRINCÍPIOS, FINALIDADES E OBJETIVOSA natureza e a extensão de controles necessários em ambiente de tecnologia de informação variam paulatinamente de acordo com a complexidade da tecnologia de informação em operação. Para aquele(a) que acompanha o sistema de controle em um ambiente particular, é imperativo determinar e padronizar os tipos de equipamentos em operação, a natureza dos dados que são processados e os procedimentos metodológicos existentes. Num ambiente de sistema computadorizado básico, que processe seus dados mais manualmente do que computacionalmente, pode haver uma necessidade de procedimentos, tais como:∙ Identificação;∙ Autorização;∙ Autenticação;∙ Classificação de dados que sejam realizados manualmente.Evidentemente, o sistema necessitará mais de controles convencionais do que de controles modernos e computadorizados, que são bastante direcionados para ambientes de tecnologia de informação mais complexos. Para isso, vários tipos de controles são estabelecidos pela gerência de uma organização para manter uma administração própria de um sistema computadorizado. Eles envolvem:∙ Controles organizacionais;∙ Controles de segurança e privacidade;∙ Controles de preparação;∙ Controles de entrada;∙ Controles de processamento;∙ Controles de recuperação e armazenamento de dados;∙ Controles de saída.2.1 Finalidades dos controles internosExistem interpretações distintas atribuídas ao conceito de proteção de ativos de uma entidade. A mais abrangente entende que os ativos devem ser resguardados de qualquer situação indesejável. Nesse caso, compreende-se que a proteção dos ativos atuais e futuros se constitui numa das funções principais da administração da companhia.A segunda interpretação do conceito de proteção de ativos, menos abrangente, leva em consideração que tal conceito refere-se à proteção contra erros involuntários (não intencionais) ou irregularidades intencionais. Citam-se exemplos, tais como: erros provenientes de cálculos incorretos, realização de procedimentos indevidos ou sua omissão. (CEAD, 2017)As interpretações do conceito de proteção entendem que a proteção dos ativos se referem tão somente aos erros intencionais (fraude).2.2 Objetivos dos controles internosOs principais objetivos de um sistema geral de controle interno são:∙ Proteger os ativos de uma organização;∙ Manter a integridade;∙ Corrigir e garantir a confiabilidade dos registros;∙ Promover a eficiência operacional;∙ Encorajar o cumprimento dos procedimentos e das políticas da gerência.Esses objetivos não apresentam diferenças nos procedimentos de controles internos em ambientes de tecnologia de informações.Princípios de controles internos geralmente aceitos em ambiente de tecnologia de informação constituem a parte integral dos objetivos e princípios de controles internos em âmbito global, mesmo ainda não tendo aceitação universal. Contudo, alguns desses princípios estão em operação dentro dos ambientes computadorizados e são aceitos.Segundo Imoniana (2015) eles são:Supervisão – A gerência, por objetivos, procedimentos e tomada de decisões, deve manter um controle que a capacite a uma supervisão efetiva dentro do ambiente de tecnologia de informação.Registro e comunicação – A gerência da empresa deve estabelecer critérios para criação, processamento e disseminação de informação de dados, através de autorização e registro de responsabilidades.Segregação das funções – As responsabilidades e ocupações incompatíveis devem estar segregadas de maneira a minimizar as possibilidades de perpetuação de fraudes e até de suprimir erro e irregularidade na operação normal.Classificação de informação – A gerência deve estabelecer um plano para classificação de informação que melhor sirva às necessidades da organização, em conformidade com os princípios de contabilidade geralmente aceitos e também padrões de auditoria geralmente aceitos.Tempestividade – A gerência deve delinear procedimentos, monitorar os registros corretos das transações econômicas, financeiras e contábeis das empresas, processando-as e comunicando os resultados às pessoas necessárias em tempo hábil.Auditoriabilidade – Os procedimentos operacionais devem permitir a programação e verificação periódica no que concerne à precisão do processo de processamento de dados e de geração de relatório, de acordo com as políticas.Controle independente – Os sistemas em funcionamento devem ter procedimentos adequados para identificação e correções de erros no fluxo de processamento, inclusive nos processos executados concomitantemente.Monitoramento – A gerência deve possuir acesso master ao sistema e controle de uso, que lhe permita fazer o acompanhamento pari-passu das transações.Implantação – A gerência deve planejar a aquisição, o desenvolvimento, a manutenção e a documentação de sistema, de forma a coincidir com as metas empresariais.Contingência – A gerência deve implementar um plano adequado e procedimentos para prevenir-se contra as falhas de controles que podem surgir durante especificações de sistema, desenho, programação, testes e documentação de sistemas e nas fases pós implantações.Custo efetivo – Investimentos em tecnologia de informação devem ser propriamente planejados, a fim de coincidirem com o custo efetivo. Imoniana (2015)TEMA 3 – TIPOS DE CONTROLES INTERNOSOs controles internos são […] os planos organizacionais e coordenação de um conjunto de métodos e medidas adotado numa empresa, a fim de manter o ativo, verificar a exatidão e a veracidade de registros, promover a efetividade de sistema de informação e fomentar uma grande adesão às políticas da organização. Estes controles internos dividem-se em organizacionais, controles de segurança e privacidade, controles de preparação, controles de entrada, controles de processamento, controles de recuperação, de armazenamento de dados e de saída. Imoniana (2015)3.1 Controles administrativos e gerenciaisEm organizações cujas responsabilidades são impropriamente delineadas, a fraude é perpetrada facilmente, devido ao conhecimento de que ninguém será responsabilizado. Assim, o trabalho dos desenhistas de controles administrativos e gerenciais é segregar adequadamente as tarefas e/ou atividades incompatíveis: quem prepara a entrada de dados, quem processa os dados, quem os gerencia e quem são os usuários finais. Mais da metade dos casos recentes de fraude no computador envolveu conivência. Esse é um incidente muito maior do que uma fraude manual e pode significar que a fraude em computador requer mais habilidade, acesso e conhecimento do que simples conhecimentos gerais.3.2 Controles de segurança e privacidadeOs controles de segurança de dados em sistema de informações computadorizados são referentes à proteção de informação, evitando-se atos de destruição intencionais, ou não intencionais, acidentes e outros atos de sabotagem. Outros são referentes a furtos, manipulação fraudulenta ou divulgação de informações sigilosas para competidores a fim de obter vantagens próprias. Os controles de segurança em detrimento do funcionamento normal do sistema são também concernentes às provisões de facilidades de backup. Segundo Imoniana (2015), as propriedades dos controles de segurança de sistemas são:SIGILO: fornecer uma privacidade ou situação estritamente confidencial aos dados. Um pequeno deslize nesta propriedade conduz a uma derrocada de assuntos restritos.INTEGRIDADE: fornecer um requisito de informação completa, correta e válida, e confiabilidade a dados autorizados, guardando-os das distribuições e modificações não usuais. Qualquer sistema que preencha tais requisitos estará manifestando as propriedades de integridade.DISPONIBILIDADE: tornar os dados disponíveis a quem quer que esteja autorizado a usar tais dados. Apesar de ser dada proteção total aos dados, os requisitos para usá-los não devem ser prejudiciais. No entanto, poderão ser extraídas informações com um mínimo esforço ou interferência.CONTABILIDADE: registrar todas as transações ocorridas nos sistemas, a fim de permitir o relato correto do conteúdo dos dados alimentados no sistema e, sobretudo, permitir, quando for necessário, rastrear a verdade e reportar a visão justa das informações armazenadas.AUDITORIABILIDADE: em qualquer sistema de segurança, os dados devem ser auditados. Isso possibilita à gerência relatórios de acompanhamento, para que se saiba se estão sendo efetivos os controles implementados. O sistema também deve fornecer facilidade necessária para exames e averiguação de responsabilidades. Imoniana (2015)3.3 Controles de preparação e captação de dadosEste é um controle exercido no começo de cada atividade de processamento de dados. Envolve o recebimento de documentos (dados-fonte), pré-numerando e preparando o input, o qual vem a constituir-se no processo de conversão dentro de uma linguagem de máquina. Esses documentos, quando recebidos, são agrupados em batches (lotes), preferivelmente aquelas transações que possuem sequência de processamento comum, através dos comandos de leitura do lote. Normalmente, é aconselhável minimizar o tamanho do lote, de maneira que facilite a investigação dos erros. Os lotes muito grandes dificultam a descoberta dos erros de processamentos.3.4 Controles de entrada de dadosOs controles de entrada visam assegurar que os dados de entrada sejam validados, editados e consistentes com o tempo e com dados-fontes. A validação de dados de entrada identifica erros de dados, dados incompletos ou faltantes e inconsistências.Esses controles são embutidos nos próprios sistemas, que ajudam a indagar quanto à veracidade das transações que estão sendo efetivadas. Quaisquer inconsistências são negadas.3.5 Registro de erros e manipulaçãoOs processamentos de entradas exigem que os controles sejam identificados para verificar se os dados são aceitos no sistema corretamente e se os erros de entrada são reconhecidos e corrigidos. A entrada de manipulação de erro pode ser processada das seguintes formas:∙ Rejeitando operações com erros;∙ Rejeitando todo o lote de transações;∙ Segurando o lote em suspense;∙ Aceitando o lote e as operações com erros sinalizados.3.6 Controles de processamentoCom o pressuposto de que os dados corretos entraram no computador de forma segura, os controles de processamento são aqueles responsáveis pelo lançamento do relatório pretendido. Algumas das atividades são checagens da sequência dos arquivos mestres e arquivos de transações e checagem dos campos dos arquivos, para detectar superposição de dados. Esse controle faz uso do limite lógico, dos testes de racionalidade e de total cruzados. O limite lógico e a racionalidade verificam a extensão para a qual o processamento foi executado, se está no limite predeterminado e, então, checam sua racionalidade e fazem o cross-footing.O cross-footing é aquele controle similar às técnicas manuais para comparar totais independentes de itens individuais com o derivado do total geral, o qual é executado nos formatos programados. Frequentemente utilizados, são controles de balanceamento, nos quais os registros processados são reconciliados a fim de assegurar a integridade do log de transação.3.7 Controles de saída e de emissão de relatóriosOs controles de saída visam garantir que as informações entregues aos usuários sejam apresentadas em formatos corretos, completas, para atender às necessidades desses usuários, e, ainda, consistentes com modelos preestabelecidos e de forma segura. Os controles de saída incluem:∙ Registro e armazenamento de documentos sensíveis e críticos em local seguro;∙ Geração pelos computadores de instrumentos negociáveis, formulários e assinaturas e distribuição de relatórios;∙ Equilíbrio e conciliação;∙ Tratamento de erros de saída;∙ Retenção de relatório de saída; e∙ Verificação de recebimento de relatórios.3.8 Controles de gravação e recuperação de dadosA biblioteca de dados controla a liberação de dados para o processamento e seu armazenamento subsequente. Esse controle certifica a integridade de dados recebidos dentro da data-base, e qualquer indivíduo autorizado pode acessá-lo com o mínimo esforço.Para se obter acesso ao banco de dados, os controles relacionados ao uso de passwords e códigos de acessos são muito importantes.No que se refere a tipos mais desastrosos, os planos desastre, contingência e recuperação de dados são usados a fim de abranger todas as prováveis ameaças. Os planos são revisados e testados de tempos em tempos, à medida que nova tecnologia ofereça novos riscos.TEMA 4 – AVALIAÇÃO DOS PROCEDIMENTOS DE CONTROLES INTERNOS DE SIExame da configuração de sistemas de segurança de informação atende às políticas e do processo de compliance que fornece o mais alto nível de garantia sobre a afirmação de que um auditor pode proporcionar. São exemplos de teste:∙ Teste de controles: efetuar o walk-through do processo de movimentação;∙ Testes substantivos: recalcular totais de inventários e custos de produtos vendidos.Geralmente, as assertivas podem ser estabelecidas pelos auditores em nível de transação:∙ Integridade – as operações registradas e tratadas não foram processadas corretamente, considerando todos os comandos, e estão incompletas, considerando todos os dados necessários a partir do banco de dados para concluir a operação.∙ Válido – todos os dados que resultaram em débito das contas devem representar as operações que realmente ocorreram e que estão relacionadas com os ativos existentes.∙ Registro – todos os dados registrados em uma rotina devem ser resumidos em um valor que não está acima do que é apropriado para o período. Cut-off – crédito antecipado ou postecipado/débito devem refletir uma operação que ocorreu em um período em curso e não posterior.TEMA 5 – ANÁLISE DE RISCO NA AVALIAÇÃO DE SISTEMA DE CONTROLE INTERNO A análise de risco é uma metodologia adotada pelos auditores de TI para saber com antecedência quais as ameaças puras ou prováveis em um ambiente de tecnologia de informação de uma organização. Essas ameaças constituem eventos futuros não desejáveis e incertos, cuja ocorrência resulta em perdas. (Imoniana, 2015)AULA 5TEMA 1 – COMPLIANCE Estar em Conformidade (to Comply, em inglês) interna e externamente traz uma série de benefícios imediatos para uma organização. Destaca a empresa nos ambientes comerciais e sociais como séria e responsável do chão de fábrica a mais alta esfera executiva, trazendo consumidores cada vez mais atentos. (Mercadológica, 2017)Também oportuniza vantagens competitivas que se juntam à credibilidade, permitindo acessos a linhas de crédito antes restritas, valoriza o clima de confiança interno e certamente um melhor retorno de investimentos. Implantar um programa de compliance é investimento.1.1 Procedimentos para implantação de programa de compliance∙ Fixação de padrões de conduta, código de ética e políticas internas e externas de relacionamentos críticos.∙ Gestão de riscos, paralelamente aos procedimentos de auditoria e acompanhamento gerenciais, com transparência e respostas ágeis e efetivas em casos identificados de desvios dos padrões fixados.∙ Melhoria contínua de processos, monitoria do programa e treinamentos frequentes.∙ A integridade corporativa é essencial para a proteção dos investidores, colaboradores, parceiros comerciais e para a redução de danos causados por fraudes e corrupção.1.2 ISO 37001 – Norma certificável de programas de complianceIndependentemente de tipo, tamanho e natureza da atividade, seja do setor público, privado ou sem fins lucrativos, os requisitos da ISO 37001 podem ser aplicáveis a qualquer organização. Seu principal objetivo é apoiar as organizações a combaterem o suborno por meio de uma cultura de integridade, transparência e conformidade com as leis e regulamentações aplicáveis, com os requisitos definidos pela ISO 37001 e pela própria organização por meio de políticas, procedimentos e controles adequados para gerenciar os riscos relativos ao suborno.TEMA 2 – NORMAS, GUIAS E PROCEDIMENTOSAs organizações podem exercer a Governança dos SI (IT Governance) por abordagem local (ad-hoc), com a criação dos seus próprios referenciais, baseados na experiência da organização, ou utilizar normas internacionais desenvolvidas e aperfeiçoadas, recorrendo à experiência acumulada de um grupo de organizações e de profissionais da vanguarda de SI.A utilização dessas normas internacionais é apresentada e defendida por Spafford (2003) como a mais adequada, pois tem as seguintes características e benefícios:Já existem - Não há vantagens em investir tempo e esforço no desenvolvimento de um referencial próprio baseado na experiência e no conhecimento limitado de uma organização quando existem normas internacionais disponíveis.São estruturados - As normas internacionais de SI incorporam modelos estruturados que facilitam a compreensão e utilização das normas pelas organizações, permitindo assim que todas as partes interessadas nos SI (stakeholders) tenham uma referência em comum para saber o que podem esperar dos SI.Incorporam as melhores práticas - As normas estão em constante atualização, são construídas e melhoradas progressivamente ao longo dos anos, avaliadas por inúmeras organizações e profissionais de SI, validando esta experiência acumulada em melhores práticas.Permitem o compartilhamento de conhecimento - Adotando normas globalmente aceitas para os SI, as organizações se beneficiam do compartilhamento de conhecimento e de ideias (exemplos: grupos de usuários, websites, revistas, livros, etc.), o que não ocorre individualmente em uma organização.São auditáveis - A missão da Auditoria de SI é facilitada com a utilização de normas de Gestão de SI. Os Auditores de SI também devem utilizá-las em substituição das práticas ad-hoc de Auditoria. Os Sistemas de Informação da organização deverão ser auditados por comparação com pelo menos uma norma internacionalmente aceita, além das recomendações da norma adotada e de outras normas complementares. (Spafford, 2003)Para a correta adaptação das normas, deve-se garantir que elas incorporem, pelo menos, um conjunto mínimo de princípios de governança dos SI, que, segundo ITGI &amp; OGC (2005), passam por:Alinhamento Estratégico - Alinhar as normas com foco no negócio e em soluções colaborativas.Acréscimo de Valor - Acrescentar valor à organização através de normas centradas na redução de custos e na valorização dos SI.Gestão do Risco - Gerir os riscos com impacto nos SI (em uso ou ainda em projeto), através de normas que contemplam a salvaguarda dos ativos de SI, bem como a recuperação de desastres e a continuidade de negócio.Gestão dos Recursos - Gerir os recursos de SI através de normas que promovam a otimização do conhecimento (recursos humanos) e da infraestrutura (recursos físicos).Medição do Desempenho - Medir o desempenho dos SI através de normas que permitam controlar os projetos de SI e monitorar a prestação dos serviços de SI. (ITGI &amp; OGC, 2005)Constatados por meio destes princípios resumidos por ITGI &amp; OGC (2005), os referenciais de SI deverão garantir alinhamento com o negócio e com a Governança Corporativa (Corporate Governance), além dos requisitos técnicos considerados. A utilização de referenciais deverá permitir a definição das responsabilidades (accountability) e dos níveis de decisão (decision rights) para os SI.Para ilustrar uma possível utilização dos referenciais, LeBlanc (2004) sugere a utilização dos conceitos do método Six Sigma. Este é um método estatístico de melhoria da qualidade dos processos, desenvolvido pelo grupo Motorola, baseado numa visão de serviço ao cliente. O método prevê 5 principais fases: Definição (Define); Medição (Measure); Análise (Analyse); Melhoria (Improve); e Controle (Control). LeBlanc (2004) defende que “o referencial metodológico de SI mais adequado para as medidas de Segurança (Secure) é a ISO 17799, para a Auditoria (Audit) é o CobiT e para a Melhoria (Improve) é o ITIL”. Esses três referenciais metodológicos são apresentados/definidos individualmente nos temas seguintes.TEMA 3 – COBIT∙ Desde a criação, o CobiT tem foco na criação de um referencial para auditar os processos de SI. O ITIL teve origem não tão abrangente (a organização e a estruturação das áreas de SI), enquanto a ISO 17799 nasceu especializado apenas na segurança da informação.∙ A entidade responsável pela elaboração do CobiT é uma Associação de Auditores de SI (ISACA – Information Systems Audit and Control Association), o que não acontece com os outros dois referenciais.∙ O CobiT possui uma visão de gestão dos processos de SI e privilegia o alinhamento destes com o negócio, fatores importantes para a auditoria de SI. O ITIL também considera o alinhamento com o negócio, contudo, focado na qualidade dos serviços de SI, e possui uma visão mais operacional, fatores que o tornam mais adequado para auditoria de SI quando os objetos da auditoria forem serviços, e não processos de SI abrangentes. O ISO 17799 será o referencial mais adequado nos casos de auditoria à informação e à sua segurança nos SI, uma vez que possui uma visão sistêmica da informação.∙ O CobiT é útil para as organizações enquanto instrumento orientador e integrador de controles de SI em todos os níveis de governança dos SI e também será um referencial sobre o qual todos os tipos controles de SI poderão ser auditados. O ITIL poderá ser um referencial adequado para auditar os processos de gestão de serviços de SI e o ISO 17799 para auditar os procedimentos básicos de gestão da segurança da informação.∙ Como consequência, os destinatários privilegiados do CobiT são os auditores de SI, sendo também utilizado pelos gestores de topo e gestores de SI. Nos casos do ITIL e do ISO 17799, a utilização pelos auditores de SI deve ser favorecida apenas nas situações anteriormente indicadas, uma vez que estes dois referenciais são mais adequados para utilização pelos gestores de serviços de SI e pelos gestores da segurança da informação, respectivamente.Este modelo estruturado considera 5 tipos de recursos de SI (as pessoas, os aplicativos, a tecnologia, as instalações e os dados), que, em conjunto, possibilitam a produção e o suporte da informação da empresa, considerando 7 princípios essenciais (eficácia, eficiência, confidencialidade, integridade, disponibilidade, conformidade e confiabilidade).O referencial CobiT considera os controles de SI agrupados em 4 grandes domínios que trabalham em conjunto, de forma cíclica, para uma organização bem suportada em termos de SI, otimizada com base nas prioridades e nos recursos da organização. Os 4 domínios são:∙ Planejar e Organizar (PO – Plan and Organize);∙ Adquirir e Implementar (AI – Acquire and Implement);∙ Produzir e Suportar (DS – Deliver and Support);∙ Monitorar e Avaliar (M – Monitor and Evaluate).Cada um desses 4 domínios é constituído por um conjunto de processos de SI (34 no total) que correspondem a objetivos de controle de alto nível. Por sua vez, esses processos são constituídos por atividades de SI (318 no total) que correspondem a objetivos de controle detalhados.TEMA 4 – ITILITIL® (Information Technology Infrastructure Library) “é o framework para gerenciamento de serviços de TI mais adotado mundialmente. A utilização das melhores práticas contidas na ITIL V3 (versão atual) ajuda as organizações a atingirem seus objetivos de negócio utilizando apropriadamente os serviços TI”.A ITIL® foi desenvolvida no final dos anos 80 pelo governo britânico, primeiramente como CCTA (Central Computer and Telecommunications Agency) e posteriormente pela OGC (Office of Government Commerce), com base na necessidade do governo de ter seus processos organizados na área de TI. O resultado foi a junção dos melhores processos e práticas para ancorar a gestão dos serviços de TI. Foram levadas em conta as experiências acumuladas por organizações públicas e privadas de diversos países.O referencial ITIL toma como ponto de partida, não só a tecnologia existente, mas também as necessidades do negócio no nível de Serviços de SI. O ITIL centra-se fundamentalmente na Gestão dos Serviços de SI que tem como objetivos a produção (delivery) e o suporte (support) dos Serviços de SI que sejam adequados aos requisitos da organização.O ITIL é considerado por grande parte dos Gestores de SI como sendo um conjunto coerente de melhores práticas (guidelines) para a Gestão de Serviços de SI e para a totalidade dos processos com eles relacionados (end-to-end processes). Privilegia as seguintes abordagens:∙ promoção da qualidade dos Serviços de SI;∙ visão holística da Gestão dos Serviços de SI;∙ orientação para o negócio (cliente/usuário); e∙ uso eficaz/eficiente dos SI.Os 2 módulos centrais (core) do modelo estruturado e respectivos processos são:∙ Suporte aos Serviços (Service Support)✔ Gestão de Incidentes (Incident Management);✔ Gestão de Problemas (Problem Management);✔ Gestão de Configurações (Configuration Management);✔ Gestão de Alterações (Change Management);✔ Gestão de Versões (Release Management);✔ Apoio aos Serviços (Service Desk).∙ Produção dos Serviços (Service Delivery)✔ Gestão de Capacidade (Capacity Management);✔ Gestão de Disponibilidade (Availability Management);✔ Gestão de Níveis de Serviço (Service Level Management);✔ Gestão de Continuidade de Serviços (IT Service Continuity Management);✔ Gestão Financeira dos Serviços (Financial Management for IT Services).Os 5 módulos complementares do ITIL são mais latos, pois para além da Gestão dos Serviços de SI, abordam aspectos relacionados com a definição e o desenvolvimento de processos eficazes de SI. Os temas tratados pelos seus respectivos processos são os seguintes:∙ Gestão da Infraestrutura de TIC (ICT Infrastructure Management) - É muito abrangente em termos de processos de gestão das tecnologias (arquitetura e planejamento, produção, operação, suporte técnico, etc.).∙ Gestão de Aplicações (Application Management) - Inclui processos de desenvolvimento de software usando uma perspectiva de ciclo de vida de desenvolvimento, com foco na rigorosa definição dos requisitos aplicacionais em função das necessidades do negócio.∙ Gestão da Segurança (Security Management) - Aborda os processos de planeamento, de gestão e de resposta a incidentes relativos aos níveis de segurança da informação e das TIC.∙ Planejamento da Implementação da Gestão dos Serviços (Planning to Implement Service Management) - Prevê os processos essenciais no planeamento e na implementação da Gestão de Serviços de SI.∙ A Perspectiva de Negócio (The Business Perspective) - Aborda os processos de relacionamento e de comunicação da Gestão dos SI com o negócio, incluindo a restante organização e entidades externas. (Mundoitil, 2017)TEMA 5 – NORMA ISO 17799Conforme definido pela Associação Brasileira de Normas Técnicas (ABNT, 2005), os objetivos da normalização são:∙ Comunicação: proporcionar meios mais eficientes na troca de informação entre o fabricante e o cliente, melhorando a confiabilidade das relações comerciais e de serviços;∙ Segurança: proteger a vida humana e a saúde;∙ Proteção do consumidor: prover a sociedade de mecanismos eficazes para aferir qualidade dos produtos;∙ Eliminação de barreiras técnicas e comerciais: evitar a existência de regulamentos conflitantes sobre produtos e serviços em diferentes países, facilitando assim o intercâmbio comercial. (ABNT, 2005)No mesmo ano, foi também aprovada e publicada pela ISO a norma ISO 27002. No Brasil, a ABNT publicou a sua equivalente como norma brasileira NBR ISO IEC 17799:2005. A ISO/IEC 27001 é a norma usada para fins de certificação e substitui a norma Britânica BS 7799-2:2002.A norma brasileira NBR ISO/IEC 17799:2005 é um guia prático “que estabelece diretrizes e princípios gerais para iniciar, implementar, manter e melhorar a gestão de segurança da informação em uma organização”.Nesse sentido, a norma se subdivide em 16 capítulos: Introdução, Objetivo, Termos e Definições, Estrutura da Norma, Análise/avaliação e tratamento de Riscos, Política de Segurança da Informação, Organizando a Segurança da Informação, Gestão de Ativos, Segurança em Recursos Humanos, Segurança Física e do Ambiente, Gerenciamento das Operações e Comunicações, Controle de Acessos, Aquisição, desenvolvimento e manutenção de Sistemas de Informação, Gestão de Incidentes de Segurança da Informação, Gestão da Continuidade do Negócio e Conformidade 5.1 Evolução da Norma ISO/IEC 27002:20055.2 A Norma ABNT NBR ISO/IEC 27002Os títulos de cada seção, com suas respectivas recomendações, são aqui descritos (ABNT, 2005):∙ Política de Segurança da Informação: recomendações para a formalização de uma política. Contendo: diretrizes, princípios e regras que irão prover orientação e apoio para implantação e manutenção da segurança.∙ Organização da Segurança da Informação: recomendações para o estabelecimento de uma estrutura de gestão para planejar e controlar a implementação da segurança da informação na organização.∙ Gestão de Ativos: recomendações sobre a realização de inventário dos ativos informacionais e atribuição de responsabilidades pela manutenção dos controles necessários para protegê-los;∙ Segurança em Recursos Humanos: recomendações para reduzir os riscos de erro humano, roubo, fraude ou uso indevido das instalações;∙ Segurança Física e do Ambiente: recomendações para a proteção dos recursos e instalações de processamento de informações críticas ou sensíveis ao negócio contra acesso não autorizado, dano ou interferência;∙ Gestão das Operações e Comunicações: recomendações para garantir a operação correta e segura dos recursos de processamento de informações e proteger a integridade de serviços e informações;∙ Controle de Acesso: recomendações para a monitoração e o controle do acesso a recursos computacionais, para protegê-los contra abusos internos e ataques externos;∙ Aquisição, Desenvolvimento e Manutenção de SI: recomendações para o uso de controles de segurança em todas as etapas do ciclo de vida forçam que, com todos os esforços de TI, tudo seja implementado e mantido com a segurança em mente, usando controles de segurança em todas as etapas do processo;∙ Gestão de Incidentes da Segurança da Informação: recomendações para notificação de fragilidades e eventos de segurança da informação, responsabilidades e procedimentos e coleta de evidências.∙ Gestão da Continuidade do Negócio: recomendações para preparar a organização para neutralizar as interrupções às atividades comerciais e proteger os processos críticos em caso de ocorrência de falha ou desastre;∙ Conformidade: recomendações para a preservação da conformidade com requisitos legais (tais como direitos autorais e direito à privacidade), com normas e diretrizes internas e com os requisitos técnicos de segurança. (ABNT, 2005)5.3 Seções e controles da norma ABNT NBR ISO/IEC 27002:2005Tabela 3 – Seções e controles da norma ABNT NBR ISO/IEC 27002:2005 Política de Segurança da Informação5.1 Política de Segurança da InformaçãoObjetivo: prover uma orientação e apoio da direção para a segurança da informação de acordo com os requisitos do negócio e com as leis e regulamentações relevantes. Organização da Segurança da Informação6.1 Infraestrutura da Segurança da InformaçãoObjetivo: gerenciar a segurança de informação dentro da organização;6.2 Partes ExternasObjetivo: manter a segurança dos recursos de processamento da informação e da informação da organização, que são acessados, processados, comunicados ou gerenciados por partes externas. Gestão de Ativos7.1 Responsabilidade pelos ativosObjetivo: alcançar e manter a proteção adequada dos ativos da organização.7.2 Classificação da informaçãoObjetivo: assegurar que a informação receba um nível adequado de proteção. Segurança em Recursos Humanos8.1 Antes da contrataçãoObjetivo: assegurar que os funcionários, fornecedores e terceiros entendam suas responsabilidades e estejam de acordos com seus papéis e reduzir o risco de roubos, fraudes ou mau uso de recursos.8.2 Durante a contrataçãoObjetivo: assegurar que os funcionários, fornecedores e terceiros estão conscientes das ameaças e preocupações relativas à segurança da informação, de suas responsabilidades e obrigações, e estão preparados para apoiar a política de segurança da informação da organização durante os seus trabalhos normais, e para reduzir o risco de erro humano.8.3 Encerramento ou mudança da contrataçãoObjetivo: assegurar que os funcionários, fornecedores e terceiros deixem a organização ou mudem de trabalho de forma ordenada. Segurança Física e do Ambiente9.1 Áreas segurasObjetivo: prevenir o acesso físico não-autorizado, danos e interferências com as instalações e informações da organização.9.2 Segurança de equipamentosObjetivo: impedir perdas, danos, furto ou comprometimento de ativos e interrupções das atividades da organização. Gerenciamento das Operações e Comunicações10.1 Procedimentos e responsabilidades operacionaisObjetivo: garantir a operação segura e correta dos recursos de processamento da informação;10.2 Gerenciamento de serviços terceirizadosObjetivo: implementar e manter o nível apropriado de segurança da informação e entrega de serviços em consonância com acordos de entrega de serviços terceirizados.10.3 Planejamento e aceitação dos sistemasObjetivo: minimizar o risco de falhas nos sistemas.10.4 Proteção contra códigos maliciosos e códigos móveisObjetivo: proteger a integridade do software e da informação.10.5 Cópias de segurançaObjetivo: manter a integridade e disponibilidade da informação e dos recursos de processamento da informação.10.6 Gerenciamento da segurança em redesObjetivo: garantir a proteção das informações em redes e a proteção da infraestrutura de suporte.10.7 Manuseio de mídiasObjetivo: prevenir contra divulgação não autorizada, modificação, remoção ou destruição aos ativos, e interrupções das atividades do negócio.10.8 Troca de informaçõesObjetivo: manter a segurança na troca de informações e softwares internamente à organização e com quaisquer entidades externas.10.9 Serviços de comércio eletrônicoObjetivo: garantir a segurança de serviços de comércio eletrônico e sua utilização segura.10.10 MonitoramentoObjetivo: detectar atividades não autorizadas de processamento da informação. Controle de Acesso11.1 Requisitos de negócio para controle de acessoObjetivo: controlar acesso à informação11.2 Gerenciamento de acesso do usuárioObjetivo: assegurar acesso de usuário autorizado e prevenir acesso não autorizado a sistemas de informação11.3 Responsabilidade dos usuáriosObjetivo: prevenir o acesso não autorizado dos usuários e evitar o comprometimento ou furto da informação e dos recursos de processamento da informação.11.4 Controle de acesso à redeObjetivo: prevenir acesso não autorizado aos serviços da rede.11.5 Controle de acesso ao sistema operacionalObjetivo: prevenir acesso não autorizado aos sistemas operacionais11.6 Controle de acesso à aplicação e à informaçãoObjetivo: prevenir acesso não autorizado à informação contida nos sistemas de aplicação.11.7 Computação móvel e trabalho remotoObjetivo: garantir a segurança da informação quando se utilizam a computação móvel e recursos de trabalho remoto. Aquisição, Desenvolvimento e Manutenção de Sistemas de Informação12.1 Requisitos de segurança de sistemas de InformaçãoObjetivo: garantir que segurança é parte integrante de sistemas de informação.12.2 Processamento correto nas aplicaçõesObjetivo: prevenir a ocorrência de erros, perdas, modificação não autorizada ou mau uso de informações em aplicações.12.3 Controles criptográficosObjetivo: proteger a confidencialidade, a autenticidade ou a integridade das informações por meios criptográficos.12.4 Segurança dos arquivos do sistemaObjetivo: garantir a segurança de arquivos de sistema12.5 Segurança em processos de desenvolvimento e de suporteObjetivo: manter a segurança de sistemas aplicativos e da informação.12.6 Gestão de vulnerabilidades técnicasObjetivo: reduzir riscos resultantes da exploração de vulnerabilidades técnicas conhecidas. Gestão de Incidentes de Segurança da Informação13.1 Notificação de fragilidades e eventos de segurança da informação Objetivo: assegurar que um enfoque consistente e efetivo seja aplicado a gestão de incidentes da segurança da informação.13.2 Gestão de incidentes de segurança da informação e melhoriasObjetivo: assegurar que um enfoque consistente e efetivo seja aplicado à gestão de incidentes da segurança da informação. Gestão da Continuidade do Negócio14.1 Aspectos da gestão da continuidade do negócio, relativos à segurança da informaçãoObjetivo: não permitir a interrupção das atividades do negócio e proteger os processos críticos contra efeitos de falhas ou desastres significativos e assegurar a sua retomada em tempo hábil se for o caso. Conformidade15.1 Conformidade com requisitos legaisObjetivo: evita violação de qualquer lei criminal ou civil, estatutos, regulamentações ou obrigações contratuais e de quaisquer requisitos de segurança da informação.15.2 Conformidade com normas e políticas de segurança da informação e conformidade técnicaObjetivo: garantir a conformidade dos sistemas com as políticas e normas organizacionais de segurança da informação.15.3 Considerações quanto à auditoria de sistemas de informação Objetivo: maximizar a eficácia e minimizar a interferência no processo de auditoria dos sistemas de informação.AULA 6TEMA 1 – FERRAMENTAS DE AUDITORIAAs ferramentas de auditoria podem ser classificadas em:∙ Generalistas;∙ Especializadas;∙ De utilidade geral.TEMA 2 – FERRAMENTAS GENERALISTAS“softwares que podem processar, simular, analisar amostras, gerar dados estatísticos, sumarizar, apontar duplicidade e outras funções que o auditor desejar”.As vantagens do uso desse tipo de ferramenta são:∙ O software pode processar diversos arquivos ao mesmo tempo;∙ Pode processar vários tipos de arquivos em vários formatos;∙ Permite integração sistêmica com vários tipos de softwares e hardwares;∙ Reduz a dependência do auditor em relação ao especialista de informática.As desvantagens são:∙ Como o processamento das aplicações envolve gravação de dados em separado para serem analisados em ambientes distintos, poucas aplicações poderiam ser feitas em ambiente online;∙ Se o auditor precisar rodar cálculos complexos, o software não poderá dar esse apoio, pois tal sistema, para dar assistência generalista a todos os auditores, evita aprofundar as lógicas e matemáticas muito complexas.A seguir são apresentadas as principais ferramentas generalistas.2.1 Audit Command Language (ACL)Segundo Lyra e Imoniana, Audit Command Language (ACL) “é um software que auxilia auditores internos e externos na realização de testes em arquivos de dados. O sistema foi criado e é fornecido pela empresa canadense ACL”. ACL Services Ltda é uma empresa que oferece ferramentas para extração e análise de dados, detecção de fraudes e monitoração contínua.A ACL é uma das ferramentas mais modernas para extração de informações de banco de dados, tratamento e análise, visando detectar erros e riscos gerais do negócio associados a dados transacionais incompletos, imprecisos e inconsistentes.O diferencial em relação a softwares como Excel e Access é que a ACL pode trabalhar com grandes volumes de transações distribuídas em diversas operações e em sistemas diferentes.A ACL ajuda as organizações a reduzir riscos, detectar fraudes e minimizar as perdas, tirando proveito do seu investimento em conformidade para melhorar os resultados finais e otimizar o desempenho comercial.ACL permite analisar populações inteiras de dados, identificar tendências, exceções e destacar as áreas potenciais de preocupação, localizar erros e fraudes potenciais, identificar os problemas de controle e assegurar o cumprimento das normas de organização e regulação, analisar operações financeiras ou quaisquer outras operações sensíveis ao tempo e limpar e normalizar os dados para garantir consistência e resultados precisos. (ACL)2.2 Interactive Data Extraction &amp; Analisys (IDEA)Interactive Data Extraction &amp; Analisys (IDEA) é um “software para extração e análise de dados utilizado para controles internos e detecção de fraudes”O IDEA pode ler, exibir, analisar e manipular amostra ou extrato de arquivos de dados a partir de praticamente qualquer fonte – desde um mainframe até um PC, incluindo relatórios impressos em um arquivo.Dentre as vantagens, segundo IDEA, podem ser citadas:∙ Cria um registro de todas as alterações feitas em um arquivo (banco de dados) e mantém uma trilha de auditoria ou registro de todas as operações, incluindo a importação e todos os testes de auditoria, realizada na base de dados;∙ Cada entrada é identificada com o ID de usuário a partir do login do Windows;∙ Permite importar e exportar dados em uma variedade de formatos, incluindo formatos para computadores de grande porte e software de contabilidade;∙ Pode ler e processar milhões de discos em poucos segundos;∙ Não há limite para o número de registros que a IDEA pode processar;∙ Compara, junta, acrescenta, e conecta diferentes arquivos de diversas fontes.2.3 IDEA/AudimationAudimation “é uma versão americana do IDEA desenvolvida pela Caseware/Audimation Services, Inc, que presta serviço de consultoria e dá suporte ao software”.O Audimation ajuda profissionais de contabilidade e da área financeira a aumentar suas capacidades analíticas de auditoria, detectar fraudes e atender aos padrões de documentação. Permite importar rapidamente, juntar, analisar, a amostra e extrair dados de quase qualquer fonte, incluindo relatórios impressos em um arquivo.Essa ferramenta disponibiliza uma interface com o usuário projetada com assistentes para funções-chave. É baseado em características do padrão Windows, o que significa que não precisa ser um técnico especializado para obter resultados.2.4 GalileoGalileo é “um software integrado de gestão de auditoria. Inclui gestão de risco de auditoria, documentação e emissão de relatórios para auditoria interna”.Galileo afirma que essa ferramenta oferece uma metodologia baseada em auditoria completa dos riscos e cobre:∙ O planejamento estratégico anual, que garante orientação das áreas de alto risco, mantendo a cobertura;∙ Atividade de monitoramento e garantia de que problemas sejam identificados e atendidos com a maior brevidade;∙ Levantamentos de auditoria para obter um feedback sobre o processo de auditoria, indicadores de desempenho e gerenciamento de informações para todas as atividades realizadas pelo departamento.2.5 PentanaPentana é um software que permite a realização de planejamento de auditoria, planejamento e monitoramento de recursos, controle de horas, registro de check-lists, programas de auditoria, desenho e gerenciamento de plano de ação etc. E um software útil para governança, controle de riscos e adequação as leis.Pentana afirma que as principais características dessa ferramenta são:∙ Apresenta resultados em gráficos coloridos com alta resolução;∙ Produz relatórios sensíveis ao contexto e popula automaticamente documentos MS Office com base em relatórios de auditoria e formulários;∙ Gera relatórios em tempo real em todas as linhas de negócios;∙ Proporciona acesso simultâneo a todos os trabalhos de auditoria para revisão do auditor líder para que ele possa gerenciar e aprovar sem a necessidade de transferência do documento;∙ Possui conformidade com padrões internacionais de análise de riscos e auditoria; incluindo Sarbanes-Oxley, AS/NZS 4360, Basiléia II e COSO;∙ Substitui planilhas pesadas por um robusto e flexível sistema de banco de dados, escalável e facilmente acessível. (Pentana)TEMA 3 – FERRAMENTAS ESPECIALIZADASAs ferramentas especializadas de auditoria, segundo Lyra e Imoniana, são softwares desenvolvidos especialmente para executar certas tarefas em uma circunstância definida.A principal vantagem do uso desse tipo de ferramenta é que ela atende a demandas mais específicas, como crédito imobiliário, leasing, cartão de crédito e outras funções que exijam tarefas especializadas no segmento de mercado.As principais desvantagens dessas ferramentas são:∙ Pode ser muito caro, uma vez que seu uso será limitado ou restrito a apenas um cliente;∙ As atualizações deste software podem transformar-se em um problema.3.1 Regence – Sistema de Auditoria InternaO Regence – Sistema de Auditoria Interna automatiza o processo de auditoria interna da organização através das seguintes funcionalidades:∙ Cadastro do plano de auditoria, programas de trabalho, roteiros de teste;∙ Auditoria por processo, área, produto;∙ Levantamentos preliminares;∙ Evidências da auditoria;∙ Pontos de auditoria;∙ Controle de horas previstas e realizadas da auditoria;∙ Emissão do relatório de auditoria;∙ Acompanhamento de planos de ação;∙ Integração com o Regence – Sistema de Gestão de Riscos;∙ Integração com sistemas ERP;∙ Integração com o correio eletrônico;∙ Controle de acesso;∙ Workflow para aprovação de documentos;∙ Alerta sobre tarefas vencidas e a vencer;∙ Trilha de auditoria;∙ Emissão de relatórios e gráficos.3.2 Syrius OpAdvanced - Módulo de Auditoria InternaO sistema de auditoria interna integrado OpAdvanced, onde as organizações podem aproveitar as informações de controles internos, compliance e gestão de riscos para embasar os trabalhos realizados e reduzir significativamente a quantidade de horas dispensadas para realizar os mapeamentos necessários. (Syrius)Principais benefícios:∙ Planeje melhor as atividades e prazos de seus trabalhos de auditoria interna∙ Monitore os testes de auditoria com simplicidade e eficácia∙ Controle auditorias e apontamentos dos órgãos reguladores∙ Identifique superalocação de auditores internos em tempo de planejamento∙ Reaproveite as informações de controles internos, compliance e risco operacional∙ Armazene evidências de testes dos controles e o possibilite o rastreamento (Syrius)∙ Principais funcionalidades:∙ Planejamento da auditoria – O sistema OpAdvanced possibilita a criação de planos de auditoria identificados por tipos de trabalho, podendo organizar as auditorias por objetivos, além de oferecer total controle sobre prazos e execução de cada atividade.∙ Registro de pontos de auditoria – Os pontos de auditoria são registrados no sistema e vinculados ao trabalho da própria auditoria e poderão ser recuperados posteriormente para verificação do cumprimento.∙ Registro de recomendações - É possível, além dos pontos de auditoria, registrar recomendações necessárias para o aumento da segurança do sistema de controles da organização.∙ Importação de papéis de trabalho – Os papéis de trabalho podem ser anexados, relacionados e armazenados no sistema.∙ Testes de controles-chave – O sistema permite a criação de testes específicos para verificar a efetividade operacional de controles-chave de auditoria em linha com as definições do PCAOB para implantação da Sarbanes Oxley. Pode ser definido um plano de teste para cada controle estabelecendo critérios para obtenção de amostras, quantidades a serem testadas e procedimentos para execução dos testes.∙ Gerenciamento de plano de ação – O sistema permite a elaboração de um plano de ação detalhado para a regularização, relacionado a cada ponto de auditoria. Entre outras informações, é possível descrever a ação, qual será o prazo para conclusão e quem é responsável por cada atividade, possibilitando um gerenciamento efetivo do andamento da implantação, além de contar com o apoio de envio de alertas para auxiliar os envolvidos a não perderem os prazos. (Syrius)TEMA 4 – FERRAMENTAS DE UTILIDADE GERALOutros softwares, embora não específicos para a atividade de auditoria, também vêm sendo utilizados com esse propósito, sendo possível citar como exemplos as planilhas eletrônicas, como Excel, softwares de gerenciamento de banco de dados, como Access e MySQL, ferramentas de Business Intelligence, como Business Objects, softwares estatísticos etc. (Syrius)Segundo Lyra, Imoniana, as ferramentas de utilidade geral são softwares utilitários utilizados para executar algumas funções muito comuns de processamento, como sortear arquivos, sumarizar, concatenar, gerar relatórios etc. Esses programas não foram desenvolvidos para executar trabalhos de auditoria, portanto, não tem recursos tais como verificação de totais de controles, ou gravação das trilhas de auditoria.TEMA 5 – SOFTWARES DE CONTROLE DAS ATIVIDADES DE FUNCIONÁRIOSOs principais serviços oferecidos por esses softwares são:∙ Rastreamento e registro automático tanto de mudanças de localização como de configuração para dispositivos com alertas de mudanças, criando um rastro preciso;∙ Auditoria da máquina de usuários remotos através de qualquer conexão IP;∙ Banco de dados aberto compatível com ODBC que permite fácil exportação dos dados de auditoria para outras soluções complementares;∙ Criação de regras de notificação para quando o sistema de um computador com agente for alterado, tanto na parte de Hardware quanto de Software;∙ Acesso a relatórios que mostram o nível de acesso aos computadores, tais como horários de logins e logouts. (Teruel, 2010)5.1 Suíte Trauma Zer0Possui recursos para realizar descobrimento de software e tipos de arquivos, rastreamento de localização física de recursos, categorização de utilização de software, auditoria remota, comunicação e acesso seguros, bloqueio de aplicações e URL etc.Dentre os recursos dessa ferramenta destaca-se o que permite auditar a máquina de usuários remotos através de qualquer conexão IP (conexão remota à rede, VPN, internet discada, etc.).De forma imperceptível ao usuário, o Tz0 E-mail Sondas, um módulo do Suite Trauma Zer0, monitora todas as mensagens que circulam pela rede da empresa. Através de condições ligadas às ações, é possível filtrar, por exemplo: assuntos, textos, pessoas, e documentos referenciados no título, no corpo da mensagem, e até mesmo dentro de anexos, dentre diversos outros cenários.O Tz0 E-mail Sondas age integrado com o sistema operacional, permitindo que e-mails assinados e criptografados (com qualquer tecnologia) sejam monitorados como os demais, em um processo impossível de ser burlado. (iVirtua)5.2 MailDetectiveÉ uma ferramenta utilizada para o monitoramento do uso do correio eletrônico na organização. Ele analisa os registros de utilização (arquivos log) do servidor de correio eletrônico, fornecendo relatórios de utilização, mensagens enviadas e recebidas e volume de tráfego (inclusive por usuários e endereços de destinatários).O MailDetective permite controlar o percentual de e-mails pessoais e profissionais, identificar quem são os interlocutores dos funcionários, estimar o tráfego de e-mails gerado por cada usuário e criar relatórios para intervalos de tempo específicos.A HENIQ.NET também comercializa o WebSpy, uma solução que oferece “análises detalhadas, monitoramento e relatórios a respeito da utilização da internet e e-mail, individualmente, por departamentos ou toda organização.WebSpy oferece também soluções para captura de dados completos e alerta em tempo real”.5.3 mxHeroFuncionalidades do mxHero:∙ Acompanhamento do fluxo de mensagens enviadas e recebidas;∙ Gestão da proteção do e-mail: antispam, antivírus e antiphishing;∙ Controle do horário do uso do e-mail;∙ Compatível com qualquer sistema de e-mail;∙ Controle do envio de e-mail e anexos;∙ Acompanhamento do uso de e-mail em tempo real;∙ Rastreamento de abertura de anexos.5.4 MailMarshal Exchange e IQ.Suite for DominoO MailMarshal Exchange é uma solução comercializada pela Gaia Informática, que monitora e controla a troca de mensagens interna de corporações que utilizam o Microsoft Exchange 2003/2000, auxiliando na garantia de um ambiente de trabalho seguro e produtivo, na implementação de Políticas de Uso Aceitável (AUP), e na proteção contra spams e vírus. (Gaia)A Gaia comercializa também o IQ.Suite for Domino, uma solução que disponibiliza a funcionalidade de segurança e gerenciamento para uma implementação de estratégias de ciclo de vida de e-mails. Desde criptografia, proteção contra vírus, e filtro de conteúdo, até classificação e armazenamento, os e-mails são submetidos a todos estes processos em uma única plataforma, sem alterar o seu ciclo de vida. (Gaia)Outra solução comercializada pela Gaia Informática é o WebMarshal, um software para controlar o acesso dos funcionários à internet: combinando filtro de URL, antivírus, antispyware, controle de conteúdo e gerenciamento de produtividade em uma única solução, de fácil gerenciamento.De acordo com Gaia, WebMarshal permite controlar o acesso dos funcionários a conteúdo inapropriado, gerenciar o uso pessoal da internet por parte dos funcionários e proteger a organização contra vírus, spyware e outras formas de código malicioso." }, { "title": "Java Insider", "url": "/posts/java-insider/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-11-26 09:00:00 -0300", "snippet": " Do webinar da SoftblueInside the Stack &amp; Heap A Stack e o Heap são áreas alocadas de memória RAMPassagem de Parâmetro No Java, a passagem de parâmetros é sempre feita por cópia!– Nunca por referência– O conteúdo é sempre copiadoGarbage Collector (Coletor de Lixo) Serviço da JVM A JVM decide quando ele vai executar Libera a área de memória do Heap que não é mais acessível Inside the String PoolStrings Armazenam conjuntos de caracteres String é uma classe – Objetos String são armazenados no HeapString s = new String(“java”);//Praticamente não se usaString s = “java”;//Esta sintaxe só existe em Strings! Pool (Área do Heap)A Imutabilidade das Strings Strings no pool são compartilhadas E se a String mudasse? Confusão total! Solução: – Strings são imutáveis!– A classe String é definida como final Para mudar uma String, só criando outra Para evitar a criação desnecessária de Strings (e sobrecarregar o GC), uma alternativa é usar a classe StringBuilder Inside the Collections APIListasInterface ListElementos ordenadosPermitem elementos duplicadosPodem aumentar ou diminuir sob demandaArrayListUsa um array pra armazenar os elementosNovos arrays são criados para acomodar novos elementos Inserção– Insere rapidamente na posição corrente do array– Se for preciso redimensionar o array, demora um pouco mais– Para inserção que não seja no final, é preciso mexer na estrutura do array Exclusão– Todos os elementos são movidos para a esquerda para não deixar“buraco” no array Busca– A busca por índice é rápida, pois vai direto na posição do array– Na busca por objeto, é preciso iterar sobre cada elementoLinkedListUsa uma lista duplamente encadeada para armazenar os elementos Inserção– A inserção é rápida e pode ser feita no começo, no fim ou no meio da lista com a mesma performance– Implica na correção das referências de elementos vizinhos, feita rapidamente Exclusão– Implica na correção das referências de elementos vizinhos, feita rapidamente Busca– Tanto na busca por índice como na busca pelo objeto é preciso iterar sobre cada um dos elementos da listaVector Foi substituído pelo ArrayList O problema do Vector são suas operações sincronizadas (synchronized) – Diminui a performance da coleção Se você deseja usar uma coleção com operações sincronizadas, use os métodos synchronized*() da classe CollectionsConjuntosInterface SetConjuntos como na matemáticaNão permitem elementos duplicadosA ordem dos elementos pode não ser a mesma da inserçãoHashSetOs elementos são organizados na memória usando um algoritmo de hashing (espalhamento) Inserção– É feito o cálculo do hash do elemento, que é adicionado no local correto dentro da tabela hash Exclusão– É eficiente, pois a busca é feita rapidamente na tabela hash Busca– A busca feita por objeto é muito eficiente, pois o conhecimento do local na tabela hash onde o elemento está concentra a buscaMétodos equals() e hashCode()O algoritmo de hashing deve retornar valores bem distribuídoshashCode() - Encontra o índiceequals() - Encontra o elemento dentro do índiceLinkedHashSet Funcionamento semelhante ao do HashSet A diferença é que o LinkedHashSet usa uma lista duplamente encadeada para guardar a ordem de inserção – Isso garante que a ordem de iteração será a mesma de inserçãoTreeSet Funcionamento semelhante ao do HashSet A diferença é que o TreeSet classifica os elementos na hora da inserção Ao iterar sobre os elementos, a ordem será a ordem de classificação Existe um passo a mais na inserção, que é a execução do algoritmo de ordenação Red/Black Tree (árvore rubro-negra) Comparator e Comparable - Interfaces usadas para determinar o critério de ordenação em elementos de coleçõesColeções com “Hash” no nome: usam equals() e hashCode()Coleções com “Tree” no nome: usam as interfaces Comparable ou ComparatorMapasInterface MapMapeamento de uma chave a um valorChaves e valores podem ser de qualquer tipoExiste uma equivalência com as implementações dos conjuntosAs regras das implementações de conjuntos são aplicadas nas chaves do mapaHashMap -&gt; HashSetLinkedHashMap -&gt; LinkedHashSetTreeMap -&gt; TreeSetAs implementações dos conjuntos usam as implementações dos mapas no código!Hashtable Foi substituída pelo HashMap O problema da Hashtable são suas operações sincronizadas (synchronized) – Diminui a performance da coleção Se você deseja usar uma coleção com operações sincronizadas, use os métodos synchronized*() da classe Collections" }, { "title": "Taglibs Customizadas", "url": "/posts/taglibs-customizadas/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-11-19 09:00:00 -0300", "snippet": "Criando Taglibs• É possível que o desenvolvedor crie suas próprias taglibs– Melhorar produtividade do desenvolvimento– Código mais fácil de entender a manter• Taglibs podem ser criadas de duas maneiras– Tag files– Tag handlersTag Files• Fragmentos de arquivos JSP• Possuem a extensão .tag• Estão localizados no diretório WEB-INF/tagsimage.tag&lt;CENTER&gt;&lt;IMG src=\"java.png\"&gt;&lt;BR&gt;&lt;/CENTER&gt;Este tag file adiciona uma imagem centralizada na páginaUsando um Tag Fileexemplo.jsp&lt;%@ taglib prefix=\"t\" tagdir=\"/WEB-INF/tags\" %&gt;&lt;html&gt;&lt;body&gt;&lt;t:image /&gt;&lt;!--O image referencia o nome do tag file (image.tag)--&gt;&lt;/body&gt;&lt;/html&gt;Passando Atributos para Tag Filesimage.tag&lt;%@ attribute name=\"imgName\"required=\"true\"rtexprvalue=\"true\"%&gt;&lt;!--A diretiva attribute define os atributos da tag--&gt;&lt;CENTER&gt;&lt;IMG src=\"${imgName}\"&gt;&lt;!--imgName é substituído pelo atributo passado--&gt;&lt;CENTER&gt;exemplo.jsp&lt;%@ taglib prefix=\"t\" tagdir=\"/WEB-INF/tags\" %&gt;&lt;html&gt;&lt;body&gt;&lt;t:image imgName=\"java.png\" /&gt;&lt;!--Passagem de atributo--&gt;&lt;/body&gt;&lt;/html&gt;Informações no Corpo das Tagsimage.tag&lt;%@ attribute name=\"imgName\"required=\"true\"rtexprvalue=\"true\"%&gt;&lt;CENTER&gt;&lt;IMG src=\"${imgName}\"&gt;&lt;BR&gt;&lt;jsp:doBody /&gt;&lt;!--Imprime o corpo da tag sendo chamada--&gt;&lt;CENTER&gt;exemplo.jsp&lt;%@ taglib prefix=\"t\" tagdir=\"/WEB-INF/tags\" %&gt;&lt;html&gt;&lt;body&gt;&lt;t:image imgName=\"java.png\"&gt;Logotipo do Java&lt;!--Corpo da tag--&gt;&lt;/image&gt;&lt;/body&gt;&lt;/html&gt;Tag Handlers• Tag files são interessantes quando não há necessidade de envolver código Java• Nestes casos, é melhor usar um tag handler• O Tag Handler é uma classe Java que representa uma taglib• A classe estende SimpleTagSupport e sobrescreve o método doTag()Criando um Tag Handlerpublic class DateTag extends SimpleTagSupport { private String pattern; public void doTag() throws JspException, IOException { Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(pattern); getJspContext().getOut().print(sdf.format(d));//Envio do dado para a response } public void setPattern(String pattern) { this.pattern = pattern;//Setter invocado pelo container }}Configurando o Tag Handler• A configuração é feita em um arquivo .tld (tag library descriptor), dentro de WEB-INFmytags.tld&lt;taglib&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;MyCustomTags&lt;/short-name&gt; &lt;uri&gt;myTags&lt;/uri&gt; &lt;tag&gt; &lt;description&gt;Formata uma data&lt;/description&gt; &lt;name&gt;date&lt;/name&gt; &lt;tag-class&gt;tag.DateTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;pattern&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt;Usando o Tag Handlerexemplo.jsp&lt;%@ taglib prefix=\"t\" uri=\"myTags\" %&gt;&lt;!--Referencia a URI do arquivo mytags.tld--&gt;&lt;html&gt;&lt;body&gt;&lt;t:date pattern=\"dd/MM/yyyy\" /&gt;&lt;!--O container chama o método setPattern() no handler--&gt;&lt;/body&gt;&lt;/html&gt;Tag Handler e o Corpo da Tagpublic class MyTag extends SimpleTagSupport { public void doTag() throws JspException, IOException { getJspContext().invoke(null);//Imprime o conteúdo do corpo da tag na response //É possível passar um Writer como parâmetro }}Mais Sobre Configurações• Atributo das tags: rtexprvalue Valor Significado true Strings literais e outras expressões (como EL e scriptlets) são aceitas como valor para o atributo false Apenas strings literais são aceitas como valor para o atributo • Atributo do corpo das tags: body-content Valor Significado empty A tag não pode ter corpo scriptless O corpo da tag não pode conter scriptlets (mas aceita expressões EL) tagdependent O corpo da tag é interpretado como texto " }, { "title": "Estruturando uma Aplicação Web", "url": "/posts/estruturando-aplicacao-web/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-11-12 09:00:00 -0300", "snippet": "O Modelo MVC Model – View – Controller. Permite a divisão da aplicação em camadas lógicas. Esta divisão facilita a manutenção e extensão futura do código. graph TD A[fa:fa-desktop] --&gt; B(Controller) B --&gt; C(Model) C --&gt; B B --&gt; D(View) D --&gt; AController• É o componente chamado pelo cliente• O controller executa os seguintes passos: Prepara os dados que serão usados pelo model Chama o model Prepara os dados que serão usados pela view Direciona para a view View• É o resultado visual observado pelo cliente• O direcionamento para uma determinada view é responsabilidade do controller• Os dados presentes na view normalmente são renderizados com base em dados obtidos pelo modelModel• É onde está toda a lógica de negócio implementada pela aplicação• O model compreende implementação da lógica, acesso a bancos de dados, acesso a sistemas externos, etc.• O model não deve ter qualquer dependência com a tecnologia usada pelos controllers ou views– Esta independência garante que o mesmo model pode ser usado para qualquer tipo de aplicação (web, desktop, dispositivos móveis, etc.)O MVC e as Aplicações Web• O MVC pode ser aplicado para desenvolver qualquer tipo de aplicação• Quando a aplicação é web, o MVC se encaixa perfeitamente– O modo de funcionamento proposto pelo MVC e das aplicações web é muito similargraph TD subgraph A[fa:fa-desktop] --&gt; B(Controller) B --&gt; A B --&gt; C(Model) B --&gt; D(View) end B --- E[Servlet] D ---F[JSP]O Servlet Como Controller• No modelo MVC, os servlets fazem o papel dos controllers• Uma boa opção é criar apenas um servlet na aplicação que intercepta todas as requisições• O servlet, dependendo do que é requisitado, delega a operação para outras classesgraph LR A[fa:fa-desktop] --&gt; B subgraph Controller B(ControllerServlet) B --&gt; C(PagamentoAction) B --&gt; D(CadastroAction) B --&gt; E(LoginAction) end B --- F[Front Controller] C &amp; D &amp; E --- G[Command Pattern]Estruturando a Camada Model• O model é, sem dúvida, a camada mais importante da sua aplicação• Nela está localizada a lógica de todo o funcionamento da aplicação• É preciso que o model seja bem organizado para que o código seja de fácil manutenção e de fácil extensãoDefinição das Entidades• As entidades (entities) são classes que representam os conceitos presentes na aplicação• Na prática elas normalmente são mapeadas para tabelas do banco de dadosAcesso a Dados• Praticamente todas as aplicações comerciais possuem um meio de acessar e armazenar dados– Banco de dados– Sistemas externos– Arquivos• É importante criar um conjunto de classes que encapsulem o acesso aos dados– Centraliza o acesso aos dados– Permite mudar o mecanismo de persistência sem afetar outras partes do código DAO Pattern (Data Access Object)Definição dos Objetos de Negócio• Os objetos de negócio (business objects) realizam tarefas específicas de negóciograph LR A((Controller)) --&gt; B(PagamentoService) B --&gt; C(CartaoCreditoService) B --&gt; D(PagamentoDAO) B --&gt; E(ClienteDAO) B --&gt; F(LogService)O Model é uma Composição: Entity + Business Object + DAOFrameworks MVC• Frameworks MVC tornam mais produtivo o desenvolvimento de aplicações web• Trazem facilidades como suporte à validação de dados, tradução de dados vindos pelo HTTP, etc.• Normalmente o framework faz o papel do controller• Traz facilidades para trabalhar com as views– Taglibs• Exemplo de frameworks MVC no Java– Struts• http://struts.apache.org– Spring• http://www.springsource.org" }, { "title": "Introdução ao Hibernate", "url": "/posts/introducao-hibernate/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-11-05 09:00:00 -0300", "snippet": "Desvantagens do JDBC• JDBC permite a integração entre aplicações Java e banco de dados– A forma de uso é a mesma para todos os bancos de dados• JDBC expõe a linguagem SQL ao programador– SQL nem sempre é padronizado– Às vezes, as queries são complexas de montarFrameworks ORM• Em aplicações orientadas a objetos, normalmente são criadas classes para representar conceitos existentes na aplicação• Estas classes são, no final das contas, mapeadas para tabelas do banco de dados, com o objetivo de persistir os dados• Os frameworks do tipo Object-Relational-Mapping facilitam este mapeamentoHibernate• O Hibernate é um framework ORM• Gratuito e open source• Site oficial– http://www.hibernate.org• Pode ser utilizado em aplicações standalone e aplicações webEntidades• Entidades são classes Java que serão mapeadas para tabelas no banco de dados• As entidades são classes POJO– Devem ter uma ou mais propriedades que serão utilizadas como chave na tabela– Atributos e métodos getters e setters• O Hibernate consegue mapear atributos sem getters e/ou setters definidos, mas utilizá-los é mais adequado– Presença de um construtor sem argumentospublic class Produto {//A classe não precisa estender nenhuma classe ou implementar interfaces private Long id;//Os atributos serão mapeados mais tarde para tabelas private String nome; private Double valor; private void setId(Long id) {//O método setId() pode ser privado, pois o Hibernate gerará o ID this.id = id; } public Long getId() { return this.id; } //Outros getters e setters} Mapeamento dos Atributos&lt;hibernate-mapping&gt; &lt;class name=\"Produto\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;property name=\"nome\" /&gt; &lt;property name=\"valor\" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;Configurando o Hibernate• Para que o Hibernate funcione adequadamente, ele deve ser configurado– Os JARs necessários devem ser colocados no classpath– Criação dos arquivos .hbm.xml– Criação do arquivo hibernate.cfg.xml• Define como o Hibernate será integrado com o banco de dados da aplicaçãoO Arquivo hibernate.cfg.xml&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"connection.driver_class\"&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;property name=\"connection.url\"&gt; jdbc:mysql://localhost/db &lt;/property&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.password\"&gt;admin&lt;/property&gt; &lt;property name=\"dialect\"&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;mapping resource=\"db/Produto.hbm.xml\" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;SessionFactory• A SessionFactory é responsável por criar os objetos SessionConfiguration cfg = new Configuration().configure();ServiceRegistry sr = new ServiceRegistryBuilder(). applySettings(cfg.getProperties()).buildServiceRegstry();SessionFactory factory = cfg.buildSessionFactory(sr);• O ideal é usar apenas um objeto SessionFactory para toda a sua aplicaçãoSession• A Session é utilizada para executar operações, que serão refletidas no banco de dadosSession session = factory.getCurrentSession();session.beginTransaction();Produto p = new Produto();p.setNome(\"XPTO\");p.setValor(100.0);session.save(p);session.getTransaction().commit();• A session pode ser utilizada para executar mais de uma operaçãoOperações da Session: Operação Descrição save() Cria a entidade no banco de dados update() Atualiza uma entidade existente no banco de dados. delete() Exclui uma entidade do banco de dados. load() Carrega uma entidade no banco de dados através do seu ID. createQuery() Cria um objeto Query a partir de uma expressão HQL, que possibilita executar queries no banco de dados. Associações• O Hibernate gerencia também as associações entre entidades, escondendo a linguagem SQL usada no processo• Tipos de associação– Many-to-One (Muitos-para-Um)– One-to-Many (Um-para-Muitos)– One-to-One (Um-para-Um)– Many-to-Many (Muitos-para-Muitos)• Associações podem ser unidirecionais ou bidirecionaisAssociação Many-to-One• Unidirecional&lt;class name=\"Cliente\"&gt; ... &lt;many-to-one name=\"endereco\" column=\"endereco_id\" /&gt;&lt;/class&gt;&lt;class name=\"Endereco\"&gt; ...&lt;/class&gt;• Bidirecional&lt;class name=\"Cliente\"&gt; ... &lt;many-to-one name=\"endereco\" column=\"endereco_id\" /&gt;&lt;/class&gt;&lt;class name=\"Endereco\"&gt; ... &lt;set name=\"clientes\" inverse=\"true\"&gt; &lt;key column=\"endereco_id\"/&gt; &lt;one-to-many class=\"Cliente\"/&gt; &lt;/set&gt;&lt;/class&gt;Associação One-to-Many• Unidirecional&lt;class name=\"Endereco\"&gt; ... &lt;set name=\"clientes\" inverse=\"true\"&gt; &lt;key column=\"endereco_id\"/&gt; &lt;one-to-many class=\"Cliente\"/&gt; &lt;/set&gt;&lt;/class&gt;&lt;class name=\"Cliente\"&gt; ...&lt;/class&gt;• Bidirecional&lt;class name=\"Endereco\"&gt; ... &lt;set name=\"clientes\" inverse=\"true\"&gt; &lt;key column=\"endereco_id\"/&gt; &lt;one-to-many class=\"Cliente\"/&gt; &lt;/set&gt;&lt;/class&gt;&lt;class name=\"Cliente\"&gt; ... &lt;many-to-one name=\"endereco\" column=\"endereco_id\" /&gt;&lt;/class&gt;Associação One-to-One• Unidirecional&lt;class name=\"Cliente\"&gt; &lt;id name=\"id\" column=\"id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt;&lt;/class&gt;&lt;class name=\"CartaoFidelidade\"&gt; &lt;id name=\"id\" column=\"cliente_id\"&gt; &lt;generator class=\"foreign\"&gt; &lt;param name=\"property\"&gt;cliente&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;one-to-one name=\"cliente\" constrained=\"true\" /&gt;&lt;/class&gt;• Bidirecional&lt;class name=\"Cliente\"&gt; &lt;id name=\"id\" column=\"id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;one-to-one name=\"cartao\" /&gt;&lt;/class&gt;&lt;class name=\"CartaoFidelidade\"&gt; &lt;id name=\"id\" column=\"cliente_id\"&gt; &lt;generator class=\"foreign\"&gt; &lt;param name=\"property\"&gt;cliente&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;one-to-one name=\"cliente\" constrained=\"true\" /&gt;&lt;/class&gt;Associação Many-to-Many• Unidirecional&lt;class name=\"Cliente\"&gt; ... &lt;set name=\"produtos\" table=\"produto_cliente\"&gt; &lt;key column=\"cliente_id\" /&gt; &lt;many-to-many column=\"produto_id\" class=\"Produto\" /&gt; &lt;/set&gt;&lt;/class&gt;&lt;class name=\"Pedido\"&gt; ...&lt;/class&gt; • Bidirecional&lt;class name=\"Cliente\"&gt; ... &lt;set name=\"produtos\" table=\"produto_cliente\"&gt; &lt;key column=\"cliente_id\" /&gt; &lt;many-to-many column=\"produto_id\" class=\"Produto\" /&gt; &lt;/set&gt;&lt;/class&gt;&lt;class name=\"Pedido\"&gt; ... &lt;set name=\"clientes\" inverse=\"true\" table=\"produto_cliente\"&gt; &lt;key column=\"produto_id\" /&gt; &lt;many-to-many column=\"cliente_id\" class=\"Cliente\" /&gt; &lt;/set&gt;&lt;/class&gt; HQL• Hibernate Query Language• Linguagem similar ao SQL• A HQL usa os conceitos de orientação a objetosQuery q = session.createQuery(\"from Cliente\");List result = q.list();Cláusulas from e as• from– Seleciona o tipo da entidade a ser retornada• as– alias para a entidadefrom Clientefrom Cliente as cRetorno: ListCláusula select• Filtra os resultados, trazendo apenas os dados desejados das entidadesselect c from Cliente as cRetorno: Listselect c.nome, c.idade from Cliente as cRetorno: List&lt;Object[]&gt;Associações• HQL é capaz de associar entidades automaticamenteselect c.endereco from Cliente as cRetorno: Listselect c.endereco.rua from Cliente as cRetorno: ListJoins• HQL permite fazer joins entre entidadesselect c from Pedido as p inner join p.cliente as cRetorno: List• Tipos de joins suportados– inner join– left outer join– right outer joinCláusula where• Estipula condições sobre os dados que devem ser selecionados pela queryfrom Cliente as c where c.idade &gt; 18Apenas clientes cuja idade é maior que 18 anosselect p from Pedido as p inner join p.cliente c where c.nome like '%José%'Apenas pedidos cujo nome do cliente tem ‘José’ no meiofrom Cliente as c where c.endereco is not nullApenas clientes que possuem endereçoselect p from Pedido as p where p.cliente.endereco.estado = 'SP'Apenas pedidos cujo estado do cliente que fez o pedido é ‘SP’Funções de Agregação• A HQL suporta algumas funções de agregação Função Descrição count Conta registros min Valor mínimo max Valor máximo sum Soma de valores avg Média de valores select sum(p.valor) from Produto pRetorna a soma dos valores de todos os produtosConsiderações sobre a HQL• Permite escrever queries de forma orientada a objetos, sem pensar em termos de bancos de dados• A HQL é bastante extensa, e o que foi visto aqui cobre o básico, que é o mais utilizado• Para maiores informações, consulte a documentação do Hibernate" }, { "title": "JavaBeans, EL e JSTL", "url": "/posts/javabeans-el-jstl/", "categories": "Estudos-faculdade", "tags": "java, web", "date": "2021-10-29 09:00:00 -0300", "snippet": "Evite o Uso de Código Java em JSP• Apesar de JSPs terem sido criados para possibilitarem a mistura de HTML e código Java, escrever código Java em JSPs não é uma boa prática– Dificulta o trabalho de web designers, que não são programadores– Para páginas complexas, o código fica confuso– Dificuldade de manutençãoAlternativas aos Scriptlets• JavaBeans• EL (Expression Language)• JSTL (Java Server Pages Standard Tag Library)JavaBeans• É uma especificação Java que define um padrão de classe• Uma classe é um JavaBean se:– Possui um construtor público sem argumentos– Possui métodos getters e/ou setters definidos corretamenteAssinatura dos Getters e Setters• A assinatura dos getters e setters segue um padrão Atributo Getter Setter numConta getNumConta() setNumConta() saldo getSaldo() setSaldo() ativo isAtivo() setAtivo() Para atributos booleanos, o padrão do getter é isXXX(), mas getXXX() também pode ser utilizadoLendo as Propriedades do BeanServlet...ContaBancaria c = new ContaBancaria();c.setNumConta(\"3245-3\");c.setSaldo(500.0);c.setAtivo(true);request.setAttribute(\"conta\", c);...JSP&lt;jsp:useBean id=\"conta\" class=\"model.ContaBancaria\" scope=\"request\" /&gt;&lt;html&gt;&lt;body&gt;Núm. Conta: &lt;jsp:getProperty name=\"conta\" property=\"numConta\" /&gt;&lt;BR&gt;Saldo: &lt;jsp:getProperty name=\"conta\" property=\"saldo\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;jsp:useBean id=\"conta\" class=\"model.ContaBancaria\" scope=\"request\"/&gt;id: Nome pelo qual o bean será referenciado. Equivale ao nome do atributo.class: Fully qualified name da classe do bean instanciada na memória.scope: Escopo de onde o bean é carregado. O default é page.Se o bean não existir, o &lt;jsp:useBean&gt; cria um novo bean&lt;jsp:getProperty name=\"conta\" property=\"numConta\" /&gt;name: Nome do bean, definido pelo id em &lt;jsp:useBean&gt;.property: Nome da propriedade para leitura. Será chamado o método getter correspondente (getNumConta()).Alterando as Propriedades do Bean• Além de ler as propriedades de um JavaBean, é possível também alterá-lasJSP&lt;jsp:useBean id=\"conta\" class=\"model.ContaBancaria\" scope=\"request\" /&gt;&lt;jsp:setProperty name=\"conta\" property=\"numConta\" value=\"0000-0\" /&gt;&lt;html&gt;&lt;body&gt;Núm. Conta: &lt;jsp:getProperty name=\"conta\" property=\"numConta\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;jsp:setProperty name=\"conta\" property=\"numConta\" value=\"0000-0\" /&gt;name: Nome do bean, definido pelo id em &lt;jsp:useBean&gt;.property: Nome da propriedade que será alterada. Será chamado o método setter correspondente (setNumConta())value: Novo valor para a propriedade do bean.• É possível definir um &lt;jsp:setProperty&gt; dentro da tag &lt;jsp:useBean&gt;– Neste caso as propriedades só serão alteradas se o bean estiver sendo criado pelo &lt;jsp:useBean&gt;&lt;jsp:useBean id=\"conta\" class=\"model.ContaBancaria\" scope=\"request\"&gt; &lt;jsp:setProperty name=\"conta\" property=\"numConta\" value=\"0000-0\" /&gt;&lt;!--O &lt;jsp:setProperty&gt; será ignorado caso o bean já exista na request--&gt;&lt;/jsp:useBean&gt;• A tag &lt;jsp:setProperty&gt; também pode ser usada para alterar propriedades de um bean de acordo com informações vindas da request&lt;form action=\"conta.jsp\"&gt;Núm Conta: &lt;INPUT type=\"text\" name=\"numConta\"&gt;&lt;BR&gt;Saldo: &lt;INPUT type=\"text\" name=\"saldo\"&gt;&lt;BR&gt;&lt;INPUT type=\"submit\" value=\"Processar\"&gt;&lt;/form&gt;conta.jsp&lt;jsp:useBean id=\"conta\" class=\"model.ContaBancaria\" scope=\"request\" /&gt;&lt;jsp:setProperty name=\"conta\" property=\"numConta\" /&gt;&lt;jsp:setProperty name=\"conta\" property=\"saldo\" /&gt;&lt;html&gt;&lt;body&gt;Núm. Conta: &lt;jsp:getProperty name=\"conta\" property=\"numConta\" /&gt;&lt;BR&gt;Saldo: &lt;jsp:getProperty name=\"conta\" property=\"saldo\" /&gt;&lt;/body&gt;&lt;/html&gt;Se value não for definido, os parâmetros da request são pesquisados• É possível buscar todos os parâmetros da request que possuem os nomes iguais às propriedades do bean&lt;jsp:setProperty name=\"conta\" property=\"*\" /&gt;• Se o parâmetro da request e a propriedade do bean tiverem nomes diferentes, é possível usar param&lt;jsp:setProperty name=\"conta\" property=\"numConta\" param=\"nc\" /&gt;Expression Language• EL permite ainda mais facilidade na hora de ler informações presentes em um escopoServletrequest.setAttribute(\"user\", \"Carlos\");JSP${user}O resultado é “Carlos”EL e JavaBeans• Ler propriedades de JavaBeans é muito mais fácil usando ELServletContaBancaria conta = new ContaBancaria();conta.setNumConta(\"1234-5\");conta.setSaldo(400.0);request.setAttribute(\"c\", conta);JSP${c.numConta}${c.saldo}O resultado é “1234-5” e “400.0”• Além do operador “.”, existe o operador “[]”${c.numConta} = ${c[\"numConta\"]}Operador “[]” e Coleções de Dados• O operador “[]” pode ser usado na presença de coleções de dadosc é um java.util.List OU c é um array${c[1]}${c[\"1\"]}Retorna a segunda posição da lista/arrayc é um java.util.Map${c[\"Carlos\"]}${c.Carlos}Retorna o valor do mapa cuja chave é “Carlos”Limitações do Operador “.”• O operador “.” só pode ser utilizado se o que estiver escrito do lado direito do operador for um identificador válido do Java• Suponha que c é um java.util.Map:${c.1}//Esta notação não funciona, pois \"1\" não é um identificador válido${c[1]}//Esta notação funciona${c[\"1\"]} Objetos Implícitos Objeto Descrição pageScope Map com os atributos do escopo page requestScope Map com os atributos do escopo request sessionScope Map com os atributos do escopo session applicationScope Map com os atributos do escopo application param Map com os parâmetros da request paramValues Map com os parâmetros da request header Map com o request HTTP header headerValues Map com o request HTTP header cookie Map com os cookies initParam Map com os context init parameters pageContext Referencia o objeto pageContext JSTL• JSTL é um conjunto de tag libraries que complementa as facilidades providas pela EL– As tag libraries definem ações– Substituem códigos Java nos arquivos JSP• JSTL é bastante extensa– Core library– SQL library– Formatting library– XML libraryConfigurando o JSTL• Para usar o JSTL na sua aplicação, são necessários dois arquivos JAR no classpath– jstl-api-XX.jar– jstl-impl-XX.jar• Os arquivos podem ser encontrados na página do projeto do JSTL– http://jstl.java.net• É necessário referenciar a URI do JSTL para que você possa usar as taglibs&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;• Permite executar um loop em uma lista de elementosServletList&lt;String&gt; lista = new ArrayList&lt;String&gt;();lista.add(\"laranja\");lista.add(\"leite\");lista.add(\"margarina\");request.setAttribute(\"listaCompras\", lista);JSP&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;table border=\"1\"&gt;&lt;c:forEach var=\"item\" items=\"${listaCompras}\"&gt; &lt;tr&gt;&lt;td&gt;${item}&lt;/td&gt;&lt;/tr&gt;&lt;!--A variável só existe dentro da tag--&gt;&lt;/c:forEach&gt;&lt;/table&gt;• Permite testar uma determinada condiçãoServletrequest.setAttribute(\"valor\", 100);JSP&lt;c:if test=\"${valor &gt; 50}\"&gt; O valor é maior que 50!&lt;/c:if&gt;&lt;c:if test=\"${valor &lt; 50}\"&gt; O valor é menor que 50!&lt;/c:if&gt;&lt;c:if test=\"${valor == 50}\"&gt; O valor é maior que 50!&lt;/c:if&gt;, , • Testam diversas condições de forma agrupada• Apenas um bloco é executadoServletrequest.setAttribute(\"tipoUsuario\", \"admin\");JSP&lt;c:choose&gt; &lt;c:when test=\"${tipoUsuario == 'admin'}\"&gt; Bom dia, usuário administrador! &lt;/c:when&gt; &lt;c:when test=\"${tipoUsuario == 'gerente'}\"&gt; Bom dia, usuário gerente! &lt;/c:when&gt; &lt;c:otherwise&gt; Bom dia, usuário desconhecido! &lt;/c:otherwise&gt;&lt;/c:choose&gt;• Permite definir uma variável em um determinado escopoJSP&lt;c:set var=\"cont\" value=\"1\" scope=\"request\" /&gt;&lt;!--O valor é fixo--&gt;&lt;c:set var=\"cliente\" value=\"${conta.cliente}\" scope=\"session\" /&gt;&lt;!--O valor é lido a partir de um atributo--&gt;• Esta tag também pode ser usada para popular a propriedade de um bean&lt;c:set target=\"${conta}\" property=\"numConta\" value=\"1234-5\" /&gt;Bean - Propriedade - Valor• E também de um java.util.Map&lt;c:set target=\"${clientes}\" property=\"34\" value=\"Carlos\" /&gt;java.util.Map - Chave - Valor• Permite criar linksJSP&lt;c:url var=\"link\" value=\"/ProcessarPedido\"&gt; &lt;c:param name=\"numPedido\" value=\"${num}\" /&gt; &lt;c:param name=\"pago\" value=\"false\" /&gt;&lt;/c:url&gt;&lt;A href=\"${link}\"&gt;Processar Pedido&lt;/A&gt;&lt;A href=\"/app/ProcessarPedido?numPedido=30&amp;pago=false\"&gt;Processar Pedido&lt;/A&gt;• O JSTL é um conjunto amplo de tag libraries• Para maiores informações, consulte a documentação no site oficial Baseado nos cursos da Softblue" }, { "title": "Anotações sobre Fundamentos de Desenvolvimento WEB com Angular", "url": "/posts/angular/", "categories": "Estudos-faculdade", "tags": "angular, javascript, typescript, web", "date": "2021-10-22 09:00:00 -0300", "snippet": " Baseado nas minhas anotações da disciplina da graduaçãoAngularO Angular iniciou como um projeto pessoal de Miško Hevery para facilitar o trabalho de designers que não conheciam programação a fazer alterações nas telas das aplicações usando basicamente HTML.O nome foi baseado nos sinais &lt; e &gt; (angle) utilizados nas suas tags (NG-CONF, 2014).Sua primeira versão se chamava AngularJS e foi desenvolvida e mantida pelo Google até o desenvolvimento da nova versão. Atualmente ainda é mantida, mas com suporte limitado para questões relacionadas à segurança (Long Term Support) até 31 de dezembro de 2021 (Angular, 2021d).Desde seu início, o AngularJS foi desenvolvido em JavaScript para ser utilizado no lado cliente (Angular, 2021b). Com a versão 2.0, o AngularJS foi totalmente reescrito e passou a ser chamado somente de Angular; passou também a ser desenvolvido utilizando TypeScript como linguagem padrão.Uma aplicação Angular necessita ser compilada, e por meio dessa compilação é gerado um código JavaScript que pode ser executado diretamente pelos navegadores.MEAN (MONGODB, EXPRESS.JS, ANGULAR, E NODE.JS)As tecnologias têm o seguinte objetivo (&gt;IBM, 2019):a. MongoDB: base de dados NoSQL open-source que utiliza uma estrutura semelhante ao JSON para armazenar os dados.b. ExpressJS: framework que possibilita o desenvolvimento de aplicação no servidor usando NodeJS.c. NodeJS: ferramenta que possibilita a execução de JavaScript fora do ambiente de um navegador.d. Angular: framework que possibilita o desenvolvimento de aplicações SPA.Com a utilização do JavaScript, tags personalizadas podem ser criadas, bem como constar no DOM e terem atributos e funcionalidades específicas (Custom HTML, 2021). Para construir uma tag personalizada válida, seu nome deve ter mais de uma palavra com um traço. Esse tipo de tag personalizada é utilizada pelo Angular ao definir pontos do documento HTML que terão informações dinâmicas.CONTROLE DE INTERFACEO Model View Controller – MVC (ou “Modelo, Visão e Controlador”) é uma forma de organizar o código de maneira a separar a parte visual que será apresentada ao usuário do restante do código da aplicação, de forma que, ao fazer ajustes na visualização das informações ou do layout da tela, o impacto no restante do código da aplicação seja o mínimo.O padrão MVC propõe que o código seja organizado com base em três grupos (Matos; Zabot, 2020, p. 196; martinFowler.com, 2006). O model (“modelo”) reúne o código utilizado para processar as regras principais do programa. É a parte do aplicativo que vai executar as funcionalidades a que o sistema se propõe; O view (“visão”) é a parte do aplicativo que formatará os dados para visualização do usuário. Os componentes visuais (botões, menus, formulários, figuras) serão exibidos nessa parte do padrão MVC; O controler (“controlador”) é a parte do código que recebe os dados que o usuário selecionou, digitou ou clicou na interface e encaminha para a parte do aplicativo que vai processar a informação. O controlador vai decidir se apresenta algo na tela (view) ou executa uma função (model). No caso de desenvolvimento web, considerando que a parte visual é montada com HTML, o MVC adiciona mais uma vantagem que é a possibilidade de um designer web (que não conhece programação) poder trabalhar no layout HTML e no desenvolvimento de opções visuais sem interferir na codificação.As primeiras interfaces de sistemas eram executadas em um fluxo em que o programa exibia uma questão para o usuário, o usuário respondia e, com base no tipo de resposta do usuário, o programa executava algum procedimento. O programa é que controlava cada etapa da execução.Quando temos um código que está separado das funcionalidades que estão sendo desenvolvidas para a aplicação, e que chama essas funcionalidades por meio da estrutura montada para gerenciar a execução dos códigos, estamos invertendo o controle de execução (martinFowler.com, 2004; 2005).A inversão de controle (IoC, em inglês) é uma das características fundamentais dos frameworks de aplicações (martinFowler.com, 2004). Os frameworks representam uma estrutura básica para o desenvolvimento dos sistemas, em que o desenvolvedor vai acrescentando trechos de código específicos da aplicação e o framework gerencia a execução desses códigos.Uma forma de inversão de controle é conhecida como injeção de dependência (Dependency Injection), em que os códigos a serem executados são chamados por um objeto controlador, deixando a aplicação mais genérica (martinFowler.com, 2004).O framework Angular utiliza a injeção de dependência para combinar os códigos desenvolvidos com o esqueleto do framework.A navegação entre as telas dos sistemas web deve ser estruturada de forma que o usuário possa clicar em um link e o sistema apresenta a tela ou executa o procedimento correspondente. Para isso, os frameworks implementam mecanismos genéricos em que essa relação de link e tela possam ser configurados pelos desenvolvedores.No Angular, o módulo de roteamento (router) possibilita que o desenvolvedor crie um tipo de lista de páginas que cada link deve executar (Angular, 2021c). Dessa forma, o framework tem uma estrutura de navegação que pode ser utilizada para diferentes sistemas.NODEJSCOMANDOS NGPara trabalhar com o framework Angular, algumas tarefas burocráticas são necessárias e trechos de código padrão devem ser criados para que o framework possa ser inicializado. Uma estrutura de pastas deve ser criada, componentes devem ser registrados e o mecanismo de navegação deve ser atualizado.São várias tarefas que não estão relacionadas ao desenvolvimento das funcionalidades da aplicação e que, se fossem feitas manualmente, seria um tempo a mais não dedicados à programação dessas funcionalidades.Para auxiliar o desenvolvedor nessas tarefas foi criado o Angular CLI, que é uma ferramenta utilizada para automatizar grande parte das atividades relacionadas ao framework. Para instalar basta utilizar o comando npm install -g @angular/cli. O “npm” é o gerenciador de pacotes do NodeJS e faz o download do programa, bem como verifica suas dependências.Após instalado, o comando ng fica disponível para o desenvolvedor, que poderá configurar um novo projeto de uma aplicação angular (ng new meu-proj), compilar a aplicação para distribuir (ng build meu-proj) ou testar a aplicação em desenvolvimento iniciando um servidor de teste (ng serve) (Angular, 2021a).TYPESCRIPTO TypeScript é uma linguagem baseada em uma adaptação do JavaScript feita pela Microsoft para adicionar tipos estáticos, cujo código é convertido para JavaScript após passar por um compilador (Typescriptlang, 2021).Com a possibilidade de declarar tipos, alguns conceitos de orientação a objetos são reforçados como o encapsulamento, que pode receber um atributo “private” e evitar o acesso externo à variável de uma classe sem autorização (TYPESCRIPT, 2021).ESTRUTURA ANGULARNa pasta “src”, temos a aplicação em si, ou seja, os códigos usados para construir a aplicação e onde o desenvolvedor vai trabalhar diretamente. Na pasta “node_modules”, temos alguns pacotes necessários ao framework Angular e alguns pacotes de uso frequente em aplicações. Ainda, podem ser instalados pacotes de terceiros utilizando a ferramenta “npm”. Inicialmente, essa pasta contém mais de 39.000 arquivos.Todos os pacotes devem estar registrados no arquivo “package.json”.A pasta “src” tem o arquivo “index.html”, que é o início da aplicação. Ele está praticamente vazio, tendo apenas a tag personalizada “”, que por sua vez vai chamar o componente principal. O componente principal está na pasta “app” e é composto por um arquivo HTML (app.component.html), um CSS (app.component.css) e um ćodigo TypeScript (app.component.ts). Essa pasta também tem um arquivo “app.componet.spec.ts” para testes e um “app.module.ts” que mantêm um registro de todos os componentes necessários para compor a aplicação.O conteúdo de modificações, portanto, deverá ser incluído no “app.component.html”, e se for necessário criar algum estilo CSS específico para esse conteúdo, podemos também incluir a formatação no “app.component.css”.Para facilitar os testes, o comando “ng” do Angular apresenta uma opção “serve” que automatiza a compilação e inicia a execução de um servidor de teste, que já disponibiliza a aplicação compilada.Após finalizar a compilação na tela, o servidor será executado. Basta o desenvolvedor colocar na área de endereço do navegador a URL de teste http://localhos:4200 que aparecerá o resultado.ANGULAR VIEWNo Angular, as informações que são apresentadas em HTML fazem parte de uma estruturação do framework para o uso de templates. Estes templates são um esqueleto que pode abrigar variáveis e pequenos algoritmos que facilitam a listagem de dados.Inicialmente, temos a possibilidade de incluir no HTML variáveis que vão ser convertidas para seu conteúdo assim que a tela for apresentada ao usuário. Essa possibilidade deixa o HTML mais genérico, evitando ter de ser alterado a cada processamento. Para acrescentar as variáveis no template, basta incluir as duplas chaves de início ``.A partir do index.html, que tem a parte inicial da aplicação, o Angular vai combinando os demais arquivos HTML até formar a aplicação completa. Por esse motivo os demais templates não precisam ter as tags iniciais &lt;html&gt;, &lt;head&gt; e &lt;body&gt;.Para permitir que grupos de dados sejam facilmente listados nas estruturas do HTML, o template Angular inclui o atributo *ngFor, que vai criar um laço de repetição que multiplicará as tags HTML envolvidas.Somado à possibilidade de repetição automatizada de trechos do HTML, temos também como decidir se uma tag será incluída ou não na tela, com base no conteúdo de variáveis. O Angular tem o atributo *ngIf, que determina se a tag na qual ele se encontra será incluída na montagem da telaFiltros (pipes): Durante a exibição dos dados, a formatação pode trazer uma maior facilidade na interpretação das informações. Por esse motivo, temos no Angular filtros que podem converter os dados para um formato visualmente mais interessante.O Angular possui alguns filtros para dados que são frequentemente utilizados, como:a. DatePipe: utilizado para transformar as datas, podendo fazer a separação de meses, dias e anos;b. UpperCasePipe: converte o texto para maiúsculas;c. LowerCasePipe: converte o texto para minúsculas;d. CurrencyPipe: apresenta o valor como uma informação financeira, usando, inclusive, o símbolo da moeda no país específico;e. DecimalPipe: converte o valor para string com a pontuação de casas decimais;f. PercentPipe: converte o número em uma string com o sinal de percentual.InternacionalizaçãoConfigurações necessárias para isso, que devem ser acrescentadas no app.module.ts.// ---- localização - pt-BR import { LOCALE_ID } from '@angular/core'; import { registerLocaleData } from '@angular/common'; import ptBR from '@angular/common/locales/pt'; registerLocaleData(ptBR); //--- no @NgModule providers: [\t{provide: LOCALE_ID, \tuseValue: 'pt'\t} ],Para acrescentar um novo componente, o comando ng pode ser utilizado para simplificar a configuração, digitando na linha de comando ng generate component nome-componente. Uma nova pasta será criada dentro de “app” com os arquivos “.ts”, “.css”, “.html” do novo componente.INSTALANDO UM APLICATIVO ANGULAROs procedimentos para transformar nossa aplicação SPA Angular em um aplicativo PWA envolvem a adoção de parâmetros e configurações que são facilitadas pelo utilitário “ng”, e para isso basta instalar ng add @angular/pwa.Com o ajuste finalizado, devemos preparar a aplicação para uso em produção, o que envolve a compilação e empacotamento de todos os arquivos necessários para distribuição. Esse passo seria feito independentemente de conversão para PWA e serve também para finalizar a aplicação Angular: ng build --prod. A pasta “dist/app-nome” será criada e todos os arquivos necessários estarão armazenados lá. Basta incluir esses poucos arquivos num servidor HTTP e nossa aplicação pode ser liberada. No caso do PWA, o servidor de teste do Angular não funciona e por esse motivo teremos que utilizar outra opção. Para facilitar, temos o pacote “http-server” no Node.js, que pode ser utilizado. Basta instalar com npm install http-server e executar http-server -p 8080 -c-1 dist/app-nome na pasta do projeto." }, { "title": "Integrando Servlets e JSPs", "url": "/posts/integrando-servlets-jsp/", "categories": "Estudos-faculdade", "tags": "java, web", "date": "2021-10-15 09:00:00 -0300", "snippet": "O Papel de Cada Componente• Se um JSP é um servlet, quando usar um e quando usar outro?graph BT subgraph Modelo MVC A[fa:fa-user] --&gt;|request| B(Servlet) B --&gt; C(Model) C --&gt; B B --&gt; D(JSP) D --&gt;|response| A endgraph LR A(\"JSP (origem)\") --&gt;|\"request (parameters)\"| B(Servlet) B --&gt;|\"request (attributes)\"| C(\"JSP (destino)\")Parameters (Parâmetros)• São fornecidos pelo HTTP através de requisições GET ou POSThttp://www.joaonogueira.dev/CadastroServlet?nome=João&amp;empresa=joaonogueira.devpublic class CadastroServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String nome = request.getParameter(\"nome\");//O retorno é sempre uma string String empresa = request.getParameter(\"empresa\"); CadastroService service = new CadastroService(); service.cadastrar(nome, empresa); ... }}Attributes (Atributos)• São dados colocados numa área comum e podem ser compartilhadospublic class CadastroServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... Registro reg = service.cadastrar(nome, empresa); request.setAttribute(\"r\", reg);//O atributo deve possuir um nome e pode ser de qualquer tipo request.getRequestDispatcher(\"sucesso.jsp\").forward(request, response);//Redirecionamento para um JSP de destino }}sucesso.jsp&lt;html&gt;&lt;body&gt;&lt;% Registro reg = (Registro) request.getAttribute(\"r\");//request é um objeto implícito%&gt;&lt;H1&gt;Cadastro feito com sucesso!&lt;/H1&gt;&lt;H2&gt;O ID do cadastro é: &lt;%= reg.getId() %&gt;&lt;/H2&gt;&lt;/body&gt;&lt;/html&gt;Escopos dos Atributos• A visibilidade dos atributos depende do seu escopo Escopo Descrição page Apenas a página que define o atributo o enxerga. Usado em JSPs request Atributos visíveis apenas enquanto durar a requisição context Atributos compartilhados com todos os servlets e JSPs da aplicação session Atributos visíveis apenas a um cliente específico O Escopo Page• Usado em JSPs• Um atributo é definido no JSP e só é visível dentro do JSP&lt;% pageContext.setAttribute(\"nome\", \"João\");//Define o atributo no escopo page%&gt;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Nome: &lt;%= pageContext.getAttribute(\"nome\") %&gt;&lt;/H1&gt;//Lê o atributo&lt;/body&gt;&lt;/html&gt;O Escopo Request• Atributos na request duram apenas enquanto durar a requisiçãoServlet...Registro reg = service.cadastrar(nome, empresa);request.setAttribute(\"r\", reg);request.getRequestDispatcher(\"sucesso.jsp\").forward(request, response);...sucesso.jsp&lt;% Registro reg = (Registro) request.getAttribute(\"r\");%&gt;O Escopo Context• Os atributos são compartilhados por todos os servlets e JSPs da aplicaçãoServletServletContext ctx = getServletContext();ctx.setAttribute(\"versao\", \"1.0\");String versao = (String) ctx.getAttribute(\"versao\");JSP&lt;% application.setAttribute(\"versao\", \"1.0\");%&gt;&lt;%= application.getAttribute(\"versao\") %&gt;O Escopo Session• Os atributos são exclusivos de um cliente da aplicação• Outros clientes que usam a aplicação não têm acesso aos atributos• A session define um estado de conversação entre um cliente específico e um servidor– O servidor reconhece as múltiplas requisições do clienteAcesso Concorrente aos Atributos• Lembre-se que em um ambiente web existem múltiplos clientes fazendo acessos simultâneos• Apenas o escopo request é thread-safeServletContext ctx = getServletContext();synchronized(ctx) { ctx.setAttribute(\"versao\", \"1.0\");}Estado de Conversação• Algumas aplicações exigem que o servidor saiba quem é o cliente com o qual ele está lidando– Várias telas de cadastro– Carrinho de compras– Login de usuário– etc.• O problema é que o protocolo HTTP não armazena estadoSessão• Na camada web, a forma de fazer isto é usando uma session (sessão)– Representada pela interface HttpSessionServletHttpSession session = request.getSession();session.setAttribute(\"usuario\", \"usu1010\");String u = (String) session.getAttribute(\"usuario\");JSP&lt;% session.setAttribute(\"usuario\", \"usu1010\");%&gt;&lt;%= session.getAttribute(\"usuario\") %&gt;• A sessão é única para cada cliente• Não existe a possibilidade de outro cliente ler ou escrever dados na sessão de outro cliente• Se você estiver acessando uma aplicação e um atributo for colocado na sua sessão, numa requisição futura a aplicação poderá ler este atributoFuncionamento da Sessão• Como o servidor sabe quem é o cliente?• O servidor gera um ID único por clientegraph LR subgraph .. D[fa:fa-user] --&gt;|\"a@a.com, #25\"| E[fa:fa-server] E --&gt;|\"setAttribute()\"| F((HttpSession #25)) end subgraph . A[fa:fa-user] --&gt;|usu1010| B[fa:fa-server] B --&gt;|nova sessão| C((HttpSession #25)) B --&gt;|\"setAttribute()\"| C((HttpSession #25)) B --&gt;|ID #25| A end• Para que o processo funcione, é necessário que cliente e servidor troquem a informação de ID da sessão• Isto pode ser feito de duas formas– Cookies– URL rewritingSessão por Cookies• Cookies são informações enviadas pelo servidor e guardadas no cliente• O servidor envia um cookie para o cliente e este o armazena• A cada requisição, o cliente reenvia o cookie ao servidor• Os cookies vão dentro do cabeçalho do protocolo HTTPSessão por URL Rewriting• Usada normalmente quando o cliente não aceita cookies• A cada URL chamada, o cliente reenvia o ID da sessão na URLO container adiciona o ID da sessão à URLhttp://www.joaonogueira.dev/Comprar;jsessionid=2379FD2Tempo de Vida da Sessão• Pode ser que o cliente tenha seus dados colocados na sessão e pare o processo no meio• Para evitar o gasto desnecessário de recursos, a sessão é destruída depois de um tempo– O tempo pode ser configurado no web.xml• A sessão também pode ser destruída via programação– Método invalidate() da interface HttpSession• Uma boa prática é remover os atributos da sessão que não são mais necessários– Método removeAttribute() da interface HttpSessionCookies• Os cookies são pares de chave e valor armazenados no cliente• Por padrão eles desaparecem assim que o browser é fechado, mas é possível configurá-los para que eles durem mais tempoTrabalhando com Cookies• O servidor é quem cria o cookieCookie cookie = new Cookie(\"nomeCliente\", \"Carlos\");cookie.setMaxAge(30 * 60);response.addCookie(cookie);• Quando o cliente faz uma requisição, ele envia seus cookies ao servidor• O servidor pode procurar pelo cookie desejadoCookie[] cookies = request.getCookies();for (Cookie cookie : cookies) { if(cookie.getName().equals(\"nomeCliente\")) { String nome = cookie.getValue(); }}Redirecionamento• Após um servlet terminar sua tarefa, ele normalmente redireciona a requisição para um arquivo JSP, que será mostrado como resultado para o cliente• Este redirecionamento pode ser feito de duas formas:– Forward– RedirectForward• O forward é um redirecionamento interno– O próprio container faz o redirecionamento– Olhando a URL, não é possível determinar para onde ocorreu o redirecionamentorequest.getRequestDispatcher(\"sucesso.jsp\").forward(request, response);//Forward para sucesso.jspRedirect• O redirect é um redirecionamento para outra URL– O container solicita ao browser a requisição de uma nova URL– Olhando a URL, é possível ver para onde ocorreu o redirecionamentoresponse.sendRedirect(\"sucesso.jsp\");//Redirect para sucesso.jspAo fazer um redirect, todos os dados da request são perdidosForward ou Redirect?• O que normalmente ocorre na prática é que o redirect é utilizado após alguma operação que salva, atualiza ou exclui dados da aplicação– O redirect evita que o cliente pressione F5 no browser e o processo seja executado de novo• Nas outras situações, normalmente o forward é utilizado– Se o cliente pressionar F5 no browser o processo é executado de novo, mas isto não traz problemas Baseado nos cursos da Softblue" }, { "title": "Java Server Pages", "url": "/posts/java-server-pages/", "categories": "Estudos-faculdade", "tags": "java, web", "date": "2021-10-08 09:00:00 -0300", "snippet": "O Que É• Um documento HTML é estático• Para criar respostas dinâmicas em Java, existem os servlets– Dependendo da resposta, é bastante difícil codificá-la usando servlets• Surgiram os JSPs– Java Server Pages– HTML + Código Java&lt;%@ page language=\"java\" contentType=\"text/html; harset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;%@page import=\"java.util.List\"%&gt;&lt;%@page import=\"java.util.ArrayList\"%&gt;&lt;% List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(\"Arroz\"); l.add(\"Feijão\"); l.add(\"Batata\");%&gt;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Lista de Compras&lt;/H1&gt;&lt;ul&gt;&lt;% for (String item : l) { %&gt;&lt;li&gt;&lt;%= item %&gt;&lt;/li&gt;&lt;% } %&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Lista de Compras&lt;/H1&gt;&lt;ul&gt; &lt;li&gt;Arroz&lt;/li&gt; &lt;li&gt;Feijão&lt;/li&gt; &lt;li&gt;Batata&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;Na resposta que chega ao cliente, o documento é 100% HTMLUm JSP é na verdade um servletScriptlets• São códigos Java inseridos no JSP• Não estão presentes no HTML resultante• Um scriptlet deve começar com &lt;% e terminar com %&gt;&lt;% List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(\"Arroz\"); l.add(\"Feijão\"); l.add(\"Batata\");//O ponto-e-vírgula é necessário aqui%&gt;Expressions• Também são códigos Java inseridos no JSP• São convertidas em texto no HTML resultante• Uma expression deve começar com &lt;%= e terminar com %&gt;&lt;ul&gt;&lt;% for (String item : l) { %&gt;&lt;li&gt;&lt;%= item %&gt;&lt;/li&gt;&lt;% } %&gt;&lt;/ul&gt;Uma expression deve sempre resultar numa stringExpressions não recebem ponto-e-vírgulaDeclarations• Também são códigos Java inseridos no JSP• Usadas para declarar atributos e métodos de instância• Uma declaration deve começar com &lt;%! e terminar com %&gt;&lt;%! int id = 0; %&gt;&lt;%! int getId() { return id;//Não esqueça de colocar ponto-e-vírgula }%&gt;Scriptets são traduzidos da forma como são escritosExpressions são traduzidas como parâmetros para o out.print()Declarations são traduzidas como atributos e métodosComentários em JSP• Dentro de scriptlets, os comentários seguem o padrão do Java&lt;% //este é um comentário int x = 0;%&gt;&lt;% /* este é um comentário */ int x = 0;%&gt;• Fora dos scriptlets, deve ser usada outra notação&lt;%-- este é um comentário %&gt;Diretivas do JSP• JSP possui 3 tipos de diretivas (directives)• Elas são identificadas por começarem por &lt;%@ e terminarem por %&gt; Diretiva Descrição include Inclui código de um arquivo externo no JSP taglib Define uma tag library page Define propriedades da página A Diretiva Include• Permite incluir um arquivo externo na criação do JSP• A inclusão é feita durante a fase de tradução– O servlet gerado já contém o conteúdo incluído&lt;%@ include file=\"inc/header.jsp\" %&gt;A Diretiva Taglib• Permite referenciar tag libraries na página– Tag libraries são bibliotecas de tags– Utilizadas para simplificar algumas tarefas e esconder o código Java&lt;%@ taglib uri=\"http://www.jsp.org/tags\" prefix=\"jsp\" %&gt;&lt;jsp:loop id=\"item\" value=\"lista\"&gt; ...&lt;/jsp:loop&gt;A Diretiva Page• Define propriedades específicas da página JSP• É composta por diversos atributos– language– contentType– pageEncoding– import– isErrorPage– errorPage• Os atributos language, contentType e pageEncoding definem a linguagem e codificação&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\" %&gt;• O atributo import é utilizado para importar classes e/ou pacotes que serão usados no JSP• Funciona de forma bastante semelhante ao import do Java&lt;%@ page import=\"java.util.List\" %&gt;&lt;%@ page import=\"java.util.List, java.util.ArrayList\" %&gt;&lt;%@ page import=\"java.util.*\" %&gt;• Por padrão, alguns imports já são realizados– java.lang.*– javax.servlet.*– javax.servlet.jsp.*– javax.servlet.http.*JSP Actions• Funcionalidades para melhorar a produtividade no desenvolvimento• São definidas pelas tags no formato &lt;jsp:action&gt; Action Descrição Inclui outro JSP para renderização Redireciona a requisição para outro local Cria parâmetros no JSP Recupera a propriedade de um Java Bean Atribui um valor a uma propriedade de um Java Bean Referencia um Java Bean no JSP A action &lt;jsp:include&gt;• Inclui o conteúdo de outro arquivo (HTML, JSP, servlet, etc.)• A inclusão é feita durante a renderização– A diretiva &lt;%@ include %&gt; faz a inclusão na fase de tradução&lt;html&gt;&lt;body&gt;&lt;jsp:include page=\"header.jsp\" /&gt;//Inclui o arquivo header.jsp na geração do HTML de retorno...&lt;/body&gt;&lt;/html&gt;A action &lt;jsp:forward&gt;• Permite redirecionar a requisição para outro local– HTML, JSP, servlet, etc&lt;jsp:forward page=\"result.jsp\" /&gt; //Redireciona para o arquivo result.jspObjetos Implícitos• Como um JSP é um servlet, ele possui acesso à objetos que um servlet acessaria• Estes objetos existem de forma implícita no JSP Objeto Implícito Classe do Objeto   out JspWriter Dados na saída application ServletContext Configuração config ServletConfig Configuração exception JspException Apenas para páginas de erro request HttpServletRequest Escopo de dados response HttpServletResponse Escopo de dados session HttpSession Escopo de dados pageContext PageContext Escopo de dados page Object Escopo de dados Páginas de Erro• Os atributos isErrorPage e errorPage possibilitam o direcionamento para uma página de erro caso alguma exceção inesperada ocorra• isErrorPage deve ser usado pela página que representa a página de erro• errorPage deve indicar uma página de erro para que haja o redirecionamento no caso de erro&lt;%@ page errorPage=\"error.jsp\" %&gt;//atributo errorPage define qual JSP chamar em caso de exceção&lt;html&gt;&lt;body&gt;&lt;% Object o = null; o.toString();//Este código vai gerar uma NullPointerException%&gt;&lt;/body&gt;&lt;/html&gt;&lt;%@ page isErrorPage=\"true\" %&gt;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Erro no Sistema&lt;/H1&gt;&lt;STRONG&gt;Mensagem: &lt;/STRONG&gt;&lt;%= exception.toString() %&gt;//Uma página de erro possui um objeto implícito chamado exception, que representa a exceção ocorrida&lt;/body&gt;&lt;/html&gt;Inicialização e Destruição de JSPs• Em servlets, o container chama os métodos– init(): ao inicializar o servlet– destroy(): ao destruir o servlet– service(): ao atender uma requisição• Como um JSP é um servlet, o container também chama métodos semelhantes– jspInit(): ao inicializar o JSP– jspDestroy(): ao destruir o JSP– _jspService(): ao atender uma requisição• É possível sobrescrever os métodos jspInit() e jspDestroy()• O método _jspService() não deve ser sobrescrito&lt;%!//Usar declaration public void jspInit() { //inicializar o que for necessário } public void jspDestroy() { //destruir o que for necessário }%&gt;Passando Parâmetros para JSPs• Assim como servlets, JSPs também podem receber parâmetros de inicialização&lt;servlet&gt; &lt;servlet-name&gt;ListaCompras&lt;/servlet-name&gt; &lt;jsp-file&gt;/lista_compras.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;moeda&lt;/param-name&gt; &lt;param-value&gt;R$&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ListaCompras&lt;/servlet-name&gt; &lt;url-pattern&gt;/lista_compras.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;html&gt;&lt;body&gt; Moeda: &lt;%= config.getInitParameter(\"moeda\") %&gt;//O objeto implítico config acessa o ServletConfig do servlet&lt;/body&gt;&lt;/html&gt;Não use código Java em JSPs• Apesar de JSPs terem sido criados para possibilitar a mistura de HTML e código Java, escrever código Java em JSPs não é uma boa prática– Dificulta o trabalho de web designers, que não são programadores– Para páginas complexas, o código fica confuso– Dificuldade de manutenção• Qual a alternativa?– EL (Expression Language)– JSTL (Java Server Pages Standard Tag Library)– Tag libraries customizadas Baseado nos cursos da Softblue" }, { "title": "Segurança em Jakarta EE", "url": "/posts/seguranca-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-10-01 09:00:00 -0300", "snippet": "Os Principais Conceitos de SegurançaAutenticação: Garante que alguém é realmente quem diz ser;Autorização: Verifica a possibilidade de acesso de alguém autenticado;Confidencialidade e Integridade: Garantem que os dados não serão lidos ou alterados durante o tráfego.Autenticação• Garante a identidade de alguém– Usuário e senha– Leitura biométrica– Certificado digital• Até o Java EE 7, o processo de autenticação não era padronizado– Cada container implementava da sua forma• A partir do Java EE 8, foi criada a Java EE Security API– Padronização no processo de autenticaçãoAutorização• Depois de autenticado, o usuário pode acessar o recurso protegido?• Em Java EE, a autorização é padronizada na especificação– Todos os containers seguem o mesmo padrãoDefinindo os Roles de Acesso• Um role representa um grupo de acesso• Os roles da aplicação podem ser definidos no arquivo web.xml&lt;security-role&gt; &lt;role-name&gt;gerente&lt;/role-name&gt;&lt;/security-role&gt;&lt;security-role&gt; &lt;role-name&gt;diretor&lt;/role-name&gt;&lt;/security-role&gt;• Ou via anotação@DeclareRoles({ \"admin\", \"guest\" })Protegendo Recursos• Recursos são protegidos em Java EE com base em mapeamentos de URL e HTTP method feitos no web.xml&lt;web-app&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;admin pages&lt;/web-resource-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;http-method&gt;GET&lt;/http-method&gt;&lt;!--Mapeamento e HTTP method--&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;diretor&lt;/role-name&gt;&lt;!--Roles autorizados--&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt;&lt;/web-app&gt;Tipos de Autenticação• Ao acessar um recurso protegido, o navegador precisa solicitar as credenciais do usuário de alguma forma• Essas são as 3 formas de autenticação mais usadas: Forma Descrição BASIC O navegador abrirá uma janela padrão solicitando as credenciais FORM O usuário será redirecionado para uma página customizada para fornecer as credenciais CUSTOM FORM O usuário também fornecerá as credenciais em uma página customizada, mas o processo de autenticação é controlado por programação Autenticação BASIC• O container cuida de todo o processo de autenticação• Uma janela aberta pelo próprio navegador solicita o usuário e a senha@BasicAuthenticationMechanismDefinition public class Config {}Autenticação FORM• Páginas customizadas para solicitar as credenciais– Uma página solicitando usuário e senha– Uma página para que haja o redirecionamento caso os dados digitados sejam inválidos@FormAuthenticationMechanismDefinition( loginToContinue = @LoginToContinue( loginPage = \"/login.faces\", errorPage = \"/error.faces\" ))public class Config {}• O formulário de login deve seguir algumas regras&lt;html&gt; &lt;body&gt; &lt;form method=\"POST\" action=\"j_security_check\"&gt; Usuário: &lt;input type=\"text\" name=\"j_username\"&gt;&lt;br /&gt; Senha: &lt;input type=\"password\" name=\"j_password\"&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"Login\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;Autenticação CUSTOM FORM• Também baseado em páginas customizadas para o fornecimento de credenciais@CustomFormAuthenticationMechanismDefinition( loginToContinue = @LoginToContinue( loginPage = \"/login.faces\", errorPage = \"/error.faces\" ))public class Config {}• O formulário é livre, não precisa seguir nenhuma regra&lt;html&gt; &lt;body&gt; &lt;h:form&gt; Usuário: &lt;h:inputText value=\"#{loginBean.userName}\" /&gt;&lt;br /&gt; Senha: &lt;h:inputSecret value=\"#{loginBean.password}\" /&gt;&lt;br /&gt; &lt;h:commandButton value=\"Login\" action=\"#{loginBean.login}\" /&gt; &lt;/h:form&gt; &lt;/body&gt;&lt;/html&gt;• O login é feito via programação usando um objeto SecurityContext@Named@RequestScopedpublic class LoginBean implements Serializable { @Inject private SecurityContext securityContext; private String userName; private String password; public String login() { //... AuthenticationStatus status = securityContext.authenticate(request, response, authParams); //... }}O objeto SecurityContext• A Java EE Security API introduziu o conceito de SecurityContext– Um objeto onde detalhes do usuário autenticado podem ser obtidos via programação Método Descrição authenticate() Autentica um usuário fornecendo suas credenciais getCallerPrincipal() Retorna o objeto Principal do usuário autenticado isCallerInRole() Verifica se o usuário autenticado pertence a determinado grupo hasAccessToWebResource() Verifica se o usuário autenticado tem acesso a determinada página web • Um objeto SecurityContext é obtido através de injeção de dependência feita pelo CDI@Injectprivate SecurityContext securityContext;• Ele pode ser obtido em diversos tipos de componentes do Java EE– EJBs– Servlets– Filters– JSF BeansSegurança em EJBs• A anotação @RolesAllowed controla quem pode acessar os métodos de um EJB@Stateless@RolesAllowed(\"admin\")//Apenas usuários do grupo admin podem chamar m1() e m2()public class MyBean { public void m1() { } public void m2() { }}• A anotação @RolesAllowed também pode ser usada em métodos@Stateless@RolesAllowed(\"admin\")public class MyBean { public void m1() { } @RolesAllowed(\"guest\")//m2() pode ser chamado por usuários do grupo guest public void m2() { }}Confidencialidade e Integridade• A confidencialidade previne que os dados sejam lidos durante o tráfego na rede• A integridade garante que os dados não serão alterados enquanto trafegam pela rede• O HTTPS dá essas garantias– Hypertext Transfer Protocol SecureAntes de serem enviados, os dados são criptografados.Apenas o servidor de destino consegue descriptografar os dadosHTTPS e Java EE• Primeiramente, é necessário configurar o servidor para que ele aceite conexões do tipo HTTPS• Depois, no web.xml, basta definir que o acesso a determinado recurso necessita de HTTPS&lt;web-app&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;admin pages&lt;/web-resource-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;&lt;!--Garante o uso de HTTPS sempre que uma URL no padrão /admin/* for acessada--&gt; &lt;/user-data-constraint&gt; &lt;/security-constraint&gt;&lt;/web-app&gt; Baseado nos cursos da Softblue" }, { "title": "O Arquivo web.xml - Jakarta EE", "url": "/posts/arquivo-webxml-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-09-24 09:00:00 -0300", "snippet": "O Arquivo web.xml• Utilizado para configurar a aplicação web• Não é obrigatório, mas é necessário pra alguns tipos de configurações• Possui algumas tags para algumas configurações simples, porém importantes– &lt;welcome-file-list&gt;– &lt;session-config&gt;– &lt;error-page&gt;– &lt;context-param&gt;&lt;welcome-file-list&gt;• Definir arquivos padrão que serão carregados caso o usuário acesse a aplicação pelo navegador diretamente no context-roothttp://localhost:8080/curso //Vai retornar um erro 404 do HTTP&lt;web-app&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.faces&lt;/welcome-file&gt; &lt;welcome-file&gt;primeiro.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;http://localhost:8080/curso //Vai retornar um welcome-file&lt;session-config&gt;• Permite definir um tempo de expiração para a sessão de um usuário&lt;web-app&gt; &lt;session-config&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt;&lt;!--O tempo é definido em minutos. Caso não seja fornecido, um valor padrão é assumido--&gt; &lt;/session-config&gt;&lt;/web-app&gt;&lt;error-page&gt;• Permite direcionar a requisição para uma página customizada de erro– De acordo com algum código de retorno HTTP– De acordo com uma determinada exceção&lt;web-app&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.faces&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt;&lt;web-app&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt;&lt;!--Qualquer exceção que ocorrer--&gt; &lt;location&gt;/exception.faces&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt;&lt;context-param&gt;• Permite definir parâmetros iniciais para a aplicação web• Os parâmetros são visíveis para a aplicação como um todo&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;adminEmail&lt;/param-name&gt; &lt;param-value&gt;admin@abc.com&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt;Beanpublic class MyBean implements Serializable { @Inject @InitParameterMap private Map&lt;String, String&gt; initMap; public void method() { String email = initMap.get(\"adminEmail\"); }}#{initParam['adminEmail']}Parâmetros Importantes no JSF• A tag &lt;context-param&gt; é usada para definir alguns parâmetros importantes do JSF• Configuração de timezone&lt;context-param&gt; &lt;param-name&gt;javax.faces.DATETIMECONVERTER_DEFAULT_TIMEZONE_IS_SYSTEM_TIMEZONE&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt;&lt;/context-param&gt;• Define que o timezone (fuso horário) a ser usado no processo de conversão de datas é o timezone do sistema operacional• O padrão é usar o UTC• Configuração de estágio de projeto&lt;context-param&gt; &lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt; &lt;param-value&gt;Development&lt;/param-value&gt;&lt;/context-param&gt;• Define o estágio do projeto, o que pode influenciar em alguns aspectos do sistema• Valores possíveis:– Development, UnitTest, SystemTest, Production• O padrão é Production• Configuração de armazenamento da view&lt;context-param&gt; &lt;param-name&gt;javax.faces.STATE_SAVING_METHOD&lt;/param-name&gt; &lt;param-value&gt;server&lt;/param-value&gt;&lt;/context-param&gt;• Define onde o JSF irá salvar o estados das views• Valores possíveis:– server, client• O padrão é server Baseado nos cursos da Softblue" }, { "title": "Conhecendo os Listeners - Jakarta EE", "url": "/posts/conhecendo-listeners-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-09-17 09:00:00 -0300", "snippet": "O que são Listeners• Os listeners permitem que o seu código seja avisado quando algum evento do seu interesse ocorre• Se você criar e registrar um listener, o container o invoca na presença de um evento• Existem oito tipos de listeners Interfaces dos Listeners ServletContextListener ServletContextAttributeListener ServletRequestListener ServletRequestAttributeListener HttpSessionListener HttpSessionAttributeListener HttpSessionBindingListener HttpSessionActivationListener Os listeners são interfaces. Basta implementar a interface desejada e registrá-laConfigurando um Listener• Para que o container saiba da existência do listener, é preciso registrá-lo no web.xml&lt;web-app&gt; &lt;listener&gt; &lt;listener-class&gt;listener.MyListener&lt;/listener-class&gt;&lt;!--Esta classe deve implementar uma das sete interfaces de listener--&gt; &lt;/listener&gt;&lt;/web-app&gt;Listeners e Annotations• Outra forma de configurar um listener é através de annotations@WebListener//@WebListener define que a classe é um listenerpublic class MyListener implements ServletContextListener { public void contextInitialized(ServletContextEvent e) { } public void contextDestroyed(ServletContextEvent e) { }}Listeners do Servlet Context• ServletContextListener Método Invocado quando… contextInitialized() A aplicação web está sendo iniciada contextDestroyed() A aplicação web está sendo terminada • ServletContextAttributeListener Método Invocado quando… attributeAdded() Um atributo é adicionado ao servlet context attributeRemoved() Um atributo é removido do servlet context attributeReplaced() Um atributo é substituído no servlet context Listeners do Servlet Request• ServletRequestListener Método Invocado quando… requestInitialized() A request está iniciando requestDestroyed() A request está terminando • ServletRequestAttributeListener Método Invocado quando… attributeAdded() Um atributo é adicionado à request attributeRemoved() Um atributo é removido da request attributeReplaced() Um atributo é substituído na request Listeners da HTTP Session• HttpSessionListener Método Invocado quando… sessionCreated() Uma session está sendo criada sessionDestroyed() Uma session está sendo invalidada • HttpSessionAttributeListener Método Invocado quando… attributeAdded() Um atributo é adicionado à session attributeRemoved() Um atributo é removido da session attributeReplaced() Um atributo é substituído na session • HttpSessionActivationListener Método Invocado quando… sessionDidActivate() Uma session está sendo trazida para a memória sessionWillPassivate() Uma session está sendo retirada da memória • Servidores de aplicações podem decidir o que fazer com dados da session• Remover da memória (armazenar em disco)• Migrar os dados para outra JVM (ambiente distribuído)• HttpSessionBindingListener– É o único listener que não precisa ser configurado• Nem no web.xml nem via @WebListener– Classes cujos objetos precisam ser notificados quando são adicionados ou removidos de uma session implementam esta interface Método Invocado quando… valueBound() O objeto é adicionado numa session valueUnbound() O objeto é removido de uma session Baseado nos cursos da Softblue" }, { "title": "Conhecendo os Filters - Jakarta EE", "url": "/posts/conhecendo-filters-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-09-10 09:00:00 -0300", "snippet": "FiltersOs clientes fazem requisições aos diversos servlets da aplicação.Como fazer para calcular o tempo levado em cada requisição?A requisição passa por um filtro antes de chegar aos servlets.O filtro implementa a lógica para calcular o tempo gasto em cada requisição.Podem existir mais de um filter que interceptam uma requisição.Os filters funcionam em cadeia: um filter chama o seu sucessor.A requisição é interceptada tanto na ida quanto na volta.Os Filters são transparentes: O filter não sabe da existência de outros filters; O cliente não sabe da existência dos filters; O servlet não sabe da existência dos filters.• Ninguém sabe que os filters existem– A não ser o container, que gerencia a chamada dos filters• Isto permite um desenvolvimento totalmente desacoplado– Filters podem ser colocados e retirados da cadeia de filters sem que seja necessário alterar códigoExemplos de Filters• Alguns exemplos do que pode ser feito com o uso de filters– Log– Auditoria– Verificação de segurança– Alterações na request e na responseCriando um Filter• A implementação de um filter é feita através da implementação da interface javax.servlet.Filter Método Quando é chamado… init() Quando o filter é iniciado destroy() Quando o filter é removido doFilter() Quando o filter intercepta a requisição • Assim como servlets, apenas uma instância de um filter existe em uma aplicaçãopublic class MyFilter implements Filter { private FilterConfig config; public void init(FilterConfig config) throws ServletException { //armazena o objeto FilterConfig this.config = config; } public void destroy() { //limpeza de recursos } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //faz algo antes de repassar a request chain.doFilter(request, response); //faz algo depois de receber a response }}Configurando um Filter• O filter deve ser registrado no web.xml para que o container possa carregá-lo&lt;web-app&gt; &lt;filter&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.LogFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;SecurityFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.SecurityFilter&lt;/filter-class&gt; &lt;/filter&gt;&lt;/web-app&gt;• Como o container sabe quando invocar determinado filter?– Através de mapeamentos de URL– Da mesma forma como acontece com servlets&lt;web-app&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--Intercepta todas as requisições--&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SecurityFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;&lt;!--Intercepta requisições em /admin--&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;Ordem de Carregamento• Se mais de um filter for mapeado para a mesma URL, o container usa a ordem da declaração dos filters no web.xml para definir a cadeia.Filters e Annotations• Filters também podem ser configurados através de annotations@WebFilter(\"/*\")//@WebFilter define um filter e o mapeamentopublic class LogFilter implements Filter { public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //código do filter } public void init(FilterConfig fConfig) throws ServletException { } public void destroy() { }}A definição de ordem só é possível através do web.xmlAspect Oriented Programming• Programação orientada a aspectos– AOP• Permite plugar funcionalidades no código– Estas funcionalidades são chamadas de aspectos• O código não possui conhecimento a respeito dos aspectos, o que permite habilitá-los e desabilitá-los sem que seja necessária qualquer alteração no código Baseado nos cursos da Softblue" }, { "title": "Conhecendo os Servlets - Jakarta EE", "url": "/posts/conhecendo-servlets-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-09-03 09:00:00 -0300", "snippet": "Introdução aos Servlets• Componente Java EE• Seu objetivo é atender requisições• Reside no servidor, dentro do web container• É controlado pelo container• O objeto do servlet é único na aplicação• Para atender requisições simultâneas, são usadas threads– Tomar cuidado, pois o mesmo objeto de servlet é compartilhado entre várias threads• Quando uma requisição ao servlet é feita, ele já foi previamente inicializadoCiclo de vida de um Servletgraph TD A[Não existe] --&gt;|\"construtor init()\"| B[Inicializado] B --&gt;|\"service()\"| B B --&gt;|\"destroy()\"| AOs servlets são instanciados pelo container, na primeira vez que são acessados.Após iniciados, os servlets podem atender requisições.O container decide a hora de destruir os servlets.Criando Servletsgraph LR A[MyServlet] --&gt; B[HttpServlet] B --&gt; C[GenericServlet] C -.-&gt; D[\"&lt; &lt; interface &gt; &gt; Servlet\"]public class MyServlet extends HttpServlet { public void init(ServletConfig config) throws ServletException { //inicialização do servlet } public void destroy() { //destruição do servlet } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //atendimento de requisição do tipo GET } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //atendimento de requisição do tipo POST }}Tratando GET e POST igualmentepublic class MyServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doIt(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doIt(request, response); } private void doIt(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //atendimento de requisição GET ou POST }}Outros tipos de requisições HTTP• Além de GET e POST, existem outros tipos, mas são menos usados HTTP Method Servlet Method HEAD doHead() TRACE doTrace() PUT doPut() DELETE doDelete() OPTIONS doOptions() CONNECT - A Interface HttpServletRequest• Representa a requisição feita pelo usuário• Alguns métodos importantes– Obter dados do HTTP request header• getHeaderNames()• getHeader(String)– Obtém informações submetidas de um formulário HTML (por GET ou por POST)• getParameter(String)A Interface HttpServletResponse• Representa a resposta que será enviada de volta ao cliente• Alguns métodos importantes– Colocar dados no HTTP response header• addHeader(String, String)– Definir o tipo de resposta• setContentType(String)– Obter referência ao canal de saída dos dados• getWriter()• getOutputStream()Configurando um Servlet• O arquivo web.xml é utilizado para configurar um servlet&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;Comprar&lt;/servlet-name&gt; &lt;servlet-class&gt;loja.servlet.ComprarServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Comprar&lt;/servlet-name&gt; &lt;url-pattern&gt;/ComprarServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;Como funciona o mapeamento Mapeamento Classe /ComprarServlet loja.servlet.ComprarServlet Inicialização automática• É possível definir que servlets devem ser inicializados junto com a aplicação• Ao ser inicializado, o init() é chamado&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;Comprar&lt;/servlet-name&gt; &lt;servlet-class&gt;loja.servlet.ComprarServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;/web-app&gt;• A tag load-on-startup permite ordenar a inicialização dos servlets&lt;servlet&gt; &lt;servlet-name&gt;Comprar&lt;/servlet-name&gt; &lt;servlet-class&gt;loja.servlet.ComprarServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;Listar&lt;/servlet-name&gt; &lt;servlet-class&gt;loja.servlet.ListarServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;Cadastrar&lt;/servlet-name&gt; &lt;servlet-class&gt;loja.servlet.CadastrarServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt;Passando parâmetros para Servlets• Ao inicializar os servlets, é possível passar parâmetros a eles através do arquivo web.xml&lt;servlet&gt; &lt;servlet-name&gt;Comprar&lt;/servlet-name&gt; &lt;servlet-class&gt;loja.servlet.ComprarServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;moeda&lt;/param-name&gt; &lt;param-value&gt;R$&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;• É possível fornecer mais de uma parâmetro usando a tag init-param várias vezesRecuperando os parâmetros• A recuperação dos parâmetros pode ser feita no código do servletServletConfig config = getServletConfig();String moeda = config.getInitParameter(\"moeda\");String moeda = getInitParameter(\"moeda\");• Caso o init() seja sobrescrito, é precisoinvocar o método da superclassepublic void init(ServletConfig config) throws ServletException { super.init(config); //...}• O método getInitParameterNames() permite ler todos os parâmetros do servletServletConfig config = getServletConfig();Enumeration&lt;String&gt; e = config.getInitParameterNames();while(e.hasMoreElements()) { String param = e.nextElement();}Servlets e annotations• Servlets podem ser configurados também via annotations@WebServlet(\"/Comprar\")//@WebServlet define que a classe é um servletpublic class ComprarServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //código do servlet }}• O atributo loadOnStartup define a inicialização automática@WebServlet(value = \"/Comprar\", loadOnStartup = 1)public class ComprarServlet extends HttpServlet { //...}• O atributo initParams permite definir parâmetros de inicialização para o servlet• Ele define um array de parâmetros, onde cada elemento é do tipo @WebInitParam@WebServlet(value = \"/ComprarServlet\", initParams = { @WebInitParam(name = \"moeda\", value = \"R$\"), @WebInitParam(name = \"pais\", value = \"Brasil\")})public class ComprarServlet extends HttpServlet { //...}Enviando uma resposta ao cliente• Depois que uma requisição é feita, o cliente (browser) aguarda uma resposta• Depois de processar a requisição, uma das opções é que o servlet gere a resposta• Como deve ser a resposta?– Normalmente é em formato HTML– Pode ser também qualquer outro tipo de formato, seja ele binário ou textoProduzindo uma resposta• O servlet acessa o canal de envio da resposta através do objeto HttpServletResponse//Resposta em formato textoPrintWriter out = response.getWriter();//out.print() é usado para enviar dados//Resposta em formato binárioOutputStream out = response.getOutputStream();//out.write() é usado para enviar dadosDefinindo um content-type• É preciso avisar ao cliente (browser) sobre o tipo de resposta que está sendo enviado• Isto é feito através do content-type, definido no HTTP response headerresponse.setContentType(\"text/html\"); Content Type Extensão Típica Formato text/html .htm .html HTML text/plain .txt Texto sem formatação image/gif .gif Imagem GIF image/jpeg .jpg Imagem JPEG image/x-png .png Imagem PNG application/pdf .pdf Documento PDF application/zip .zip Conteúdo compactado no formato ZIP Exemplo de Reposta HTMLpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html\"); PrintWriter out = null; try { out = response.getWriter(); out.print(\"&lt;HTML&gt;\"); out.print(\"&lt;HEAD&gt;\"); out.print(\"&lt;META http-equiv=\\\"Content-Type\\\" \" + \"content=\\\"text/html; charset=ISO-8859-1\\\" /&gt;\"); out.print(\"&lt;/HEAD&gt;&lt;BODY&gt;\"); out.print(\"&lt;H1&gt;Seja bem vindo!&lt;/H1&gt;\"); out.print(\"&lt;/BODY&gt;&lt;/HTML&gt;\"); } finally { if (out != null) { out.close(); } }}Exemplo de Resposta Bináriapublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"application/zip\"); OutputStream out = null; InputStream in = null; try { out = response.getOutputStream(); in = new FileInputStream(\"C:/Temp/java.zip\"); byte[] buffer = new byte[1024]; int numBytes; while((numBytes = in.read(buffer, 0, buffer.length)) &gt; -1) { out.write(buffer, 0, numBytes); } } finally { if (in != null) { in.close(); } if (out != null) { out.close(); } }} Baseado nos cursos da Softblue" }, { "title": "WebServices REST em Jakarta EE usando JAX-RS", "url": "/posts/webservices-rest-jakarta-jaxrs/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-08-27 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueRESTful WebServices• REST é um estilo arquitetural– Representational State Transfer• Um WebService é visto como um recurso (resource)• É identificado através de uma URI– Uniform Resource Identifier• WebServices que usam o estilo REST são conhecidos como RESTFul WebServicesURI: http://joaonogueira.dev/services/usersJSON:[{ id: 1, name: \"João\", email: \"contato@joaonogueira.dev\"},[{ id: 2, name: \"Paulo\", email: \"paulo@email.com\"}]JSON e XML são muito usadosOperações• O protocolo HTTP suporta várias operações– GET, POST, PUT, DELETE, etc.• RESTFul WebServices tiram vantagens dessas operações Operação Significado GET Ler um resource POST Criar um resource PUT Atualizar um resource DELETE Excluir um resource       /services/user/17 GET Retorna os dados do usuário com ID 17 /services/users POST Cadastra um novo usuário (os dados são enviados no corpo do HTTP) /services/user/17 PUT Atualiza os dados do usuário com ID 17 (os dados são enviados no corpo do HTTP) /services/user/17 DELETE Exclui o usuário com ID 17 /services/users GET Retorna os dados de todos os usuários Status do HTTP• Toda requisição HTTP a um servidor resulta em uma resposta (status) Status Descrição 200 OK 201 Created 400 Bad Request 403 Forbidden 404 Not Found 500 Internal Server Error MIME Types• O MIME Type é o tipo de dado que está sendo transportado pelo protocolo HTTP• É a forma do cliente e do servidor se “entenderem”– O cliente envia no header da requisição HTTP qual o MIME Type dos dados que ele está enviando ao servidor– O servidor envia no header da resposta do HTTP o MIME Type referente aos dados que ele está enviando ao cliente• Os MIME Types são padronizados• Alguns dos MIME Types mais comuns usados na troca de dados em WebServices: MIME TYPE Descrição application/json JSON application/xml XML text/plain Texto puro text/html HTML A API JAX-RS• O JAX-RS é uma API que pertence ao Java EE• Permite criar RESTful WebServices de forma fácil, rápida e intuitivaCriando Web Services com JAX-RS• É preciso definir o caminho raiz onde os WebServices da aplicação vão responder@ApplicationPath(\"/services\")//Define a URI base /services/*public class JAXRSConfig extends Application {}• Uma classe Java é usada para definir o WebService@Path(\"/users\")//Define a URI do serviço como /userspublic class UserService {@GET//Método chamado na operação GET@Produces(MediaType.APPLICATION_JSON)//Retorna os dados no formato JSONpublic List&lt;User&gt; list() { //...}A URI é: /services/users@Produces &amp; @Consumes• Ao criar um WebService, é preciso informar que tipo de informação ele consome e que tipo de informação ele produz@GET@Produces(MediaType.APPLICATION_JSON)//Envia JSON para o clientepublic List&lt;User&gt; list() { //...}@POST@Consumes(MediaType.TEXT_PLAIN)//Recebe TEXTO do clientepublic void create(String txt) { //...}Path Parameters• É possível fornecer parâmetros para o WebService diretamente na URI@Path(\"/users\")public class UserService {@GET@Path(\"/{userId}\")@Produces(MediaType.APPLICATION_JSON)public User find(@PathParam(\"userId\") int id) { //...}A URI é: /services/users/20 (o 20 é passado como parâmetro para o método find())Query Parameters• É possível fornecer parâmetros para o WebService via query string@Path(\"/users\")public class UserService {@GET@Produces(MediaType.APPLICATION_JSON)public User find(@QueryParam(\"userId\") int id) { //...}A URI é: /services/users?userId=20 (o 20 é passado como parâmetro para o método find())Cliente para RESTFul Web Services• O JAX-RS permite fazer requisições a WebServices existentes a partir da interface ClientUser user = ClientBuilder.newClient() .target(URI) .path(\"15\") .request(MediaType.APPLICATION_JSON) .get(User.class);• Para as operações de POST, PUT e DELETE é comum o retorno do tipo ResponseReponse response = ClientBuilder.newClient() .target(URI) .path(\"15\") .request() .delete();O objeto Response permite recuperar o status HTTP da resposta e outras informações relevantes" }, { "title": "WebSockets em Jakarta EE", "url": "/posts/websockets-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-08-20 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueWebSockets• Habilitam a comunicação de duas vias entre o cliente e o servidorgraph TD subgraph Tradicional A[fa:fa-desktop Cliente] --&gt;|\"requisição (HTTP)\"| B[fa:fa-server Servidor] B --&gt;|\"resposta (HTTP)\"| A end subgraph WebSockets C[fa:fa-desktop Cliente] &lt;--&gt;|\"canal de comunicação (TCP)\"| D[fa:fa-server Servidor] D &lt;--&gt;|\"canal de comunicação (TCP)\"| C end Servidor: Endpoint• No Java EE, o servidor de um WebSocket é definido com a anotação @ServerEndpoint• Métodos devem ser anotados e são chamados automaticamente durante o ciclo de vida da sessão do usuário– @OnOpen– @OnClose– @OnError– @OnMessage@ServerEndpoint(\"/server\")//URIpublic class MyEndpoint { @OnOpen public void onOpen(Session session, EndpointConfig conf) { } @OnClose public void onClose(Session session, CloseReason reason) { } @OnError public void onError(Session session, Throwable t) { } @OnMessage public void onMessage(Session session, String message) { }}Os métodos podem ter qualquer nomeExiste uma instância do endpoint para cada sessãoServidor: Enviando Mensagens• O endpoint se comunica com o cliente através do objeto Session@OnMessagepublic void messageReceived(Session session, String message) { session.getBasicRemote().sendText(\"Alguma mensagem\");}Servidor: Mensagens Binárias• Além de mensagens de texto, é possível enviar mensagens binárias tambémsession.getBasicRemote().sendBinary(buffer);//ByteBuffer@OnMessagepublic void bytesMessage(Session session, ByteBuffer buffer) { ...}Path Parameters• Permitem o uso de padrões de URI de WebSockets que podem sofrer variação@ServerEndpoint(\"/server/{some-id}\")public class MyEndpoint { ...}//ws://localhost:8080/App/server/xyz@OnOpenpublic void open(Session session, EndpointConfig c, @PathParam(\"some-id\") String id) {//O valor xyz é passado como parâmetro ...}A Anotação @PathParam• A anotação @PathParam suporta– Classe String– Tipos primitivos– Classes wrappers• Métodos que suportam o uso da anotação @PathParam– @OnOpen– @OnClose– @OnMessageServidor: Encoders &amp; Decoders• Permitem converter os dados automaticamente quando chegam ou saem do servidorgraph LR subgraph . A(fa:fa-desktop Cliente) --- B[String] B --&gt;|\"send()\"| C[String] --&gt; D(fa:fa-server Servidor) D --&gt; F[String] --&gt;|\"send()\"| E[String] --- A end subgraph .. G(fa:fa-desktop Cliente) --- H[String] H --&gt;|\"send()\"| I[String] subgraph Decoder M[ABC] N[ABC] end I --&gt; M --&gt; J(fa:fa-server Servidor) J --&gt; N --&gt; L[String] --&gt;|\"send()\"| K[String] --- G end Servidor: Decoderpublic class MessageDecoder implements Decoder.Text&lt;Message&gt; {//tipo customizado public void init(EndpointConfig ec) { } public void destroy() { } public Message decode(String string) throws DecodeException {//Converte para o tipo customizado ... } public boolean willDecode(String string) { ... }}Servidor: Encoderpublic class MessageEncoder implements Encoder.Text&lt;Message&gt; {//tipo customizado public void init(EndpointConfig ec) { } public void destroy() { } public String encode(Message msg) throws EncodeException {//Converte para String ... }}Servidor: Configurando Encoders &amp; Decoders• Os encoders e decoders são configurados na anotação @ServerEndpoint@ServerEndpoint( value = \"/server\", encoders = { MessageEncoder.class }, decoders = { MessageDecoder.class })• O método que recebe as mensagens deve ter a assinatura correspondente@OnMessage public void onMessage(Session session, Message message) {//Quando o método for chamado, o decoder já entrou em áção ...}• O envio de mensagens é feito através do método sendObject()Message msg = new Message();...session.getBasicRemote().sendObject(msg);Servidor: Informações de Usuário• Uma sessão pode armazenar informações específicas do usuáriosession.getUserProperties().put(\"nome\", \"João\");//Map&lt;String, Object&gt;String nome = (String) session.getUserProperties().get(\"nome\");Cliente: JavaScript API• Aplicações web podem usar a API do JavaScript de cliente de WebSocket– Navegadores modernos com suporte à HTML5var websocket = new WebSocket(\"ws://localhost:8080/app/server\");//Inicia a conexãowebsocket.onopen = function(event) {//Conexão estabelecida ...};websocket.onmessage = function(event) {//Mensagem recebida ...};websocket.onerror = function(event) {//Ocorreu um erro ...};Cliente: Enviando Mensagens• O cliente pode enviar uma mensagem ao servidorwebsocket.send(\"Minha mensagem\");" }, { "title": "Binding de JSON e Objetos usando a API JSON-B - Jakarta EE", "url": "/posts/binding-json-objetos-api-jsonb-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-08-13 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueJSON-B• A API JSON-B (JSON Binding) permite um mapeamento automático entre objetos Java e documentos JSONCadastro c = new Cadastro();c.setNome(\"Marcos\");c.setIdade(28);{\"nome\": \"Marcos\",\"idade\": 28}Usando a API JSON-B• Criar documentos JSONCadastro c = new Cadastro();c.setNome(\"Marcos\");c.setIdade(28);Jsonb jsonb = JsonbBuilder.create();String json = jsonb.toJson(cadastro);• Parse de documentos JSONJsonb jsonb = JsonbBuilder.create();Cadastro cadastro = jsonb.fromJson(jsonStr, Cadastro.class);Customizando as Propriedades• Por padrão, o JSON-B usa o nome dos atributos da classe na manipulação do documento JSON• Esse comportamento pode ser alteradopublic class Cadastro { @JsonbProperty(\"nome-da-pessoa\")//Define outro nome private String nome; ...}" }, { "title": "Processamento com a API JSON-P - Jakarta EE", "url": "/posts/processamento-api-jsonp-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-08-06 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueO Formato JSON• Formato de troca de dados– Muito usado em web services e outras aplicações que se comunicam pela internet• Inspirado no JavaScript– JavaScript Object Notation• Baseado em texto• Possui 2 estruturas de dados– Objetos {}• Conjunto de pares de chave e valor– Arrays []• Lista de valores• Possui 2 tipos de dados– string– number• JSON x XML– JSON é mais compacto– XML possui recursos para validação de dados (XML Schema e DTD){ \"nome\": \"João\", \"sobrenome\": \"Alencar\", \"idade\": 33, \"endereco\" : { \"rua\" : \"Rua. dos Limões\", \"numero\" : 200, \"cidade\" : \"São Paulo\" }, \"telefones\": [ { \"Celular\": \"22 2222-2222\" }, { \"Residencial\": \"11 1111-1111\" } ]}JSON-P• API do Java EE para processamento de documentos JSON (geração e parsing)• 2 APIs– Object Model API• Cria uma árvore do documento inteiro em memória– Streaming API• Baseado em eventosJSON-P: Object Model API• Criar um documento JSONJsonObject rootObj = Json.createObjectBuilder() .add(\"nome\", \"João Almeida\") .add(\"idade\", 30) .add(\"endereco\", Json.createObjectBuilder() .add(\"rua\", \"Rua dos Abacates\") .add(\"numero\", 50).build() .build();• Gravar em uma saídaStringWriter out = new StringWriter();try (JsonWriter jsonWriter = Json.createWriter(out)) { jsonWriter.writeObject(rootObj);}• Parse de um documento JSONJsonObject rootObj;StringReader in = new StringReader(jsonStr));try (JsonReader jsonReader = Json.createReader(in)) { rootObj = jsonReader.readObject();}String nome = rootObj.getString(\"nome\");int idade = rootObj.getInt(\"idade\");JSON-P: Streaming API• Criar um documento JSONStringWriter out = new StringWriter();try (JsonGenerator g = Json.createGenerator(out)) { g.writeStartObject() .write(\"nome\", \"Pedro Silva\") .write(\"idade\", 32) .writeStartObject(\"endereco\") .write(\"rua\", \"Rua do Java\") .write(\"numero\", 100) .writeEnd() .writeEnd();}• Parse de um documento JSONJsonParser parser = Json.createParser(new StringReader(jsonStr));while (parser.hasNext()) { Event event = parser.next(); switch (event) { case KEY_NAME: /* ... */ break; case VALUE_STRING: /* ... */ break; case VALUE_NUMBER: /* ... */ break; case VALUE_TRUE: /* ... */ break; case VALUE_FALSE: /* ... */ break; case VALUE_NULL: /* ... */ break; case START_ARRAY: /* ... */ break; case END_ARRAY: /* ... */ break; case START_OBJECT: /* ... */ break; case END_OBJECT: /* ... */ break; }}Object Model API x Streaming API• Object Model API– Vantagens• Manipulação dos dados é mais fácil e intuitiva– Desvantagem• É mais lenta e ocupa mais memória• Streaming API– Vantagem• E mais rápida e não ocupa tanta memória– Desvantagem• A manipulação dos dados é pouco intuitiva e mais complexa" }, { "title": "Controle Transacional em EJBs - Jakarta EE", "url": "/posts/controle-transacional-ejb-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-07-30 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueTransações• Uma transação é um conjunto atômico de operações– TUDO é executado ou NADA é executado• O objetivo é manter a consistência das informaçõesCOMMIT: Efetiva as mudanças no BDROLLBACK: Desfaz as mudanças anterioresTransações em Java EE• O Java EE tem um serviço de gerenciamento de transações• Este gerenciamento pode ser de 2 tipos:– CMT (Container-Managed Transactions)• Gerenciadas pelo EJB container– BMT (Bean-Managed Transactions)• Gerenciadas manualmente, via programaçãoContainer-Managed Transactions• São gerenciadas pelo container• Suportadas por EJBs– Session Beans e Message-Driven Beans• A transação começa quando o método inicia e encerra quando o método termina– O desenvolvedor não precisa demarcar a transação• É o tipo padrão de gerenciamento dos EJBs@Statelesspublic class MyBean { @PersistenceContext private EntityManager em; public void m1() {//Se o método terminar normalmente: COMMIT //OP 1 //OP 2 //OP 3}public void m2() {//Se o método lançar uma system exception: ROLLBACK //OP 1 //OP 2 //OP 3}}Rollback em CMT• Existem 2 formas de executar um rollback– Lançar uma system exception a partir do método do EJB– Chamar o método setRollbackOnly()@Statelesspublic class MyBean { @PersistenceContext private EntityManager em; @Resource private EJBContext ejbContext; public void m1() { //OP 1 //OP 2 ejbContext.setRollbackOnly(); }}Transaction Attributes• Controlam o escopo da transação– O que acontece com a transação quando um método chama outro método• Tipos– Required– Requires New– Mandatory– Not Supported– Supports– Never• Uso da anotação @TransactionAttribute– Na classe• Todos os métodos do EJB vão usar este transaction attribute– No método• Apenas o método anotado do EJB vai usar este transaction attribute• Se a anotação existir na classe e no método, o que foi definido no método tem precedênciaAttribute: RequiredAttribute: Requires NewAttribute: MandatoryAttribute: Not SupportedAttribute: SupportsAttribute: NeverBean-Managed Transactions• São gerenciadas pelo desenvolvedor, via programação• Permitem um controle mais fino a respeito do escopo da transação– Métodos que usam CMT são limitados: ou o método inteiro executa em uma transação ou em nenhuma@Stateless@TransactionManagement(TransactionManagementType.BEAN)//Define o bean como BMTpublic class MyBean { @Resource private UserTransaction ut;//Gerenciamento da transação public void m1() { ut.begin();//Inicia a transação try { ... ... ut.commit();//commit() e rollback() encerram a transação } catch(Exception e) { ut.rollback(); } }}Extended Persistence Context• O manuseio de entidades na JPA é feito de um contexto de persistência• Por padrão, esse contexto tem o mesmo tempo de duração da transação@Statelesspublic class MyBean { @PersistenceContext private EntityManager em; public void m1() { ... ... ... }}Assim que a transação termina, o contexto de persistência é encerradoTodas as entidades gerenciadas pela JPA são desatachadas• Esse comportamento pode ser alterado@Statefulpublic class MyBean { @PersistenceContext(type = PersistenceContextType.EXTENDED) private EntityManager em; public void m1() { ... ... ... }}O ciclo de vida do contexto de persistência é o mesmo do EJBChamadas subsequentes de métodos usam o mesmo contexto de persistênciaSó tem sentido em Stateful Session BeansEJBs &amp; Exceções• Existem 2 tipos de exceções– System Exception• RuntimeExcetion (ou subclasse)• RemoteException (ou subclasse)– Application Exception• As outras que não são system exceptions• Quando uma exceção é lançada, o que o EJB container faz?– System Exception• Se houver uma transação ativa – Rollback da transação – Empacota a exceção em uma exceção do tipo EJBTransactionRolledBackException e lança• Se não houver uma transação ativa – Empacota a exceção em uma exceção do tipo EJBException ou RemoteException e lança– Application Exception• Lança a exceção (sem empacotar)• É possível fazer com que uma system exception se comporte como uma application exception@ApplicationException(rollback = true)public class MyException extends RuntimeException {//...}• Quando um bean lança uma system exception, a instância dele é destruída– Session Beans• Stateful• Stateless– Message-Driven Beans" }, { "title": "Buscando Dados com JPQL & Criteria API - Jakarta EE", "url": "/posts/buscando-dados-jpql-criteria-api-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-07-23 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueJPQL• Java Persistence Query Language• Linguagem para busca de entidades– Bastante semelhança com o SQL, usado em bancos de dados relacionais• A JPQL referencia apenas entidades– Não referencia tabelas ou colunas presentes no banco de dados• Buscar todas as contas correntesSELECT c FROM ContaCorrente c• Buscar contas correntes com limite superior a 1000SELECT c FROM ContaCorrente c WHERE c.limite &gt; 1000• Buscar os nomes dos titulares de contas da agência 3456SELECT c.titularConta FROM ContaCorrente c WHERE c.numAgencia = 3456• Buscar a quantidade de contas do titular José SilvaSELECT COUNT(c) FROM ContaCorrente c WHERE c.titularConta = 'José Silva'• Buscar a soma dos saldos das contas correntes, agrupada por agênciaSELECT c.numAgencia, SUM(c.saldo) FROM ContaCorrente c GROUP BY c.numAgencia ORDER BY c.numAgenciaRelacionamentos e a JPQL• A linguagem JPQL também suporta relacionamentos• Os relacionamentos podem ser expressos de duas formas– Usando o “.”, como acontece com qualquer propriedade de uma entidade• Possível em relacionamentos um-para-um e muitos-para-um– Usando o conceito de join, similar ao aplicado na linguagem SQL• [INNER] JOIN• LEFT [OUTER] JOIN• RIGHT [OUTER] JOINclassDiagram class Pedido{ -cliente: Cliente } class Cliente{ -pedidos: List&lt;Pedido&gt; } Pedido \"*\" -- \"1\" ClienteSELECT p FROM Pedido p WHERE p.cliente.nome = 'Pedro'SELECT p FROM Pedido p INNER JOIN p.cliente c WHERE c.nome = 'Pedro'SELECT p FROM Cliente c INNER JOIN c.pedidos p WHERE c.nome = 'Pedro'EAGER na JPQL• Através da linguagem JPQL, é possível fazer com que relacionamentos definidos como LAZY se comportem como EAGERSELECT c FROM Cliente c INNER JOIN c.pedidos pWHERE c.nome = 'Pedro' /*Relacionamento LAZY*/SELECT c FROM Cliente c INNER JOIN FETCH c.pedidos pWHERE c.nome = 'Pedro' /*O uso do FETCH força o carregamento das entidades (modo EAGER)*/Buscando Entidades• O EntityManager possui o método createQuery(), que permite o uso da JPQLQuery q = em.createQuery(\"SELECT p FROM Pedido p\"); //@SuppressWarnings(\"unchecked\")List&lt;Pedido&gt; pedidos = q.getResultList();TypedQuery&lt;Pedido&gt; q = em.createQuery(\"SELECT p FROM Pedido p\", Pedido.class);List&lt;Pedido&gt; pedidos = q.getResultList();• Se você souber que o resultado da query retorna 1 resultado, você pode simplificarTypedQuery&lt;Pedido&gt; q = em.createQuery(\"SELECT p FROM Pedido p\", Pedido.class);Pedido pedido = q.getSingleResult();Parâmetros em Queries JPQL• A JPQL suporta o uso de parâmetrosTypedQuery&lt;Integer&gt; q = em.createQuery( \"SELECT p.id FROM Pedido p WHERE p.valor &gt; :valor\", Integer.class) .setParameter(\"valor\", 1000)//Parâmetros nomeados .setMaxResults(5);List&lt;Integer&gt; ids = q.getResultList();TypedQuery&lt;Integer&gt; q = em.createQuery( \"SELECT p.id FROM Pedido p WHERE p.valor &gt; ?1 and p.pais LIKE ?2\", Integer.class)//Parâmetros posicionais .setParameter(1, 500) .setParameter(2, \"B%\");List&lt;Integer&gt; ids = q.getResultList();Named Queries• A JPA suporta o uso de queries nomeadas• Devem ser declaradas em uma entidade@NamedQuery(name = \"All\", query = \"SELECT p FROM Pedido p\")public class Pedido { }@NamedQueries({ @NamedQuery(name = \"All\", query = \"SELECT p FROM Pedido p\"), @NamedQuery(name = \"Free\", query = \"SELECT p FROM Pedido p WHERE p.valor = 0\")})public class Pedido { }• A execução de uma named query é parecida com a de qualquer query JPQLTypedQuery&lt;Pedido&gt; q = em.createNamedQuery(\"All\", Pedido.class);List&lt;Pedido&gt; pedidos = q.getResultList();Update &amp; Delete com JPQL• A JPQL suporta a atualização e exclusão de registros em lote, de acordo com os critérios desejadosQuery q = em.createQuery( \"UPDATE Pedido p SET p.valor = 100 WHERE p.valor = 50\");q.executeUpdate();Query q = em.createQuery( \"DELETE FROM Pedido p WHERE p.valor = 20\");q.executeUpdate();Criteria API• É uma API que permite que você busque dados, de forma semelhante à JPQL• É baseada em uma objetos e métodos, e não em Strings como a JPQL– Esta é uma vantagem, pois a query já é checada durante a compilação• A Criteria API é mais verbosaPassos Para Usar a Criteria API• Exemplo de query– Listar os números de contas bancárias cujo saldo seja inferior a R$ 5000, e ordená-las por ordem decrescente de saldo• Em JPQL:SELECT c.numeroFROM ContaBancaria cWHERE c.saldo &lt; 5000ORDER BY c.saldo DESC• Usando a Criteria API: Obter um CriteriaBuilderCriteriaBuilder cb = em.getCriteriaBuilder(); Criar um CriteriaQueryCriteriaQuery&lt;String&gt; cq = cb.createQuery(String.class); Definir o FROMRoot&lt;ContaBancaria&gt; contaBancaria = cq.from(ContaBancaria.class); Definir o SELECTcq.select(contaBancaria.get(ContaBancaria_.numero)); Definir o WHEREcq.where(cb.lessThan(contaBancaria.get(ContaBancaria_.saldo), 5000.0)); Definir o ORDER BYcq.orderBy(cb.desc(contaBancaria.get(ContaBancaria_.saldo))); Executar a queryTypedQuery&lt;String&gt; q = em.createQuery(cq);List&lt;String&gt; result = q.getResultList();Exemplo usando JOINJPQLSELECT cc.saldoFROM ContaBancaria cc INNER JOIN cc.cliente cWHERE c.nome = 'Carlos' ORDER BY cc.saldo ASCCriteria APICriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Double&gt; cq = cb.createQuery(Double.class);Root&lt;ContaBancaria&gt; contaBancaria = cq.from(ContaBancaria.class);Join&lt;ContaBancaria, Cliente&gt; cliente = contaBancaria.join(ContaBancaria_.cliente);cq.select(contaBancaria.get(ContaBancaria_.saldo));cq.where(cb.equal(cliente.get(Cliente_.nome), \"Carlos\"));cq.orderBy(cb.asc(contaBancaria.get(ContaBancaria_.saldo)));TypedQuery&lt;Double&gt; q = em.createQuery(cq);List&lt;Double&gt; result = q.getResultList();Métodos de CriteriaBuilder• Métodos condicionais Método Descrição equal() Testa se duas expressões são iguais notEqual() Testa se duas expressões são diferentes greaterThan() Testa se a primeira expressão numérica é maior do que a segunda expressão numérica greaterThanOrEqualTo() Testa se a primeira expressão numérica é maior ou igual à segunda expressão numérica lessThan() Testa se a primeira expressão numérica é menor do que a segunda expressão numérica lessThanOrEqualTo() Testa se a primeira expressão numérica é menor ou igual à segunda expressão numérica between() Testa se a primeira expressão está entre dois valores like() Testa se a expressão possui determinado padrão • Métodos de composição de predicados Método Descrição and() Aplica o operador E em duas expressões lógicas or() Aplica o operador OU em duas expressões lógicas not() Nega uma expressão lógica Metamodel API• Possibilita o acesso às propriedades das entidades com verificação durante a compilaçãoJoin&lt;ContaBancaria, Cliente&gt; cliente = contaBancaria.join(\"cliente\");cq.select(contaBancaria.get(\"saldo\"));cq.where(cb.equal(cliente.get(\"nome\"), \"Carlos\"));cq.orderBy(cb.asc(contaBancaria.get(\"saldo\")));//Problema de execução se alguma propriedade mudar de nomeJoin&lt;ContaBancaria, Cliente&gt; cliente = contaBancaria.join(ContaBancaria_.cliente);cq.select(contaBancaria.get(ContaBancaria_.saldo));cq.where(cb.equal(cliente.get(Cliente_.nome), \"Carlos\"));cq.orderBy(cb.asc(contaBancaria.get(ContaBancaria_.saldo)));//Se alguma propriedade mudar de nome, o erro ocorre na compilaçãoClasses de Metamodel• É comum que a IDE gere as classes de Metamodel relacionadas às entidades@Entitypublic class ContaBancaria { @Id private Integer id; private String numero; private String agencia; private Double saldo; @ManyToOne private Cliente cliente; // getters &amp; setters}@Generated@StaticMetamodel(ContaBancaria.class)public class ContaBancaria_ { public static SingularAttribute&lt;ContaBancaria, String&gt; numero; public static SingularAttribute&lt;ContaBancaria, Integer&gt; id; public static SingularAttribute&lt;ContaBancaria, String&gt; agencia; public static SingularAttribute&lt;ContaBancaria, Cliente&gt; cliente; public static SingularAttribute&lt;ContaBancaria, Double&gt; saldo;}" }, { "title": "Herança nas Entidades - Jakarta EE", "url": "/posts/heran%C3%A7a-entidades-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-07-16 09:00:00 -0300", "snippet": " Baseado nos cursos da Softblue@MappedSuperclass• Uma entidade pode herdar propriedades de uma superclasse– Ela deve ser anotada com @MappedSuperclass@MappedSuperclass//Não é gerada uma tabela Pessoapublic class Pessoa { @Id private Integer id; // getters &amp; setters...}@Entity(name = \"PFISICA\")public class PessoaFisica extends Pessoa { private String cpf; // getters &amp; setters...}classDiagram class PFISICA{ integer id varchar(255) cpf }@Entity(name = \"PJURIDICA\")public class PessoaJuririca extends Pessoa { private String cnpj; // getters &amp; setters...}classDiagram class PJURIDICA{ integer id varchar(255) cnpj }Herança de Uma Classe “Normal”• Uma entidade pode herdar de uma classe “normal”– Que não é uma entidade– Que é não é uma @MappedSuperclass• Neste caso, as propriedades que não pertencem à entidade não poderão ser persistidaspublic class Pessoa { private String nome;//O atributo nome não é mapeado para o BD}@Entity(name = \"PFISICA\")public class PessoaFisica extends Pessoa { @Id private Integer id; private String cpf;}@Entity(name = \"PJURIDICA\")public class PessoaJuririca extends Pessoa { @Id private Integer id; private String cnpj;}Herança Entre Entidades• Uma entidade pode herdar de outra• No BD, o mapeamento da herança pode seguir uma das seguintes estratégias– Uma tabela por hierarquia de classes– Uma tabela por entidade– Uma tabela por subclasse (com possibilidade de realizar um join entre tabelas)• Uma tabela por hierarquia de classes@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE)//@Inheritance define a estratégiapublic abstract class Pessoa { @Id @GeneratedValue private Integer id; private String nome;}Se @Inheritance não for especificada, SINGLE_TABLE é usada por padrão@Entitypublic class PessoaFisica extends Pessoa { private String cpf;}@Entitypublic class PessoaJuridica extends Pessoa { private String cnpj;}DTYPE Indica o tipo da entidade (PessoaFisica ou PessoaJuridica)classDiagram class PESSOA{ varchar(31) DTYPE integer id varchar(255) nome varchar(255) cpf varchar(255) cnpj }• Uma tabela por entidade@Entity@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)public abstract class Pessoa { //...}As colunas se repetem em cada tabelaDependendo do persistence provider que você use, esta estratégia pode não estar disponívelclassDiagram class PFISICA{ integer id varchar(255) nome varchar(255) cpf } class PJURIDICA { integer id varchar(255) nome varchar(255) cnpj }• Uma tabela por subclasse@Entity@Inheritance(strategy = InheritanceType.JOINED)public abstract class Pessoa { //...}As tabela das subclasses referenciam a tabela da superclasseclassDiagram class PESSOA{ integer id varchar(255) nome } class PFISICA{ integer id varchar(255) cpf } class PJURIDICA { integer id varchar(255) cnpj } PESSOA &lt;.. PFISICA PESSOA &lt;.. PJURIDICAConfigurando a Coluna DTYPE@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumn( name = \"TIPO\",//Nome da coluna discriminatorType = DiscriminatorType.INTEGER,//Tipo do discriminador (STRING, INTEGER, CHAR) length = 5)//Tamanho do campopublic abstract class Pessoa { //...}@Entity@DiscriminatorValue(\"1\")//Define o valor a ser usado no discriminadorpublic class PessoaFisica extends Pessoa { //...}" }, { "title": "Relacionamentos na JPA - Jakarta EE", "url": "/posts/relacionamentos-jpa-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-07-09 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueRelacionamentos em JPA• O JPA é capaz de trabalhar com relacionamentos entre entidades– Em orientação a objetos, um relacionamento existe quando um objeto da classe A possui um atributo que referencia um objeto B, de outra classe– No modelo relacional, um relacionamento existe quando uma tabela A referencia uma tabela B através de uma chave estrangeira (foreign key)Definindo Relacionamentos• Os relacionamentos são definidos nas entidades através de anotações Annotation Tipo de Relacionamento @OneToOne Um-para-Um @OneToMany Um-para-Muitos @ManyToOne Muitos-para-Um @ManyToMany Muitos-para-Muitos • Outras anotações utilizadas em relacionamentos Annotation Tipo de Relacionamento @JoinColumn Coluna para chave estrangeira @JoinTable Tabela auxiliar para o join pedido.java@OneToOne@JoinColumn(name = \"pagamento_id\")private Pagamento pagamento;@ManyToOne@JoinColumn(name = \"cliente_id\", nullable = false)private Cliente cliente;@ManyToMany@JoinTable(name = \"PEDIDO_PRODUTO\", joinColumns = @JoinColumn(name = \"pedido_id\"), inverseJoinColumns = @JoinColumn(name = \"produto_id\"))private List&lt;Produto&gt; produtos;Navegabilidade dos Relacionamentos• Relacionamentos unidirecionais– É possível navegar do lado A para o B– Não é possível navegar do lado B para o A• Relacionamentos bidirecionais– É possível navegar do lado A para o B– É possível navegar do lado B para o ADono do Relacionamento• Em relacionamentos bidirecionais, um dos lados do relacionamento é o dono do relacionamento (relationship owner) Tipo Dono Um-para-Um Lado que possui a chave estrangeira (foreign key) Um-para-Muitos Lado “muitos” Muitos-para-Um Lado “muitos” Muitos-para-Muitos A critério da aplicação Relacionamentos Eager e Lazy• Quando uma entidade que possui relacionamentos é carregada, a JPA permite duas abordagens– Carregar automaticamente as entidades dos relacionamentos (EAGER)– Carregar os relacionamentos apenas quando eles forem necessários (LAZY)– A JPA assume um padrão• @OneToOne e @ManyToOne = EAGER• @OneToMany e @ManyToMany = LAZYpublic class Pedido { @OneToOne(fetch = FetchType.EAGER)//O pagamento será carregado automaticamente private Pagamento pagamento;public class Pedido { @OneToOne(fetch = FetchType.LAZY)//O pagamento não será carregado automaticamente, Será carregado apenas quando for utilizado private Pagamento pagamento;public class Cliente { @OneToMany(fetch = FetchType.EAGER)//Os pedidos serão carregados automaticamente private List&lt;Pedido&gt; pedidos;public class Cliente { @OneToMany(fetch = FetchType.LAZY)//Os pedidos não serão carregados automaticamente. Serão carregados apenas quando forem utilizados private List&lt;Pedido&gt; pedidos;• Entre EAGER ou LAZY, não existe uma opção melhor ou pior– Vai depender de cada situação• EAGER– Reduz o acesso ao banco de dados para leitura de dados– Ocupa mais memória• LAZY– É preciso fazer vários acessos ao banco de dados para obter os dados conforme a necessidade– Ocupa menos memória" }, { "title": "Arquitetura & Entidades da JPA - Jakarta EE", "url": "/posts/arquitetura-entidades-jpa-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-07-02 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueJPA – Java Persistence API• A integração entre aplicações e bancos de dados relacionais é muito comum• O problema é que aplicações e bancos de dados “falam línguas diferentes”graph TD A(Aplicação - Modelo orientado a objetos) --- B((\"JPA (Java Persistence API)\")) --&gt; C(Bando de dados - Modelo relacional) C --- B --&gt; AA especificação Java EE e o ORM• Nas primeiras versões do Java EE (chamado de J2EE), a persistência de dados era feita pelos componentes denominados entity beans – Os entity beans eram complexos e limitados• Em paralelo, surgiu o Hibernate – Permitia usar todas as facilidades da orientação a objetos a favor do ORM– Open source• A JPA foi criada com base no Hibernate e foi incorporada na plataforma a partir do Java EE 5Especificação da JPA• A JPA é uma especificação – É apenas um documento com diretrizes para implementação da JPA• As implementações da JPA são chamadas de persistence providers– EclipseLink (implementação de referência)– Hibernate• Todas as implementações que seguem a especificação da JPA funcionam da mesma formaEntidades• Em orientação a objetos, chamamos as instâncias de classes de objetos• No mundo ORM, os objetos que representam dados persistidos em tabelas do banco de dados são chamados de entidades (entities)Criando Entidades• Exemplo de implementação de uma entidade@Entity //@Entity define a classe como sendo uma entidadepublic class ContaCorrente { @Id//@Id define o ID da entidade @GeneratedValue//@GeneratedValue determina que o ID deve ser gerado automaticamente private Integer id; private String titularConta; private String numConta; private Integer numAgencia; private Double limite; // getters &amp; setters...}Regras Para Uma Entidade• Classe anotada com @Entity• Construtor sem parâmetros (public ou protected)• Deve implementar Serializable– Se for usada por interfaces remotas de EJBs– For usada em um JSF Bean com escopo de sessão• Os atributos não podem ser públicos– Podem ser acessados externamente apenas através de getters e setters• Deve ter um ID (chave primária)Tipos de Persistência• Persistent fields – As annotations são realizadas nos atributos@Entitypublic class ContaCorrente { @Id private Integer id;}• Persistent properties – As annotations são realizadas nos métodos getters@Entitypublic class ContaCorrente { @Id public Integer getId() { return id; }}Chaves Primárias em Entidades• Toda entidade precisa ter um identificador único– Assim a entidade pode ser encontrada• A chave pode ser simples ou composta– Simples• Annotation @Id– Composta• Classe específica pra representar a chave• Annotations @IdClass e @IdClasse de Chave Primária Composta• A classe deve ter um construtor público sem parâmetros• Deve implementar Serializable• Deve implementar os métodos hashCode() e equals()public class LivroPK implements Serializable { private String titulo; private String autor; public LivroPK() { } public boolean equals(Object o) { } public int hashCode() { } // getters &amp; setters...}Definindo os IDs@Entity@IdClass(LivroPK.class)//@IdClass define o nome da classe da chave compostapublic class Livro implements Serializable { @Id private String titulo; @Id private String autor;//Cada uma das chaves recebe a anotação @IdEmbeddable Classes• Existem situações onde você pode desejar agrupar em uma classe, mas sem criar uma tabela no BD pra isso• Para estes casos você pode usar as Embeddable Classes@Embeddable //Substitui a annotation @Entitypublic class Endereco implements Serializable { private String rua; private Integer numero; // getters &amp; setters...}• Embeddable classes podem ser definidas como propriedades de entidades@Entitypublic class Cadastro implements Serializable { @Id private Integer id; private String nome; @Embedded//O @Embedded indica uma embeddable class private Endereco endereco; // getters &amp; setters...}Mapeamento em Embeddable ClassesEmbeddable classes são mapeadas para a mesma tabela da entidadeEntityManager• A interface EntityManager é o ponto de entrada para o uso da JPA pelo programador• Possui os métodos para interagir com entidades Método Descrição persist() Cria uma entidade merge() Atualiza uma entidade remove() Exclui uma entidade find() Busca uma entidade com base no seu ID createQuery() Permite procurar entidades de acordos com os critérios desejados • A instância de um EntityManager pode ser injetada em componentes do Java EE via CDI@Statelesspublic class MyBean { @PersistenceContext//@PersistenceContext injeta uma instância de EntityManager private EntityManager em;//...}Ciclo de Vida de Uma Entidade• Uma entidade pode assumir diversos estados durante o seu ciclo de vida– new (nova)– managed (gerenciada)– detached (não-gerenciada)• Quando a entidade está no estado gerenciada, qualquer alteração nela é refletida no banco de dadosLivro l = new Livro();l.setTitulo(\"Java\");l.setAutor(\"José Silva\");entityManager.persist(l);l.setTitulo(\"Java EE\"); graph LR subgraph \"Nova (new)\" A((L)) end subgraph Contexto transacional subgraph \"Gerenciada (managed)\" B((L)) end end C[Os dados são modificados no DB] -.-&gt; BLivro l = entityManager.find(Livro.class, 123);l.setTitulo(\"Java Web\");entityManager.remove(l);graph LR subgraph \"Detached (não-gerenciada)\" end subgraph Contexto transacional subgraph \"Gerenciada (managed)\" B((L)) end end C[Os dados são modificados no DB] -.-&gt; Bpublic void m() { Livro l = ejb.load(123); l.setAutor(\"Maria P.\"); ejb.update(l); }graph TD subgraph JSF Bean subgraph \"Detached (não-gerenciada)\" A((L)) end end B[Os dados NÃO são modificados no DB] -.-&gt; A C[Ao sair do contexto transacional, a entidade deixa de ser gerenciada] -.-&gt; Apublic Livro load(int id) { Livro l = entityManager.find(id); return l;}public void update(Livro l) { entityManager.merge(l);}graph TD subgraph EJB subgraph \"Gerenciada (managed)\" A((L)) end end B[\"O merge() atualiza no BD o que foi modificado\"] -.-&gt; AO arquivo persistence.xml• A JPA tem a responsabilidade de se comunicar com o banco de dados e fazer o gerenciamento das entidadesgraph LR A(Aplicação) &lt;--&gt;|EntityManager| B((JPA)) &lt;--&gt;|persistence.xml| C[(Banco de Dados)]• O arquivo persistence.xml define como a JPA se comunica com o banco de dados– Normalmente é utilizada uma data source&lt;persistence&gt; &lt;persistence-unit name=\"appPU\"&gt; &lt;jta-data-source&gt;jdbc/appds&lt;/jta-data-source&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt;Conexões com o Banco de Dados• Em aplicações web, conexões com o banco de dados são normalmente gerenciadas pelo próprio servidor– Abrir conexões é um processo considerado caro computacionalmente– Existe um limite de conexões simultâneas que podem ficar ativas no banco de dadosPool de ConexõesO pool garante um limite de conexões simultâneas e evita o “abre e fecha” de conexõesgraph LR A((Requisição)) subgraph Servidor B[Aplicação] C[Pool de conexões] end A --&gt; B B -.-&gt; C C -.-&gt; B• A configuração do pool de conexões varia de um servidor para outro– Wildfly, GlassFish, etc.• É necessário consultar a documentação do servidor utilizadoData Source• A data source é uma fonte de dados– É configurada no servidor– Tem um pool de conexões associado– Tem um nome JNDI, que a identifica• Ex: jdbc/appdsgraph LR A((JPA)) --&gt;|Usa o nome JNDI| B[Data Source] --&gt;|Informações de conexão| C[(Banco de Dados)]" }, { "title": "Componentes EJB - Message-Driven Beans - Jakarta EE", "url": "/posts/componentes-ejb-message-driven-beans-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-06-25 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueJMS• Java Messaging Service• Serviço de comunicação via troca de mensagensO JMS gerencia e garante a entrega das mensagensA e B estão desacopladosA comunicação é assíncronagraph LR A((A)) --&gt; B(JMS) --&gt; C((B))Os Modelos de Entrega de MensagensB e C e D recebem a mensagemgraph LR A((A)) --&gt; B(fa:fa-newspaper Topic) B --&gt; C((B)) &amp; D((C)) &amp; E((D))B ou C ou D recebem a mensagemgraph LR A((A)) --&gt; B(fa:fa-database Queue) B --&gt; C((B)) B --- D((C)) &amp; E((D))Java EE &amp; JMS• EJBs do tipo Message-Driven Beans são usados para consumir mensagens enviadas via JMSgraph LR D[JSF Bean, EJB, outros sistemas, etc.] -.-&gt; A A((A)) --&gt; B(JMS) --&gt; C((B)) E[Message-Driven Bean] -.-&gt; CO MDB pode receber mensagens de topics ou queuesConfigurando o JMS• Todo servidor de aplicações que suporta o JavaEE deve ter suporte ao JMS• Cada servidor de aplicação tem sua própria forma de configurar o JMSCaracterísticas dos Message-Driven Beans• Não são acessados diretamente via programação– Eles respondem a mensagens enviadas a um topic ou queue• Não possuem interfaces como os Session Beans• São stateless– Não armazenam estado de conversação com um cliente específico– O container normalmente usa um pool de instâncias pra atender múltiplos clientes simultaneamente• De forma semelhante ao que acontece com os Stateless Session Beans• São chamados de forma assíncronaCriando Message-Driven Beans@MessageDriven(activationConfig = { //@MessageDriven define que a classe é um MDB @ActivationConfigProperty(//Propriedades que conectam o bean a um topic ou queue propertyName = \"destinationType\", propertyValue = \"javax.jms.Topic\"), @ActivationConfigProperty( propertyName = \"destination\", propertyValue = \"java:/jms/topic/SoftTopic\"),})public class TopicReceiverBean implements MessageListener {//Interface opcional public void onMessage(Message message) { // Processa a mensagem - Chamado quando chega uma mensagem }}Tipos de mensagens: TextMessage, StreamMessage, BytesMessage, ObjectMessage, MapMessageCiclo de vida Criação da instância (new) Injeção de dependências Método @PostConstructgraph TD A[Não Existe] --&gt;|Container decide criar o bean| B[Pronto] B --&gt;|\"onMessage()\"| B B --&gt;|Container decide destruir o bean| A B -.-&gt; C(\"Método @PreDestroy\") -.-&gt; A" }, { "title": "Componentes EJB - Session Beans - Jakarta EE", "url": "/posts/componentes-ejb-session-beans-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-06-18 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueEnterprise Java Beans• Chamados também de EJBs• Componentes da plataforma Java EE que implementam a lógica de negócio da aplicação• O uso de EJBs favorece a escalabilidade– Os EJBs podem ser distribuídos em diferentes servidores• O container fornece diversos serviços aos EJBs, como segurança e transações– O foco do desenvolvedor pode ficar 100% na implementação da lógica de negócio• Os EJBs foram introduzidos na plataforma J2EE• Tinham uma série de limitações• Configuração complicada• Muitos artefatos• Nas últimas versões do Java EE os EJBs sofreram uma melhora significativaOs EJBs são executados por um container específicoTipos de EJBs• Existem 2 tipos de EJBs– Session Beans• Stateful• Stateless• Singleton– Message-Driven BeansSession Beans• Um session bean possui métodos que podem ser invocados por um clienteNormalmente o session bean é um cliente da aplicação webgraph LR subgraph Servidor subgraph Web Container A[JSF Bean] end subgraph EJB Container B[Session Bean] end A --&gt; B end Stateful Session Bean• Está atrelado a um cliente específicoA mesma instância de ProdutoBean é usada pra atender o clientegraph LR A[Web - JSF Bean] subgraph EJB Container B[ProdutoBean] end A --&gt; B A --&gt; B A --&gt; B• Mantém estado conversacional– O cliente interage com o mesmo bean• Como o bean não é compartilhado, é possível armazenar dados nos seus atributos• É preciso que exista um objeto pra cada cliente acessando a aplicação– Isso pode causar problemas em aplicações que demandam uma grande quantidade de acessos simultâneosStateless Session Bean• Não está atrelado a um cliente específico– Pode atender vários clientesQualquer instância de ProcessarBean pode ser usada pra atender o clientegraph LR A[Web - JSF Bean] subgraph EJB Container B[ProdutoBean] C[ProdutoBean] D[ProdutoBean] E[ProdutoBean] end A --&gt; B A --&gt; C A --&gt; E• Não mantém estado conversacional– Diferentes instâncias do bean podem ser designadas pra atender os clientes• Como o bean é compartilhado, não é possível armazenar dados nos seus atributos• Poucas instâncias de beans podem atender muitos clientes– Essa é uma característica interessante em cenários onde a escalabilidade é desejadaSingleton Session Bean• Existe apenas uma instância do bean– Ela é compartilhada entre todos os clientesA mesma instância de CacheBean é usada pra atender todos os clientesgraph LR A[Web - JSF Bean] subgraph EJB Container B[CacheBean] end A --&gt; B A --&gt; B• A instância é única durante todo o tempo de vida da aplicação– Ela é compartilhada entre todos os clientes, que podem acessá-la simultaneamenteQual tipo de Session Bean escolher?graph TD A[Precisa manter estado de conversação com um cliente?] --&gt; B{ } B --&gt;|SIM| C(Stateful Session Bean) B --&gt;|NÃO| D[Precisa compartilhar informações entre clientes?] D --&gt; E{ } E --&gt;|SIM| F(Singleton Session Bean) E --&gt;|NÃO| G(Stateless Session Bean)Elementos de um Session Bean• Um EJB é composto por:– Classe do bean• Obrigatória– Business interface (interface do bean)• Opcional• Se um EJB possuir uma business interface, ela pode ser:– Local• O cliente do EJB e o EJB precisam estar executando na mesma JVM– Remota• O cliente do EJB e o EJB podem estar executando em JVMs diferentes• Bean com interface remotagraph LR subgraph JVM A A[JSF Bean] --&gt; B[\"@Remote Service\"] C[\"&lt;&lt; class &gt;&gt; ServiceBean\"] -.-&gt; B end subgraph JVM B D[JSF Bean] end D --&gt; B• Bean com interface localgraph LR subgraph JVM A A[JSF Bean] --&gt; B[\"@Local Service\"] C[\"&lt;&lt; class &gt;&gt; ServiceBean\"] -.-&gt; B end• Bean sem interfaceÉ como se tivesse uma interface localgraph LR subgraph JVM A A[JSF Bean] --&gt; B[\"&lt;&lt; class &gt;&gt; ServiceBean\"] endCriando um Session Bean: Classe• A classe do EJB é uma classe comum, anotada com o tipo do bean (@Stateless, @Stateful ou @Singleton)@Stateless//Stateless Session Bean sem interfacepublic class TemperatureConverterBean { public double celsiusToFarenheit(double tc) { // lógica de negócio }}Criando um Session Bean: Interface• A interface do EJB é anotada com @Local ou @Remote@Local// interface localpublic interface TemperatureConverter { public double celsiusToFarenheit(double tc);}@Statelesspublic class TemperatureConverterBean implements TemperatureConverter { public double celsiusToFarenheit(double tc) { // lógica de negócio }}• Outra opção é anotar apenas a classepublic interface TemperatureConverter { public double celsiusToFarenheit(double tc);}@Stateless@Remote(TemperatureConverter.class)public class TemperatureConverterBean implements TemperatureConverter { public double celsiusToFarenheit(double tc) { // lógica de negócio }}Referenciando um Session Bean• A referência a um EJB pode ser injetada via CDIJSF Bean@Named(\"form\")@RequestScopedpublic class FormBean implements Serializable { @EJB private TemperatureConverter temperatureConverter;//interface}JSF Bean@EJBprivate TemperatureConverterBean temperatureConverter;//classe do beanChamadas Assíncronas• Os Session Beans suportam métodos assíncronos– O retorno ocorre antes mesmo do método terminar de executar• A annotation @Asynchronous é utilizada• O método deve retornar– void– Future&lt;?&gt;@Asynchronouspublic void m1() { // lógica de negócio}@Asynchronouspublic Future&lt;String&gt; m1() {//O objeto Future&lt;?&gt; possui métodos para checar se a execução terminou e pegar o resultado // lógica de negócio return new AsyncResult&lt;String&gt;(\"ABC\");}Ciclo de Vida: Stateful Session Bean Criação da instância (new) Injeção de dependências Método @PostConstruct Método @Initgraph LR A[Não Existe] --&gt;|Cliente inicia conversação| B[Pronto] B --&gt;|\"Método @Remove\"| A B -.-&gt; C(\"Método @PreDestroy\") -.-&gt; A B --&gt;|Container decide passivar o bean| D[Passivo] B -.-&gt; E(\"Método @PrePassivate\") -.-&gt; D D --&gt;|Container decide ativar o bean| B D -.-&gt; F(\"Método @PostActivate\") -.-&gt; BCiclo de Vida: Stateless Session Bean Criação da instância (new) Injeção de dependências Método @PostConstructgraph TD A[Não Existe] --&gt;|Container decide criar o bean| B[Pronto] B --&gt;|Método do bean é chamado| B B --&gt;|Container decide destruir o bean| A B -.-&gt; C(\"Método @PreDestroy\") -.-&gt; ACiclo de Vida: Singleton Session Bean Criação da instância (new) Injeção de dependências Método @PostConstructgraph TD A[Não Existe] --&gt;|Container decide criar o bean| B[Pronto] B --&gt;|Método do bean é chamado| B B --&gt;|Container decide destruir o bean| A B -.-&gt; C(\"Método @PreDestroy\") -.-&gt; ASe o bean estiver anotado com @Startup, ele é criado assim que a aplicação é iniciada" }, { "title": "Templates e Tags com Facelets - Jakarta EE", "url": "/posts/templates-tags-facelets-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-06-11 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueFacelets• Facelets é a tecnologia de visualização padrão a partir do JSF 2.x– Substituiu o JSP, utilizado em versões anteriores do JSF• Um dos principais usos do facelets é a criação de templates de páginas de uma aplicação JSFTemplates• Aplicações web são normalmente compostas por várias páginas, que compartilham um modelo comum (template)• Com facelets, é possível criar estes templatesCriando um Template• O primeiro passo é criar uma página que vai representar o templatelayout.xhtml&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:ui=\"http://xmlns.jcp.org/jsf/facelets\"&gt;&lt;!-- Referencia as tags do facelets --&gt;&lt;body&gt; &lt;table border=\"1\" width=\"30%\"&gt; &lt;tr&gt;&lt;td align=\"center\"&gt; &lt;h1&gt;&lt;ui:insert name=\"titulo\" /&gt;&lt;/h1&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;ui:insert name=\"texto\" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;!-- Conteúdo que será substituído --&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;Criando uma Página• Páginas que usam um template devem definir o conteúdo a ser substituídopage.xhtml&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:ui=\"http://xmlns.jcp.org/jsf/facelets\"&gt;&lt;body&gt; &lt;ui:composition template=\"/layout.xhtml\"&gt; &lt;ui:define name=\"titulo\"&gt;Título da Página&lt;/ui:define&gt; &lt;ui:define name=\"texto\"&gt;&lt;!-- Define a subsituição a ser feita nas tags ui:insert do template --&gt; Este é um texto que será utilizado na página &lt;/ui:define&gt; &lt;/ui:composition&gt;&lt;/body&gt;&lt;/html&gt;• Quando uma tag ui:composition que referencia um template é encontrada na página, o facelets remove todas as tags externas ao ui:composition&lt;ui:composition template=\"/layout.xhtml\"&gt; &lt;ui:define name=\"titulo\"&gt; Título da Página &lt;/ui:define&gt; &lt;ui:define name=\"texto\"&gt; Este é um texto que será utilizado na página &lt;/ui:define&gt;&lt;/ui:composition&gt;Incluindo páginas• Uma página JSF pode incluir outras páginas através da tag ui:include&lt;body&gt; &lt;h1&gt; &lt;ui:include src=\"/titulo.xhtml\" /&gt;&lt;!-- Inclui o conteúdo da página titulo.xhtml neste local --&gt; &lt;/h1&gt;&lt;/body&gt;titulo.xhtml&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:ui=\"http://xmlns.jcp.org/jsf/facelets\"&gt;&lt;body&gt;&lt;!-- Neste caso, não é fornecido um template --&gt; &lt;ui:composition&gt;&lt;!-- Apenas o que está dentro da tag ui:composition é incluído --&gt; Título da Página &lt;/ui:composition&gt;&lt;/body&gt;&lt;/html&gt;Decorators• Decorators são utilizados para aplicar um padrão sobre determinado conteúdo&lt;body&gt; &lt;ui:decorate template=\"/decorator.xhtml\"&gt;&lt;!-- Define um template usado para decorar o conteúdo da página --&gt; &lt;h:commandButton value=\"Processar\" action=\"#{bean.processar}\" /&gt; &lt;/ui:decorate&gt;&lt;/body&gt;decorator.xhtml&lt;body&gt; &lt;ui:composition&gt; &lt;table&gt; &lt;tr&gt; &lt;td bgcolor=\"#ACACAC\"&gt;&lt;ui:insert /&gt;&lt;/td&gt;&lt;!-- Insere o conteúdo a ser decorado --&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/ui:composition&gt;&lt;/body&gt;Parâmetros para Templates• Templates podem receber parâmetros das páginas que os incluem– Isto vale para as tags ui:composition e ui:decorate&lt;ui:decorate template=\"/decorator.xhtml\"&gt; &lt;ui:param name=\"color\" value=\"#CCCCCC\" /&gt;&lt;!-- O parâmetro color é passado para o template --&gt; &lt;h:commandButton value=\"Processar\" action=\"#{bean.processar}\" /&gt;&lt;/ui:decorate&gt;decorator.xhtml&lt;h:body&gt; &lt;ui:composition&gt; &lt;table&gt; &lt;tr&gt; &lt;td bgcolor=\"#{color}\"&gt;&lt;ui:insert /&gt;&lt;/td&gt;&lt;!-- Expressão EL para leitura do parâmetro --&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/ui:composition&gt;&lt;/h:body&gt;Tags Customizadas com Facelets• O facelets permite a criação de tags customizadas• Ao utilizar uma tag desse tipo, o conteúdo da página é substituído por outro• A tag é definida em um arquivo .xhtmlCriando o Arquivo da Tag/WEB-INF/tags/foto.xhtml&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:f=\"http://xmlns.jcp.org/jsf/core\" xmlns:h=\"http://xmlns.jcp.org/jsf/html\" xmlns:ui=\"http://xmlns.jcp.org/jsf/facelets\"&gt;&lt;body&gt; &lt;ui:composition&gt; &lt;center&gt; &lt;h:graphicImage library=\"images\" name=\"#{imagem}\" /&gt; &lt;br /&gt; &lt;h3&gt;#{legenda}&lt;/h3&gt; &lt;/center&gt; &lt;/ui:composition&gt;&lt;/body&gt;&lt;/html&gt;Arquivo de Definição da Tag• Para que as suas tags sejam reconhecidas pelo JSF, é necessário criar um arquivo de definição de tags• Este arquivo normalmente fica em /WEB-INF• Define um namespace para as tags, bem como nome e local de cada tag criadamytags.taglib.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;facelet-taglib version=\"2.2\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-facelettaglibrary_2_2.xsd\"&gt; &lt;namespace&gt;http://mytags/facelets&lt;/namespace&gt; &lt;tag&gt; &lt;tag-name&gt;foto&lt;/tag-name&gt; &lt;source&gt;tags/foto.xhtml&lt;/source&gt; &lt;/tag&gt;&lt;/facelet-taglib&gt;Configuração no web.xml• O JSF precisa saber a respeito do arquivo de definição de tags, caso contrário não saberá que ele existe• A configuração é feita no arquivo web.xml&lt;context-param&gt; &lt;param-name&gt;javax.faces.FACELETS_LIBRARIES&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/mytags.taglib.xml&lt;/param-value&gt;&lt;/context-param&gt;Para múltiplos arquivos, a separação é feita com “;”Utilizando Tags Customizadas&lt;html xmlns:my=\"http://mytags/facelets\"&gt;&lt;!-- Referencia a tag pelo namespace e usa o prefixo my --&gt; &lt;my:foto imagem=\"duke.png\" legenda=\"Duke, o mascote do Java\"/&gt;&lt;!-- Passa os parâmetros necessários --&gt;" }, { "title": "Utilizando AJAX com JSF - Jakarta EE", "url": "/posts/ajax-jsf-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-06-04 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueAJAX Asynchronous JavaScript and XML Permite fazer uma requisição parcial ao servidor e obter uma resposta – Dados são enviados ao servidor sem que a página precise ser completamente atualizada Sistemas modernos têm adotado o AJAX, pois ele possibilita uma melhor experiência de navegação aos usuáriosAJAX e o JSF Uma página JSF é composta por componentes Em uma requisição HTTP normal – Todos os componentes da página são processados no servidor– Todos os componentes são renderizados para serem exibidos na tela Em uma requisição AJAX é diferente– Na requisição, apenas alguns componentes são processados– Ao receber a resposta, alguns componentes são renderizadosCiclo de Vida de Requisições AJAXgraph TD subgraph Execução A((AJAX Request)) --&gt; B(Restore View) --&gt; C(Apply Request Values) --&gt; D(Process Validations) --&gt; E(Update Model Values) E --&gt; F(Invoke Application) end subgraph Renderização F --&gt; G(Render Response) --&gt; H((AJAX Response)) end A Tag f:ajax Utilizada para adicionar requisições AJAX a uma página JSF&lt;h:panelGrid columns=\"3\"&gt; Número: &lt;h:inputText id=\"num\" value=\"#{bean.num}\"&gt; &lt;f:ajax event=\"keyup\" execute=\"@this\" render=\"error\" /&gt; &lt;/h:inputText&gt; &lt;h:message id=\"error\" for=\"num\" style=\"color: red\" /&gt;&lt;/h:panelGrid&gt; Atributo Descrição event Evento que dispara a requisição AJAX (keyup, keydown, blur, change, etc.) execute Componentes a serem processados no servidor render Componentes da tela a serem renderizados na resposta &lt;f:ajax event=\"keyup\" execute=\"@this\" render=\"error\" /&gt;&lt;h:message id=\"error\" for=\"num\" /&gt;Atributo event Identifica o evento que vai disparar a requisição AJAX blur focus mousedown mouseup change keydown mousemove select click keypress mouseout action dblclick keyup mouseover valueChange Eventos de componentes– action Botões e links– valueChange Componentes de entrada de dadosAtributo execute Define os componentes que serão executados (processados) no servidor Para mais de um componente, os IDs devem ser separados por espaços em branco Palavras-chave permitidas: @this Componente onde a tag f:ajax foi inserida @form Todos os componentes do formulário @all Todos os componentes da página @none Nenhum componente Atributo render Define os componentes que serão renderizados na resposta da requisição Para mais de um componente, os IDs devem ser separados por espaços em branco Palavras-chave permitidas: @this Componente onde a tag f:ajax foi inserida @form Todos os componentes do formulário @all Todos os componentes da página @none Nenhum componente Grupos de Componentes AJAX A tag f:ajax também pode ser utilizada para criar um grupo de componentes AJAX&lt;f:ajax event=\"blur\" render=\"@form\"&gt; &lt;h:form&gt; ... &lt;h:inputText id=\"num1\" value=\"#{bean.num1}\" /&gt; ... &lt;h:inputText id=\"num2\" value=\"#{bean.num2}\" /&gt; ... &lt;/h:form&gt;&lt;/f:ajax&gt;AJAX, JSF e JavaScript A tag f:ajax possui dois parâmetros que podem referenciar funções JavaScript– onevent– onerrorO Atributo onevent A função definida em onevent é chamada três vezes para cada requisição AJAX– No início da requisição (begin)– Quando a requisição é processada (complete)– Quando a resposta está prestes a ser renderizada (success)&lt;f:ajax event=\"blur\" onevent=\"process\"&gt;&lt;script&gt;function process(data) { ...}&lt;/script&gt; Atributo Descrição status Status da requisição AJAX: begin, complete, success source Componente que originou o evento responseXML Resposta da requisição AJAX (XML) responseText Resposta da requisição AJAX (texto) responseCode Código de resposta HTTP para a requisição O Atributo onerror A função definida em onerror é chamada quando algum erro acontece no processamento da requisição A função recebe um objeto data, semelhante à função usada em onvent Possui um atributo extra status Valor Descrição httpError Código de retorno do HTTP inválido ou inexistente emptyResponse Servidor não enviou resposta para a requisição malformedXML A resposta não é um XML válido serverError Ocorreu algum problema no servidor Biblioteca JavaScript do JSF O JSF possui uma biblioteca JavaScript própria&lt;h:outputScript library=\"javax.faces\" name=\"jsf.js\" /&gt; Esta biblioteca possui diversas funções para quem deseja trabalhar diretamente com JavaScript Maiores informações sobre esta API podem ser encontradas na especificação do JSF " }, { "title": "Eventos em JSF - Jakarta EE", "url": "/posts/eventos-jsf-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-05-28 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueCiclo de Vida de Requisiçõesgraph TD A((Request)) --&gt; B(Restore View) --&gt; C(Apply Request Values) C --&gt; D(Process Validations) --&gt; E(Update Model Values) E --&gt; F(Invoke Application) --&gt; G(Render Response) --&gt; H((Response))Eventos e Tipos de Eventos• Eventos em JSF podem ser disparados– Em resposta a ações de usuários– Pelo próprio JSF• Eventos são processados no servidor• Existem 4 tipos de eventos– Action Events– Value Change Events– Phase Events– System EventsAction Events• Eventos disparados quando ocorre um clique em um componente que gera uma ação, como h:commandLink ou h:commandButton&lt;h:commandButton value=\"OK\" actionListener=\"#{bean.botaoClicado}\" /&gt;public void botaoClicado(ActionEvent event) { //...}• Outra opção é criar um listenerpublic class MyListener implements ActionListener { public void processAction(ActionEvent event) throws AbortProcessingException { //...}• A tag f:actionListener é utilizada para referenciar o listener criado&lt;h:commandButton value=\"OK\"&gt; &lt;f:actionListener type=\"app.MyListener\" /&gt;&lt;/h:commandButton&gt;Action Events no Ciclo de Vidagraph TD A((Request)) --&gt; B(Restore View) --&gt; C(Apply Request Values) C --&gt; D(Process Validations) --&gt; E(Update Model Values) E --&gt; F(Invoke Application) --&gt; G(Render Response) --&gt; H((Response)) F --&gt; I[Action Events] --&gt; GValue Change Events• Eventos disparados quando ocorre uma mudança de valor em algum componente, como h:inputText, h:selectOneMenu, etc.&lt;h:selectOneMenu value=\"#{bean.valor}\" onchange=\"submit();\" valueChangeListener=\"#{bean.mudouValor}\"&gt;public void mudouValor(ValueChangeEvent event) { //...}• Outra opção é criar um listenerpublic class MyListener implements ValueChangeListener { public void processValueChange(ValueChangeEvent event) throws AbortProcessingException { //... }}• A tag f:valueChangeListener é utilizada para referenciar o listener criado&lt;h:selectOneMenu value=\"#{bean.valor}\" onchange=\"submit();\"&gt; &lt;f:valueChangeListener type=\"app.MyListener\" /&gt; ...&lt;/h:selectOneMenu&gt;Value Change Events no Ciclo de Vidagraph TD A((Request)) --&gt; B(Restore View) --&gt; C(Apply Request Values) C --&gt; D(Process Validations) --&gt; E(Update Model Values) E --&gt; F(Invoke Application) --&gt; G(Render Response) --&gt; H((Response)) D --&gt; I[Value Change Events] --&gt; EVantagens de Utilizar Listeners• Action e value change events permitem utilizar listeners• O uso de listeners tem algumas vantagens– Reaproveitamento do listener em vários componentes da aplicação– Possibilidade de executar mais de um listener por evento disparadoO Atributo immediate• Utilizado em ocasiões onde o processo de validação precisa ser ignorado• Quando um componente define o atributo immediate com o valor true, os eventos (action e value change) são disparados antes da validação– Após a fase Apply Request ValuesImmediate e o Ciclo de Vidagraph TD A((Request)) --&gt; B(Restore View) --&gt; C(Apply Request Values) C --&gt; D(Process Validations) --&gt; E(Update Model Values) E --&gt; F(Invoke Application) --&gt; G(Render Response) --&gt; H((Response)) C --&gt; I[Action/Value Change Events] --&gt; DIgnorando a Validação• Para um value change event ignorar a validação, duas coisas devem acontecer– O immediate deve ser habilitado no componente– O código do evento deve forçar a ida para a fase Render Response&lt;h:selectOneMenu onchange=\"submit();\" valueChangeListener=\"#{bean.mudouValor}\" immediate=\"true\"&gt; ...&lt;/h:selectOneMenu&gt;public void mudouValor(ValueChangeEvent event) { //... FacesContext context = FacesContext.getCurrentInstance(); context.renderResponse();}• Para um action event, basta habilitar o atributo immediate no componente que gera a ação– Não é preciso chamar a fase Render Response, pois isto é feito automaticamentePhase Events• Gerados pelo JSF quando ocorrem mudanças de uma fase para outra• São gerados dois eventos por fase– O primeiro logo antes de iniciar a fase– O segundo logo após o término da fase• Este tipo de evento está associado a uma view, e não a um componenteListeners para Phase Events• Um listener deve implementar PhaseListener• Pode ser configurado de várias formasEm uma view específica&lt;f:phaseListener type=\"app.MyPhaseListener\" /&gt;Globalmente, para todas as views&lt;faces-config&gt; &lt;lifecycle&gt; &lt;phase-listener type=\"app.MyListener\" /&gt; &lt;/lifecycle&gt;&lt;/faces-config&gt;Criando um PhaseListenerpublic class MyPhaseListener implements PhaseListener { public void beforePhase(PhaseEvent event) { //... } public void afterPhase(PhaseEvent event) { //... } public PhaseId getPhaseId() { return PhaseId.ANY_PHASE;//fase de interesse }}System Events• Eventos de diversos tipos gerados pelo JSF e que podem ser interceptados pelas aplicações• Estes eventos podem estar associados normalmente a:– Application– UIComponent– UIViewRootInício e Término da Aplicação• Dois system events indicam quando a aplicação foi inicializada e quando ela está prestes a ser terminada– PostConstructApplicationEvent– PreDestroyApplicationEvent• Estes eventos estão associados à aplicação como um todopublic class MySystemEventListener implements SystemEventListener { public boolean isListenerForSource(Object source) { return source instanceof Application; } public void processEvent(SystemEvent event) throws AbortProcessingException { ... }}• A configuração de um system event associado à aplicação (Application) é feita no arquivo faces-config.xml&lt;application&gt; &lt;system-event-listener&gt; &lt;system-event-listener-class&gt; app.MySystemEventListener &lt;/system-event-listener-class&gt; &lt;system-event-class&gt; javax.faces.event.PostConstructApplicationEvent &lt;/system-event-class&gt; &lt;/system-event-listener&gt;&lt;/application&gt;Pré-Renderização da View• O JSF gera um system event momentos antes de uma view ser renderizada– PreRenderViewEvent• Este evento está associado a UIViewRoot• Bastante útil na prática– Verificar acesso à página– Carregar informações para serem exibidas na view– etc.• A tag f:event é utilizada na view&lt;f:event type=\"preRenderView\" listener=\"#{bean.carregarDados}\" /&gt;• O método é implementado no beanpublic void carregarDados(ComponentSystemEvent event) { //...}Pós-Renderização da View• O JSF também dispara um evento assim que a view é renderizada– PostRenderViewEvent• A tag f:event é utilizada na view&lt;f:event type=\"postRenderView\" listener=\"#{bean.processarDados}\" /&gt;• O método é implementado no beanpublic void processarDados(ComponentSystemEvent event) { //...}" }, { "title": "Beans e Injeção de Dependências com CDI - Jakarta EE", "url": "/posts/beans-injecao-dependencias-cdi-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-05-21 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueO que são Beans São classes Java que seguem algumas convenções– Possuem um construtor público sem parâmetros– Possuem atributos Num bean, um atributo é chamado de propriedade– Possuem métodos getters/setters para o acesso aos atributos Atributo Método Getter Método Setter nome getNome() setNome() idade getIdade() setIdade() homem getHomem() / isHomem() setHomem() Beans e Páginas JSFgraph LR subgraph Servidor B((Bean)) end A[fa:fa-desktop Cliente] --&gt; B B --&gt; A Receber os dados de páginas JSF Enviar dados para páginas JSF Processar os eventos de páginas JSF Gerenciar a navegação entre as telas Value expressions, definidas em EL (Expression Language)&lt;h:inputText value=\"#{user.name}\" /&gt;&lt;h:inputSecret value=\"#{user.password}\" /&gt;&lt;h:commandButton action=\"#{user.login}\" /&gt;@Named(\"user\")public class UserBean implements Serializable { private String name; private String password; public String login() { // Lógica para o login } // Métodos getters e setters...}CDI Beans Contexts and Dependency Injection Permite que o próprio contêiner resolva as dependências entre objetos – O programador apenas declara a variável, e o contêiner cria os objetos e gerencia o ciclo de vidaCriando CDI Beans A criação de um CDI bean é feita anotando a classe do bean com @Named Um CDI bean deve implementar a interface Serializable @Namedpublic class UserBean implements Serializable { //...}Se o escopo do bean for request, não é necessário implementar SerializableNome de um CDI Bean Todo CDI bean tem um nome O nome deve ser conhecido, pois páginas JSF utilizam o nome do bean para referenciá-lo O nome do CDI bean é fornecido como value da anotação @Named @Named(\"user\")public class UserBean implements Serializable { //...} Se o nome for omitido, é assumido o nome da classe, mas com a inicial minúscula@Namedpublic class UserBean implements Serializable {//O nome do bean será userBean //...}Managed Beans Como o CDI foi criado apenas a partir do Java EE 6, em versões anteriores do JSF eram utilizados os managed beans São mais limitados em termos de recursos São suportados no JSF 2.x, mas a preferência deve ser dada aos CDI beans – A partir do JSF 2.3, os managed beans do JSF foram marcados como deprecated Como eu identifico se estou usando os managed beans do JSF:– Annotations do pacote javax.faces.bean @ManagedBean @RequestScoped @SessionScoped etc. Backing Beans Beans com propriedades que representam componentes de páginas JSF&lt;h:inputText binding=\"#{user.nameTxt}\" /&gt;Especifica a propriedade do beanque referencia o componente@Named(\"user\")public class UserBean implements Serializable { private UIInput nameTxt;//Representa o componente da página // Métodos getters e setters}Escopos de um Bean O tempo de vida de um bean é definido pelo seu escopo O CDI define quatro escopos – Request, Application, Session, Conversation Podem ser utilizadas anotações nas classes dos beans– Package: javax.enterprise.context Procure sempre utilizar o escopo de acordo com a necessidadeEscopo Request O bean é criado quando uma requisição HTTP ocorre É destruído assim que a resposta da requisição é enviada ao cliente Este escopo é utilizado quando as informações precisam existir por pouco tempo, apenas para determinada requisição @RequestScopedpublic class MyBean implements Serializable { //...}graph TD subgraph Servidor A[JSF] --&gt; B((\"Bean (Request)\")) end B --- D[O bean é destruído após o envio da resposta] C[fa:fa-desktop Cliente] --&gt;|Requisição HTTP| A A --&gt;|Resposta HTTP| CEscopo Application O bean é compartilhado entre todos os clientes que acessam a aplicação Permanece ativo enquanto a aplicação estiver executando @ApplicationScopedpublic class MyBean implements Serializable { //...}Escopo Session O bean existe enquanto durar a sessão do usuário– Múltiplas requisições do mesmo cliente– A sessão termina quando o navegador é fechado ou via programação@SessionScopedpublic class MyBean implements Serializable { //...}graph TD subgraph Servidor A[JSF] --&gt; B((\"Bean (Session)\")) end B --- D[O bean é reutilizado na mesma sessão] C[fa:fa-desktop Cliente] --&gt;|Requisição HTTP| AEscopo Conversation O bean existe durante um período de conversação, definido pelo programador– Este escopo é diferente da sessão– A sessão de um usuário pode ter mais de uma conversação@ConversationScopedpublic class MyBean implements Serializable { @Inject private Conversation conversation;//Objeto que gerencia a conversação}Os métodos begin() e end() delimitam a conversaçãoSincronismo no Acesso O escopo request é o único thread-safe– Não é necessário sincronizar o acesso aos métodos Métodos de beans em outros escopos podem, eventualmente, ser acessados simultaneamente, gerando problema de concorrência– É necessário utilizar mecanismos de controle, como métodos sincronizados (synchronized)Injeção de Beans Algumas vezes um bean precisa referenciar outro bean Esta referência é feita através de injeção de beans – O contêiner provê as referências necessárias@Namedpublic class MyBean1 implements Serializable { @Inject private MyBean2 bean2;//A anotação @Inject injeta a dependência @Inject private MyBean3 bean3;}@PostConstruct e @PreDestroy São anotações que podem ser utilizadas em métodos de um bean Os métodos anotados são invocados automaticamente pelo contêiner – @PostConstruct: assim que o bean é criado– @PreDestroy: quando o bean está prestes a ser destruído" }, { "title": "Tabelas Dinâmicas com o Componente Data Table - Jakarta EE", "url": "/posts/tabelas-dinamicas-data-table-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-05-14 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueA Tag h:dataTable Permite renderizar tabelas utilizando informações dinâmicas&lt;h:dataTable value=\"#{table.contatos}\" var=\"c\"&gt; &lt;h:column&gt; #{c.nome} &lt;/h:column&gt; &lt;h:column&gt; #{c.email} &lt;/h:column&gt; &lt;h:column&gt; #{c.telefone} &lt;/h:column&gt; &lt;/h:dataTable&gt;@Named(\"table\")@RequestScopedpublic class TableBean implements Serializable { private List&lt;Contato&gt; contatos = new ArrayList&lt;&gt;(); public TableBean() { contatos.add(new Contato(1, \"José\", \"jose@abc.com\", \"555-3421\")); contatos.add(new Contato(2, \"João\", \"joao@abc.com\", \"555-8794\")); } public List&lt;Contato&gt; getContatos() { return contatos; }A Tag f:facet Permite atribuir informações ao cabeçalho e rodapé das colunas e título da tabela&lt;h:dataTable value=\"#{table.contatos}\" var=\"c\"&gt; &lt;f:facet name=\"caption\"&gt; Lista de Contatos &lt;/f:facet&gt; &lt;h:column&gt; &lt;f:facet name=\"header\"&gt; Nome &lt;/f:facet&gt; #{c.nome} &lt;/h:column&gt; ...&lt;/h:dataTable&gt;Os valores podem ser caption, header ou footerEstilo das tabelas O estilo das tabelas pode ser definido através de CSS A tag h:dataTable possui atributos que permitem definir os estilos– styleClass: para a tabela– headerClass: para o cabeçalho– footerClass: para o rodapé– columnClasses: para cada coluna– rowClasses: para cada linhaComponentes JSF e Tabelas Além de textos, tabelas também podem ter componentes em suas linhas e colunas...&lt;h:column&gt; &lt;h:inputText value=\"#{c.nome}\" /&gt;&lt;/h:column&gt;...Table Models Um table model faz a ponte entre dados a serem exibidos na tabela e a própria tabelagraph LR A[Table Model] --&gt; B[h:dataTable] A --&gt; C[Model] O próprio JSF encapsula os dados em um table model se o programador não o faz Os table models mais utilizados são – ArrayDataModel: usado com arrays de dados– ListDataModel: usado com listas de dadosBenefícios de um Table Model Utilizar um table model explicitamente traz algumas facilidades a mais no momento de renderizar tabelas– Exibir o número de cada linha renderizada– Fazer algum pré-processamento de informações antes que elas sejam exibidas Para criar um table model customizado, basta criar uma classe que herda de DataModelA Tag ui:repeat Alternativa ao uso da tag h:dataTable Permite renderizar o corpo da tag de forma repetida &lt;table&gt; &lt;ui:repeat value=\"#{table.contatos}\" var=\"c\"&gt; &lt;tr&gt; &lt;td&gt;#{c.nome}&lt;/td&gt; &lt;td&gt;#{c.email}&lt;/td&gt; &lt;td&gt;#{c.telefone}&lt;/td&gt; &lt;/tr&gt; &lt;/ui:repeat&gt;&lt;/table&gt;Informações sobre a Iteração Com a tag ui:repeat, é possível ter acesso a informações relacionadas à iteração&lt;table&gt; &lt;ui:repeat value=\"#{table.contatos}\" var=\"c\" varStatus=\"st\"&gt; &lt;h:panelGroup rendered=\"#{st.even}\"&gt; &lt;tr&gt; &lt;td bgcolor=\"#FFFFFF\"&gt;#{st.index + 1}&lt;/td&gt; &lt;td bgcolor=\"#FFFFFF\"&gt;#{c.nome}&lt;/td&gt; &lt;/tr&gt; &lt;/h:panelGroup&gt; &lt;h:panelGroup rendered=\"#{st.odd}\"&gt; &lt;tr&gt; &lt;td bgcolor=\"#CCCCCC\"&gt;#{st.index + 1}&lt;/td&gt; &lt;td bgcolor=\"#CCCCCC\"&gt;#{c.nome}&lt;/td&gt; &lt;/tr&gt; &lt;/h:panelGroup&gt; &lt;/ui:repeat&gt;&lt;/table&gt;" }, { "title": "Conversores e Validadores - Jakarta EE", "url": "/posts/conversores-validadores-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-05-07 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueProcessos de Conversão e Validação Os processos de conversão e validação são necessários para garantir que os dados que chegam ao bean sejam consistentespublic class LivroBean implements Serializable { private String titulo; private Date dataPublicacao; private Integer numPaginas; private Double preco; ...}Conversão Automática Algumas conversões são feitas de forma automática pelo JSF– Tipos de dados primitivos e classes wrappers correspondentes– Datas– Enums É possível especificar a formatação dos dados durante o processo de conversãoFormatação de Dados Datas e números podem ser formatados, a fim de indicar como a conversão será realizada&lt;h:inputText value=\"#{livro.dataPublicacao}\"&gt; &lt;f:convertDateTime pattern=\"MM/yyyy\" /&gt;&lt;/h:inputText&gt;&lt;h:inputText value=\"#{livro.preco}\"&gt; &lt;f:convertNumber minFractionDigits=\"2\" maxFractionDigits=\"2\" groupingUsed=\"false\" /&gt;&lt;/h:inputText&gt;Exibindo Mensagens de Erro Quando um erro de conversão ou validação ocorre, o JSF exibe a mesma tela novamente, com os dados do formulário já preenchidos A tag h:message é utilizada para exibir o erro ocorrido &lt;h:inputText id=\"numPaginas\" value=\"#{livro.numPaginas}\" /&gt;&lt;h:message for=\"numPaginas\" /&gt; A tag h:messages pode ser utilizada para exibir todas as mensagens de erro Mais utilizada durante o desenvolvimento Mensagens Resumidas e Detalhadas Uma mensagem de erro a ser exibida tem duas partes– Summary: mensagem resumida– Detail: mensagem detalhada É possível controlar qual parte exibir&lt;h:message for=\"comp\" showSummary=\"true\" showDetail=\"false\" /&gt; Para h:message, o padrão é exibir o detail Para h:messages, o padrão é exibir o summary Customizando Mensagens de Erro É necessário criar um arquivo de recursos na aplicação, que vai sobrescrever as mensagens do arquivo de recursos padrão do JSFMyMessages.propertiesDeve ficar no classpath da aplicaçãoO arquivo deve ter a extensão .propertiesDevem ser definidas as mensagens summary e detail O próximo passo é configurar a aplicação para ler as informações deste arquivo Isto é feito referenciando o arquivo no faces-config.xml &lt;faces-config&gt; &lt;application&gt; &lt;message-bundle&gt;app.MyMessages&lt;/message-bundle&gt; &lt;/application&gt;&lt;/faces-config&gt; O arquivo da aplicação será consultado primeiro, antes do arquivo de recursos do JSF Outra opção é fornecer a mensagem de erro de conversão diretamente na tag do componente &lt;h:inputText value=\"#{livro.preco}\" converterMessage=\"Erro de conversão\" /&gt;Conversores Customizados Algumas vezes os conversores padrão do JSF não atendem as necessidades da aplicação É possível criar conversores customizados @FacesConverter(forClass = Estado.class)public class EstadoConverter implements Converter { public Object getAsObject(FacesContext context, UIComponent component, String value) { //... } public String getAsString(FacesContext context, UIComponent component, Object value) { //... }} No momento da conversão, um conversor customizado pode avisar sobre erros de conversão É preciso lançar uma ConverterException public Object getAsObject(FacesContext context, UIComponent component, String value) { //... FacesMessage msg = new FacesMessage(\"Erro!\"); throw new ConverterException(msg);}Validação de Dados O JSF possui mecanismos de validação de dados Tag O que valida f:validateRequired A presença de uma informação f:validateLength O tamanho do texto fornecido f:validateLongRange Se o número é do tipo long e está dentro de determinado intervalo f:validateDoubleRange Se o número é do tipo double e está dentro de determinado intervalo f:validateRegex Uma expressão regular Exemplos de validação&lt;h:inputText value=\"#{livro.titulo}\"&gt; &lt;f:validateRequired /&gt; &lt;f:validateLength minimum=\"5\" maximum=\"30\" /&gt;&lt;/h:inputText&gt;&lt;h:inputText value=\"#{livro.titulo}\" required=\"true\" /&gt;&lt;h:inputText value=\"#{livro.numPaginas}\"&gt; &lt;f:validateLongRange minimum=\"10\" maximum=\"9999\" /&gt;&lt;/h:inputText&gt;Exibindo Mensagens de Erro Os erros de validação são exibidos da mesma forma que os erros de conversão– Tags h:message e h:messages É possível mudar as mensagens de erro padrão do JSF através da definição de um arquivo de recursos na aplicação Também é possível utilizar o atributo validatorMessage no componente Validadores Customizados Assim como nos conversores, é possível criar validadores customizados O primeiro passo é criar uma classe que implemente Validator@FacesValidator(\"app.validator.Date\")public class DateValidator implements Validator { public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException { //... }} Depois de criado, o validador pode ser referenciado por componentes JSF&lt;h:inputText value=\"#{livro.dataPublicacao}\"&gt; &lt;f:validator validatorId=\"app.validator.Date\" /&gt;&lt;/h:inputText&gt;Validando com Métodos no Bean O JSF permite a implementação de métodos de validação, que podem ser referenciados por componentes&lt;h:inputText value=\"#{livro.preco}\" validator=\"#{livro.validarPreco}\"&gt;&lt;/h:inputText&gt;public void validarPreco(FacesContext context, UIComponent component, Object value) throws ValidatorException { //...}Ignorando a Validação Em algumas situações, ignorar a validação dos dados é necessário Para ignorar a validação, definir o atributo immediate do botão/link como true &lt;h:commandButton action=\"#{doc.processar}\" value=\"Processar\" immediate=\"true\" /&gt;" }, { "title": "Tags e Componentes do JSF - Jakarta EE", "url": "/posts/tags-componentes-jsf-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-04-30 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueTags do JS Páginas JSF são compostas por tags JSF suporta diversas bibliotecas de tags Nome Namespace Prefixo HTML http://xmlns.jcp.org/jsf/html h: Core http://xmlns.jcp.org/jsf/core f: Facelets http://xmlns.jcp.org/jsf/facelets ui: As tags padrão do HTML também são suportadas&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:h=\"http://xmlns.jcp.org/jsf/html\" xmlns:f=\"http://xmlns.jcp.org/jsf/core\"&gt;&lt;h:head&gt; ...&lt;/h:head&gt;&lt;h:body&gt; ...&lt;h:body&gt;&lt;/html&gt;O prefixo é utilizado na referência de determinada tagTags sem Representação GráficaCabeçalho da página&lt;h:head&gt; ...&lt;/h:head&gt;Corpo da página&lt;h:body&gt; ...&lt;/h:body&gt;Formulários&lt;h:form&gt; ...&lt;/h:form&gt;Referência a arquivos JavaScript&lt;h:outputScript name=\"script.js\" library=\"script\" /&gt;Referência a arquivos CSS&lt;h:outputStylesheet name=\"style.css\" library=\"css\" /&gt;Textos e ImagensExibe texto na página&lt;h:outputText value=\"Boa tarde, #{bean.nome}!\" /&gt;Exibe texto na página, possibilitando a formatação do mesmo&lt;h:outputFormat value=\"{0}, {1}!\"&gt; &lt;f:param value=\"#{bean.mensagem}\" /&gt; &lt;f:param value=\"#{bean.nome}\" /&gt;&lt;/h:outputFormat&gt;Exibe uma imagem&lt;h:graphicImage url=\"/images/figura.jpg\" /&gt;Caixas de TextoCaixa de digitação de texto&lt;h:inputText value=\"#{bean.texto}\" /&gt;Caixa de digitação de senha&lt;h:inputSecret value=\"#{bean.texto}\" /&gt;Caixa de digitação de texto em múltiplas linhas&lt;h:inputTextarea value=\"#{bean.itens}\" rows=\"3\" cols=\"10\" /&gt;Campos HiddenCampo que pertence ao formulário mas não é exibido&lt;h:inputHidden value=\"#{bean.id}\" /&gt;Seleção de Itens: CheckboxesCheckbox para um único item Mapeado para um boolean no bean&lt;h:selectBooleanCheckbox value=\"#{bean.ativo}\" /&gt;Checkbox para múltiplos itens Mapeado para um array ou coleção no bean&lt;h:selectManyCheckbox value=\"#{bean.alimentos}\"&gt; &lt;f:selectItem itemValue=\"1\" itemLabel=\"Macarrão\" /&gt; &lt;f:selectItem itemValue=\"2\" itemLabel=\"Feijão\" /&gt; &lt;f:selectItem itemValue=\"3\" itemLabel=\"Arroz\" /&gt;&lt;/h:selectManyCheckbox&gt;Checkbox para múltiplos itens com lista dinâmica&lt;h:selectManyCheckbox value=\"#{bean.alimentos}\"&gt; &lt;f:selectItems value=\"#{bean.listaAlimentos}\" /&gt;&lt;/h:selectManyCheckbox&gt;A lista de elementos é fornecida pelo bean…private SelectItem[] listaAlimentos = { new SelectItem(\"1\", \"Macarrão\"), new SelectItem(\"2\", \"Feijão\"), new SelectItem(\"3\", \"Arroz\") }; Checkbox para múltiplos itens com lista dinâmica de qualquer tipo&lt;h:selectManyCheckbox value=\"#{bean.alimentos}\"&gt; &lt;f:selectItems value=\"#{bean.listaAlimentos}\" var=\"a\" itemValue=\"#{a.id}\" itemLabel=\"#{a.nome}\" /&gt; &lt;/h:selectManyCheckbox&gt;A lista de elementos é fornecida pelo bean…private List&lt;Alimento&gt; listaAlimentos = Arrays.asList(new Alimento[] { new Alimento(1, \"Macarrão\"), new Alimento(2, \"Feijão\"), new Alimento(3, \"Arroz\") });A classe Alimento possui os atributos id e nome, e os getters/setters correspondentesSeleção de Itens: Radio ButtonsRadio button para seleção de um item entre vários&lt;h:selectOneRadio value=\"#{bean.alimento}\"&gt; &lt;f:selectItem itemValue=\"1\" itemLabel=\"Macarrão\" /&gt; &lt;f:selectItem itemValue=\"2\" itemLabel=\"Feijão\" /&gt; &lt;f:selectItem itemValue=\"3\" itemLabel=\"Arroz\" /&gt;&lt;/h:selectOneRadio&gt;A tag f:selectItems também pode ser utilizada com radio buttonsSeleção de Itens: MenusCaixa de seleção de um único item&lt;h:selectOneMenu value=\"#{bean.alimento}\"&gt; &lt;f:selectItem itemLabel=\"Selecione\" noSelectionOption=\"true\" /&gt; &lt;f:selectItem itemValue=\"1\" itemLabel=\"Macarrão\" /&gt; &lt;f:selectItem itemValue=\"2\" itemLabel=\"Feijão\" /&gt; &lt;f:selectItem itemValue=\"3\" itemLabel=\"Arroz\" /&gt;&lt;/h:selectOneMenu&gt;A tag f:selectItems também pode ser utilizada com menusSeleção de Itens: ListboxesLista de seleção de um único item&lt;h:selectOneListBox value=\"#{bean.alimento}\"&gt; &lt;f:selectItem itemValue=\"1\" itemLabel=\"Macarrão\" /&gt; &lt;f:selectItem itemValue=\"2\" itemLabel=\"Feijão\" /&gt; &lt;f:selectItem itemValue=\"3\" itemLabel=\"Arroz\" /&gt;&lt;/h:selectOneListBox&gt;Lista de seleção de múltiplos itens&lt;h:selectManyListBox value=\"#{bean.alimentos}\"&gt; &lt;f:selectItem itemValue=\"1\" itemLabel=\"Macarrão\" /&gt; &lt;f:selectItem itemValue=\"2\" itemLabel=\"Feijão\" /&gt; &lt;f:selectItem itemValue=\"3\" itemLabel=\"Arroz\" /&gt;&lt;/h:selectManyListBox&gt;A tag f:selectItems também pode ser utilizada com listboxesBotõesBotão que envia uma requisição ao servidor (POST)&lt;h:commandButton value=\"Processar Pedido\" action=\"#{bean.processar}\" /&gt;Botão que envia uma requisição ao servidor (GET)&lt;h:button value=\"Processar Pedido\" outcome=\"page\" /&gt;LinksLink que envia uma requisição ao servidor (POST)&lt;h:commandLink action=\"#{bean.processar}\"&gt; Processar Pedido&lt;/h:commandLink&gt;Link que envia uma requisição ao servidor (GET)&lt;h:link value=\"Processar Pedido\" outcome=\"page\" /&gt;Link que não submete dados ao servidor&lt;h:outputLink value=\"http://joaonogueira.dev\"&gt; João Nogueira&lt;/h:outputLink&gt;Painéis São utilizados para organizar componentes em tabelas Definidos pela tag h:panelGrid &lt;h:panelGrid columns=\"2\"&gt; &lt;f:facet name=\"header\"&gt; &lt;h:outputText value=\"Cadastro de Cliente\" /&gt; &lt;/f:facet&gt; &lt;h:outputText value=\"Nome:\" /&gt; &lt;h:inputText value=\"#{bean.nome}\" /&gt; &lt;h:outputText value=\"E-mail:\" /&gt; &lt;h:inputText value=\"#{bean.email}\" /&gt; &lt;h:outputText value=\"Endereço:\" /&gt; &lt;h:inputText value=\"#{bean.endereco}\" /&gt; &lt;h:outputText value=\"Telefone:\" /&gt; &lt;h:inputText value=\"#{bean.telefone}\" /&gt; &lt;f:facet name=\"footer\"&gt; &lt;h:commandButton value=\"OK\" action=\"#{bean.cadastrar}\" /&gt; &lt;/f:facet&gt;&lt;/h:panelGrid&gt;Agrupando Componentes Ao utilizar painéis, é possível agrupar componentes em uma mesma coluna A tag h:panelGroup é utilizada &lt;h:panelGrid columns=\"2\"&gt; &lt;h:outputText value=\"Nome:\" /&gt; &lt;h:panelGroup&gt; &lt;h:inputText value=\"#{bean.nome}\" /&gt; &lt;h:outputText value=\"Nome do cliente\"&gt;&lt;/h:outputText&gt; &lt;/h:panelGroup&gt; &lt;h:outputText value=\"E-mail:\" /&gt; &lt;h:panelGroup&gt; &lt;h:inputText value=\"#{bean.email}\" /&gt; &lt;h:outputText value=\"E-mail do cliente\"&gt;&lt;/h:outputText&gt; &lt;/h:panelGroup&gt;&lt;/h:panelGrid&gt;ID de um Componente Todo componente pode ter um ID associado Um componente com ID pode ser referenciado: – Por outros componentes JSF– No código Java– Em chamadas JavaScript&lt;h:inputText id=\"txtNome\" value=\"#{bean.nome}\" /&gt;Renderização de Componentes Todo componente pode ser renderizado ou não Isto é controlado pelo atributo rendered É possível utilizar value expressions&lt;h:inputText value=\"#{bean.nome}\" rendered=\"false\" /&gt;JavaScript e Componentes JSF É possível integrar componentes JSF com código JavaScript&lt;h:form id=\"pageForm\"&gt; &lt;h:panelGrid columns=\"3\"&gt; &lt;h:outputText value=\"Nome:\" /&gt; &lt;h:inputText id=\"txtNome\" value=\"#{bean.nome}\" /&gt; &lt;h:commandButton value=\"Excluir\" action=\"#{bean.processar}\" onclick=\"return excluir(this.form);\" /&gt; &lt;/h:panelGrid&gt;&lt;/h:form&gt;O componente deve ser referenciado como idForm:idCompfunction excluir(form) { var nome = form[\"pageForm:txtNome\"].value; if (confirm(\"Excluir o nome \" + nome + \"?\")) { return true; } return false;}Se a tag h:form tiver o atributo prependId=“false”, os componentes não recebem o ID do formulário como prefixoResources Permite referenciar recursos, que podem estar separados em bibliotecas– Imagens, arquivos CSS, arquivos JavaScriptReferenciando Resources Imagens&lt;h:graphicImage name=\"imagem.jpg\" library=\"images\" /&gt; Arquivos CSS&lt;h:outputStylesheet name=\"styles.css\" library=\"css\" /&gt; Arquivos JavaScript&lt;h:outputScript name=\"scripts.js\" library=\"javascript\" /&gt;" }, { "title": "Navegação Entre Telas - Jakarta EE", "url": "/posts/navegacao-telas-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-04-23 09:00:00 -0300", "snippet": " Baseado nos cursos da Softblue e na documentação da OracleA Importância da Navegação Aplicações normalmente são compostas por diversas telasgraph TD A[fa:fa-file-alt pg1.xhtml] --&gt; B[fa:fa-file-alt pg2.xhtml] B --&gt; C[fa:fa-file-alt pg3.xhtml] B --&gt; D[fa:fa-file-alt pg4.xhtml]Conceitos de Navegação A navegação em JSF é baseada em dois conceitos importantes– View ID Nome do arquivo que representa a página JSF Ex: form.xhtml, produtos.xhtml – Outcome String que identifica um local para navegação Um outcome é mapeado para um view ID Ex: lista_pedidos, confirmar Navegação Estática Utilizada quando a navegação de uma página para outra é sempre igualpage1.xhtml&lt;h:commandButton value=\"Próxima página\" action=\"page2\" /&gt; Um outcome pode ser mapeado a um view ID Se isto não ocorrer, ele é transformado em um view ID Navegação Dinâmica Utilizada quando a navegação depende de ações do usuário, portanto pode variar Neste caso, o outcome é o resultado de um processamento, feito pelo bean &lt;h:commandButton value=\"Login\" action=\"#{bean.login}\" /&gt; &lt;!-- O método login() é invocado no bean&gt;public String login() {//O método pode retornar um objeto de qualquer tipo (menos void). if (\"abc\".equals(name) &amp;&amp; \"123\".equals(password)) { return \"login_success\";//O método faz o processamento e retorna o outcome } return \"login_failure\";}Se o método retornar null, a mesma página é exibida novamenteRegras de Navegação Outcomes podem ser mapeados para viewIDs via arquivo de configuração Estas regras de navegação (navigation rules) são especificadas no arquivo faces-config.xml graph TD B[fa:fa-file-alt login.xhtml] B --&gt;|success| C[fa:fa-file-alt login_success.xhtml] B --&gt;|failure| D[fa:fa-file-alt login_failure.xhtml]&lt;navigation-rule&gt; &lt;from-view-id&gt;/login.xhtml&lt;/from-view-id&gt; &lt;navigation-case&gt; &lt;from-outcome&gt;success&lt;/from-outcome&gt; &lt;to-view-id&gt;/login_success.xhtml&lt;/to-view-id&gt; &lt;/navigation-case&gt; &lt;navigation-case&gt; &lt;from-outcome&gt;failure&lt;/from-outcome&gt; &lt;to-view-id&gt;/login_failure.xhtml&lt;/to-view-id&gt; &lt;/navigation-case&gt;&lt;/navigation-rule&gt;Navegação com Curingas Se a tag from-view-id for omitida, o outcome pode ser utilizado em qualquer página&lt;navigation-rule&gt; &lt;navigation-case&gt; &lt;from-outcome&gt;logout&lt;/from-outcome&gt; &lt;to-view-id&gt;/logout.xhtml&lt;/to-view-id&gt; &lt;/navigation-case&gt;&lt;/navigation-rule&gt; A utilização de curingas também é permitida&lt;navigation-rule&gt; &lt;from-view-id&gt;/admin/*&lt;/from-view-id&gt; &lt;navigation-case&gt; ... &lt;/navigation-case&gt;&lt;/navigation-rule&gt;Navegação com Base em Ações A tag from-action pode ser utilizada quando ações diferentes usam o mesmo outcome&lt;navigation-rule&gt; &lt;navigation-case&gt; &lt;from-action&gt;#{bean.listarClientes}&lt;/from-action&gt; &lt;from-outcome&gt;listar&lt;/from-outcome&gt; &lt;to-view-id&gt;/listar_clientes.xhtml&lt;/to-view-id&gt; &lt;/navigation-case&gt; &lt;navigation-case&gt; &lt;from-action&gt;#{bean.listarProdutos}&lt;/from-action&gt; &lt;from-outcome&gt;listar&lt;/from-outcome&gt; &lt;to-view-id&gt;/listar_produtos.xhtml&lt;/to-view-id&gt; &lt;/navigation-case&gt;&lt;/navigation-rule&gt;Navegação Condicional Ao utilizar a tag if, a navegação ocorre apenas se a condição for verdadeira&lt;navigation-rule&gt; &lt;navigation-case&gt; &lt;from-outcome&gt;listar&lt;/from-outcome&gt; &lt;if&gt;#{bean.canList == true}&lt;/if&gt; &lt;to-view-id&gt;/listar_clientes.xhtml&lt;/to-view-id&gt; &lt;/navigation-case&gt;&lt;/navigation-rule&gt;Mesclagem na Navegação É possível mesclar o mapeamento de outcomes via arquivo de configuração com a navegação sem o mapeamento A configuração feita no arquivo tem precedência em caso de conflito Forward x Redirect Existem duas formas de fazer o direcionamento de uma página para outra– Forward Feito internamente pelo próprio contêiner Olhando para a URL, não é possível saber para onde ocorreu o direcionamento Mantém os dados no escopo request – Redirect Feito pelo navegador, a pedido do contêiner Olhando para a URL, é possível saber para onde ocorreu o direcionamento Os dados no escopo request são perdidos Redirect no JSF O padrão do JSF é utilizar sempre o forward O redirect deve ser explícito Mudança de URL&lt;h:commandButton value=\"Logout\" action=\"logout_success?faces-redirect=true\" /&gt; O redirect também pode ser configurado na regra de navegação no faces-config.xml&lt;navigation-case&gt; &lt;from-outcome&gt;logout&lt;/from-outcome&gt; &lt;to-view-id&gt;/logout_success.xhtml&lt;/to-view-id&gt; &lt;redirect /&gt;&lt;/navigation-case&gt;Uso do Flash com Redirect Após um redirect, todas as informações do escopo request são perdidas No entanto, algumas vezes é necessário passar parâmetros para a tela de destino Isto pode ser feito com o conceito de flash graph LR A[fa:fa-file-alt] --&gt;|Redirect| B[fa:fa-file-alt] A &amp; B --&gt; C[Flash]BeanFacesContext fc = FacesContext.getCurrentInstance();ExternalContext ec = fc.getExternalContext();Flash flash = ec.getFlash();flash.put(\"param\", value);//O flash é um mapPágina JSF#{flash.param} &lt;!-- Referencia a chave do map&gt;Quando o redirect é finalizado, os dados do flash são removidos automaticamenteForward ou Redirect? O que normalmente ocorre na prática é que o redirect é utilizado após alguma operação que salva, atualiza ou exclui dados da aplicação– O redirect evita que o cliente atualize a tela e o processo seja executado de novo Nas outras situações, normalmente o forward é utilizado– Se o cliente atualizar a tela o processo é executado de novo, mas isto não traz problemasRequisições GET e POST Requisições feitas ao servidor utilizando o protocolo HTTP são normalmente dos tipos GET ou POST– GET O objetivo principal é requisitar dados do servidor Os dados são enviados diretamente na URL – POST O objetivo principal é enviar dados ao servidor Os dados são enviados no corpo do protocolo HTTP Requisições GET devem ser idempotentes: se executadas uma ou várias vezes, o resultado final será o mesmoRequisições GET e o JSF O JSF suporta a utilização de requisições GET através de duas tags– h:button– h:link&lt;h:button value=\"Pesquisar\" outcome=\"pesquisar\"&gt; &lt;f:param name=\"p\" value=\"softblue\" /&gt;&lt;/h:button&gt;Lendo Parâmetros GET em uma View Quando uma página JSF recebe parâmetros GET, os mesmos precisam ser transferidos para um bean&lt;f:metadata&gt; &lt;f:viewParam name=\"p\" value=\"#{bean.texto}\" /&gt; &lt;!-- O parâmetro p da request será copiado para a propriedade texto do bean /--&gt;&lt;/f:metadata&gt;" }, { "title": "Introdução ao JSF no Jakarta EE", "url": "/posts/introducao-jsf-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-04-16 09:00:00 -0300", "snippet": " Baseado nos cursos da Softblue e na documentação da OracleJSF JavaServer Faces Framework utilizado na geração de páginas web dinâmicas As páginas são criadas utilizando componentes, que respondem a eventos É uma especificação padronizada pela Oracle – Podem existir várias implementações Mojarra (Oracle) MyFaces (Apache) Evolução das Páginas Web em Java HTML Conteúdo estático A página é renderizada sempre da mesma forma Servlet/JSP Páginas dinâmicas Falta de recursos nativos Surgimento de frameworks para suprir as necessidades JSF As páginas são montadas utilizando componentes Estes componentes podem ser nativos ou de terceiros Semelhante à criação de interfaces gráficas em aplicações desktop Funcionamento do JSFgraph TD subgraph . A[faces-config.xml] B[Faces Servlet] --&gt; C[XHTML] --&gt;D[Beans] C --- E[Converter] C --- F[Validator] end G[fa:fa-desktop Browser] --&gt; B O formato XHTML É um formato para definição de páginas web Baseado em XML Mais rígido que o HTML quanto ao conteúdo " }, { "title": "Conceitos e arquitetura da plataforma Jakarta EE", "url": "/posts/conceitos-arquitetura-plataforma-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-04-09 09:00:00 -0300", "snippet": " Baseado nos cursos da Softblue e na documentação da OracleRamificações do Java• Java SE (Standard Edition)– Base do Java– Ambiente de execução e bibliotecas comuns• Java ME (Micro Edition)– Dispositivos móveis• Java EE (Enterprise Edition)– Aplicações corporativas e internetO Java EE• Java Enterprise Edition– Chamado antigamente de J2EE• Em 2019, a Oracle entregou o Java EE para a comunidade open source– Eclipse Foundation– Mudança de nome: Jakarta EEEspecificação do Java EE• É uma especificação escrita pela Oracle– Existe a participação de uma comunidade, que dá sugestões– Participam desta comunidade diversas pessoas e empresas• É um documento aberto– Qualquer empresa pode implementar o seu servidor compatível com Java EE• A padronização permite que a mesma aplicação execute em servidores de diferentes empresasSeparação em CamadasComponentes Java EEContainers Java EEEstrutura de Diretóriosgraph TD A[fa:fa-folder-open Browser] --- B[fa:fa-folder-open WEB-INF] A --- C[fa:fa-file-alt Arquivos XHTML, Arquivos HTML estáticos, Imagens, style sheets, etc.] B --- D[fa:fa-file-alt web.xml] B --- E[fa:fa-folder-open classes] --- F[fa:fa-file-alt *.class] B --- G[fa:fa-folder-open lib] --- H[fa:fa-file-alt *.jar]Configuração de Aplicações• Até o Java EE 5, usar arquivo web.xml era utilizado na configuração– Agora o web.xml é opcional• Grande parte das configurações é feita através de annotationsEmpacotamento de Aplicações• Uma aplicação web pode ser empacotada em apenas um arquivo– Facilita a distribuição– Facilita a instalação• Este arquivo é um WAR– Web ARchivegraph TD subgraph fa:fa-box WAR C[fa:fa-file-alt Arquivos XHTML, Arquivos HTML estáticos, Imagens, style sheets, etc.] B[fa:fa-folder-open WEB-INF] --- D[fa:fa-file-alt web.xml] B --- E[fa:fa-folder-open classes] --- F[fa:fa-file-alt *.class] B --- G[fa:fa-folder-open lib] --- H[fa:fa-file-alt *.jar] endServidor Java EE gratuito - WildFly" }, { "title": "O modelo web baseado em cliente-servidor no Jakarta EE", "url": "/posts/modelo-web-cliente-servidor-jakarta/", "categories": "Estudos-faculdade", "tags": "jakarta, java", "date": "2021-04-02 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueModelo Cliente/Servidorgraph LR A[fa:fa-desktop Browser] --&gt;|requisição| B[fa:fa-server Servidor Web] B --&gt;|resposta| AO usuário solicita a abertura de uma página HTMLA requisição trafega pela rede através do protocolo HTTPO servidor analisa a requisição e escolhe uma páginaO servidor envia a página como resposta, usando também o protocolo HTTPO browser interpreta a página que está definida em linguagem HTMLHTTP Hypertext Transfer Protocol É um protocolo de rede, responsável pela transferência de conteúdo pela internet Definido pela RFC 2616 (IETF) HTTP Específico para conteúdo web TCP Transporta os dados de forma confiável IP Move os pacotes de um computador para outro Rede Rede física (cabeada ou sem fio) HTTP RequestGET /site HTTP/1.1Host: www.joaonogueira.devConnection: closeUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; pt-BR; rv:1.9.2.3) Gecko/20100401Accept-Charset: ISO-8859-1,UTF-8;q=0.7,*;q=0.7Cache-Control: noAccept-Language: de,en;q=0.7,en-us;q=0.3HTTP ResponseHTTP/1.1 200 OKDate: Fri, 02 Abr 2023 00:04:34 GMTServer: ApacheX-Powered-By: PHP/5.2.9Set-Cookie: PHPSESSID=9709ee059903f6747abf7fa7bd8f7910; path=/Expires: Fri, 02 Abr 2021 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheConnection: closeTransfer-Encoding: chunkedContent-Type:text/htmlHTML Hypertext Markup Language É uma linguagem composta de instruções sobre como formatar uma página web Os documentos HTML são entregues ao cliente através do protocolo HTTP O conteúdo HTML é enviado logo após o response header É possível também transportar outros tipos de dados Anatomia de uma URL Uniform Resource Locator Especificam um recurso na web Protocol Server Port Path Resource http:// joaonogueira.dev :80/ posts/ post1.html Requisições: GET x POST GET– O objetivo principal é requisitar dados do servidor– Pode ser usada para enviar alguns dados ao servidor– Os dados são enviados diretamente na URL POST– O objetivo principal é enviar dados ao servidor– Os dados são enviados no corpo do protocolo HTTPA Requisição GET&lt;HTML&gt;&lt;BODY&gt;&lt;FORM method=\"GET\" action=\"sucesso.html\"&gt;&lt;!-- Indica que os dados do formulário serão enviados por uma requisição do tipo GET --&gt;Nome: &lt;INPUT type=\"text\" name=\"nome\" size=\"20\"&gt;&lt;BR&gt;E-mail: &lt;INPUT type=\"text\" name=\"email\" size=\"20\"&gt;&lt;BR&gt;&lt;INPUT type=\"submit\" value=\"Cadastrar\"&gt;&lt;!-- Botão para submeter os dados --&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;GET /public/html/sucesso.html?nome=João&amp;email=a%40a.com HTTP/1.1Host: www.joaonogueira.devUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; pt-BR; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3 (.NET CLR 3.5.30729)Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: pt-br,pt;q=0.8,en-us;q=0.5,en;q=0.3Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive: 115Connection: keep-aliveReferer: http://www.joaonogueira.dev/test/cadastro.htmlA Requisição POST&lt;HTML&gt;&lt;BODY&gt;&lt;FORM method=\"POST\" action=\"sucesso.html\"&gt;&lt;!-- Indica que os dados do formulário serão enviados por uma requisição do tipo POST --&gt;Nome: &lt;INPUT type=\"text\" name=\"nome\" size=\"20\"&gt;&lt;BR&gt;E-mail: &lt;INPUT type=\"text\" name=\"email\" size=\"20\"&gt;&lt;BR&gt;&lt;INPUT type=\"submit\" value=\"Cadastrar\"&gt;&lt;!-- Botão para submeter os dados --&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;POST /public/html/sucesso.html HTTP/1.1Host: www.joaonogueira.devUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; pt-BR; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3 (.NET CLR 3.5.30729)Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: pt-br,pt;q=0.8,en-us;q=0.5,en;q=0.3Keep-Alive: 115Connection: keep-aliveReferer: http://www.joaonogueira.dev/test/cadastro.htmlContent-Type: application/x-www-form-urlencodedContent-Length: 27nome=João&amp;email=a%40a.coQual requisição usar? GET-Formulário de pesquisa Requisição de página através de um hiperlink Navegação geral em páginas de um site POST Formulário de cadastro Envio de usuário e senha ao servidor Upload de arquivo Muitos dados a serem enviados ao servidor Existem outras operações HTTP HEAD PUT DELETE CONNECT OPTIONS TRACE PATCH Conteúdo Estático e Dinâmico Servidores web podem entregar apenas conteúdo estático (arquivos já existentes) Para gerar conteúdo dinâmico, é preciso mais do que um web server graph LR A[fa:fa-desktop Browser] --&gt;|requisição| B[fa:fa-server ] B --&gt;|resposta| A subgraph Servidor Web B[fa:fa-server ] --- C(Servlets) B --- D(JSF) endA resposta é montada dinamicamente, mas o browser continua a receber conteúdo HTML" }, { "title": "Dividindo Sistemas em Módulos no Java", "url": "/posts/dividindo-sistemas-modulos-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-03-26 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueSuporte a Módulos no Java Introduzido a partir do Java 9 Objetivos – Forte encapsulamento do código– Redução da dependência entre pacotes– Facilidade para escalar sistemas– Simplificar sistemas complexos O que é um módulo no Java?– Grupo de pacotes que contêm códigos que implementam determinada funcionalidade– Considerado um componente de software independente– Módulos podem ser combinados para criar sistemas complexosDivisão em MódulosAtivando o Uso de Módulos É preciso criar no projeto um module descriptor– module-info.javamodule dev.joaonogueira.abc {}//nome do móduloExportando Pacotes Um módulo deve exportar os pacotes que poderão ser acessados por códigos externos ao módulo Os pacotes que não estiverem listados, são visíveis apenas dentro do módulo module dev.joaonogueira.abc { exports dev.joaonogueira.abc.pack1; exports dev.joaonogueira.abc.pack2;}Dependência de Outros Módulos Quando um módulo precisa acessar código de outro módulo, é preciso que isso seja configurado de forma explícitamodule dev.joaonogueira.def { uses dev.joaonogueira.abc;}A Modularização do JDK O próprio JDK foi modularizado a partir da versão 9 do Java– 73 módulos As aplicações agora podem declarar dependência apenas dos módulos que realmente precisarem– A JVM executa de uma forma mais “leve”" }, { "title": "Internacionalização de Aplicações no Java", "url": "/posts/internacionalizacao-aplicacoes-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-03-19 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueInternacionalização É o processo de criar uma aplicação de forma que ela consiga se adaptar a várias línguas e regiões de forma automática O termo abreviado é i18n O que pode ser internacionalizado? – Textos “File” vs “Arquivo”– Números “1,540.32” vs “1.540,32”– Moedas ”$ 230.15” vs “R$ 230,15”– Datas “12/22/2030” vs “22/12/2030”Locale Um objeto Locale identifica uma combinação de língua e região (país) Construtores de Locale Locale loc = new Locale(\"pt\");Locale loc = new Locale(\"pt\", \"BR\"); Método forLanguageTag() (Java 7+)Locale loc = Locale.forLanguageTag(\"pt-BR\"); Constantes pré-definidasLocale loc = Locale.UK;Locale loc = Locale.JAPAN;Locale padrão Toda aplicação Java tem um Locale padrão Ele é determinado pela JVM a partir de configurações definidas no sistema operacional É possível obter o Locale padrão via programação Locale loc = Locale.getDefault();A classe ResourceBundle Armazenam informações que podem variar de acordo com o Locale estabelecido As informações são baseadas em pares de chave e valor Dados podem ser armazenados de duas formas – Arquivo de propriedades Chave do tipo String Valor do tipo String – Classe Chave do tipo String Valor do tipo Object Arquivos de propriedadesApplication.properties:# Itens do menu (inglês)i1 = Newi2 = Openi3 = Savei4 = ExitApplication_pt_BR.properties:# Itens do menu (português)i1 = Novoi2 = Abriri3 = Salvari4 = SairClassepublic class Application extends ListResourceBundle { private static Object[][] contents = { { \"i1\", \"New\" }, { \"i2\", \"Open\" }, { \"i3\", \"Save\" }, { \"i4\", \"Exit\" }, }; protected Object[][] getContents() { return contents; }}public class Application_pt_BR extends ListResourceBundle { private static Object[][] contents = { { \"i1\", \"Novo\" }, { \"i2\", \"Abrir\" }, { \"i3\", \"Salvar\" }, { \"i4\", \"Sair\" }, }; protected Object[][] getContents() { return contents; }}Lendo os dados Criar um LocaleLocale l = new Locale(\"pt\", \"BR\"); Obter uma instância de ResourceBundleResourceBundle bundle = ResourceBundle.getBundle(\"Application\", l);ResourceBundle bundle = ResourceBundle.getBundle(\"Application\"); Ler os dados a partir das chavesString s = bundle.getString(\"i1\");String s = (String) bundle.getObject(\"i1\");Ordem de pesquisa Um ResourceBundle precisa definir de onde ele carregará as informações Exemplo – Bundle name = Application– Locale = en-US– Default Locale = pt-BRSempre defina um arquivo/classe sem sufixoArquivos de propriedades:Application_en_US.propertiesApplication_en.propertiesApplication_pt_BR.propertiesApplication_pt.propertiesApplication.propertiesClassesApplication_en_USApplication_enApplication_pt_BRApplication_ptApplicationMensagens compostas Mensagens às vezes precisam ser compostas por partes fixas e variáveisPortuguês: Fui ao shopping e comprei 2 camisas. Custou R$ 200,00.Inglês: I went to the mall and bought 2 shirts. It cost $ 200.00.Application_pt_BR.properties:msg = Fui ao shopping e comprei {0,number} {1}. Custou {2,number,currency}.i = camisasApplication_en_US.properties:msg = I went to the mall and bought {0,number} {1}. It cost {2,number,currency}.i = shirts Criar o Locale e o ResourceBundleLocale loc = new Locale(\"pt\", \"BR\");ResourceBundle bundle = ResourceBundle.getBundle(\"Application\", loc); Criar o array de parâmetrosObject[] msgArgs = { new Integer(2), bundle.getString(\"i\"), 200.0}; Gerar a mensagem finalString msgTemplate = bundle.getString(\"msg\");MessageFormat formatter = new MessageFormat(msgTemplate);formatter.setLocale(loc);String msg = formatter.format(msgArgs);Formatação de números Diferentes localizações representam números e moedas de formas diferentesNumberFormat nf = NumberFormat.getNumberInstance(new Locale(\"pt\", \"BR\"));nf.format(1540.36);//1.540,36NumberFormat nf = NumberFormat.getNumberInstance(new Locale(\"en\", \"US\"));nf.format(1540.36);//1,540.36Formatação de moedas As moedas também variam de acordo com a localizaçãoNumberFormat nf = NumberFormat.getCurrencyInstance(new Locale(\"pt\", \"BR\"));nf.format(1540.36);//R$ 1.540,36NumberFormat nf = NumberFormat.getCurrencyInstance(new Locale(\"en\", \"US\"));nf.format(1540.36);//$1,540.36Formatação de datas Datas são representadas de formas diferentes em diferentes localizaçõesDateFormat df = DateFormat.getDateInstance(DateFormat.LONG, new Locale(\"pt\", \"BR\"));df.format(new Date());//22 de Setembro de 2030DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, new Locale(\"en\", \"US\"));df.format(new Date());//September 22, 2030Formatação de horas Horas também são representadas de formas diferentes em diferentes localizaçõesDateFormat df = DateFormat.getTimeInstance(DateFormat.MEDIUM,new Locale(\"pt\", \"BR\"));df.format(new Date());//15:34:45DateFormat df = DateFormat.getTimeInstance(DateFormat.Medium, new Locale(\"en\", \"US\"));df.format(new Date());//3:34:45 PM" }, { "title": "Os formatos XML e JSON no Java", "url": "/posts/formatos-xml-json-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-03-12 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueIntrodução XML– Extensible Markup Language Linguagem de marcação para descrever dados estruturados&lt;Clientes&gt; &lt;Cliente id=\"1\"&gt;; &lt;Nome&gt;João da Silva&lt;/Nome&gt; &lt;Email&gt;joao@email.com&lt;/Email&gt; &lt;/Cliente&gt; &lt;Cliente id=\"2\"&gt; &lt;Nome&gt;Maria Silva&lt;/Nome&gt; &lt;Email&gt;maria@email.com&lt;/Email&gt; &lt;/Cliente&gt;&lt;/Clientes&gt;XML x HTML Assim como no HTML, XML é baseado em tags Em XML, as tags podem ser definidas pelas aplicações XML é muito mais rígido quanto ao formato do documento – Todos os elementos devem estar definidos de acordo com a especificaçãoXML - Características XML possibilitou fácil integração de sistemas multiplaforma– É um padrão aberto e independente de fornecedor e dispositivo O sucesso do XML também se deve à grande quantidade de código pronto– Facilita a manipulação de documentosValidação A validação do documento pode ser feita no momento da sua leitura É possível validar documentos XML usando – DTD– XML SchemaValidação: DTD A DTD descreve como um documento XML deve ser Utiliza uma linguagem própria Caiu em desuso, pois foi substituída pelo XML Schema Validação: XML Schema O XML Schema descreve como um documento XML deve ser Utiliza a própria linguagem XML para especificar documentos XML É o modo de validação mais utilizado atualmente É mais poderoso que o DTD Manipulação de Documentos XML A manipulação de documentos pode ser feita pelas APIs– DOM– SAX A partir do Java 1.4, implementações de ambas as APIs estão disponíveis no JDKDOM Document Object Model API fácil e intuitiva Cria uma árvore de objetos em memória Esta árvore representa a estrutura do documento XML Desvantagem – Ocupa muita memóriaSAX Não é tão intuitiva quanto a DOM SAX é baseada em eventos – Funções de callback são invocadas durante o parsing do documento Como não cria uma estrutura em memória, é aconselhada para documentos XML extensosO formato JSON JavaScript Object Notation Formato de representação de dados – Baseado em texto– Independente de linguagem– Mais simples que o formato XML Baseado em duas estruturas– Pares de chave e valor– Sequência ordenada de elementos{\"id\":1,\"nome\":\"João da Silva\",\"email\":\"joao@email.com\"}[10,true,\"A\"]Um conjunto de dados é delimitado por chaves ({ e })Cada dado é separado do outro por vírgula (,)A chave e o valor de um dado é separada por dois pontos (:)Sequências de dados são delimitadas por colchetes ([ e ])A API Gson Uma das APIs disponíveis para manipular dados no formato JSON em Java– http://code.google.com/p/google-gson O ponto forte do Gson é a conversão de objetos Java em dados no formato JSON e vice-versa Utilização da API – Baixar o código-fonte na página oficial– Adicionar o JAR da API ao classpath da aplicaçãoClasses importantes da API Gson– Principal classe da API– Possui métodos para manipular os dadosGson gson = new Gson();Cliente c = new Cliente(1, \"João da Silva\", \"joao@email.com\");String jsonStr = gson.toJson(c);//Converte para JSONCliente c = gson.fromJson(jsonStr, Cliente.class);//Converte para objeto JsonElement– Representa um elemento JSON– Subclasses JsonObject, JsonArray, JsonPrimitive e JsonNullJsonObject obj = new JsonObject();obj.add(\"id\", new JsonPrimitive(1));obj.add(\"nome\", new JsonPrimitive(\"João da Silva\"));obj.add(\"email\", new JsonPrimitive(\"joao@email.com\"));//Adiciona os elementosString jsonStr = gson.toJson(obj);//Converte para JSON" }, { "title": "JavaFX - Tópicos Avançados no Java", "url": "/posts/javafx-topicos-avancados-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-03-05 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueFXML Existem duas formas de criar interfaces gráficas em JavaFX Programação FXML O desenho da interface fica misturado com o código Java A interface é definida em formato XML, separada do código Java   Facilita a manutenção   Não há necessidade de recompilar o código   Designers não precisam ter experiência em Java   Forma preferida para criar interfaces Comparando: Via programaçãoBorderPane root = new BorderPane();MenuBar menuBar = new MenuBar();menuBar.getMenus().add(new Menu(\"Arquivo\"));root.setTop(menuBar);TextArea textArea = new TextArea();root.setCenter(textArea);Button btnCancel = new Button(\"Cancelar\");Button btnSave = new Button(\"Salvar\");HBox buttonBox = new HBox();buttonBox.setAlignment(Pos.CENTER_RIGHT);buttonBox.setPadding(new Insets(5, 0, 5, 0));HBox.setMargin(btnSave, new Insets(0, 0, 0, 5));buttonBox.getChildren().add(btnCancel);buttonBox.getChildren().add(btnSave);root.setBottom(buttonBox); Via FXML&lt;?import javafx.scene.layout.BorderPane?&gt;&lt;?import javafx.scene.control.Button?&gt;&lt;?import javafx.scene.control.MenuBar?&gt;&lt;?import javafx.scene.control.Menu?&gt;&lt;?import javafx.scene.control.TextArea?&gt;&lt;?import javafx.scene.layout.HBox?&gt;&lt;?import javafx.geometry.Insets?&gt;&lt;BorderPane xmlns:fx=\"http://javafx.com/fxml/1\"&gt; &lt;top&gt; &lt;MenuBar&gt;&lt;Menu text=\"Arquivo\" /&gt;&lt;/MenuBar&gt; &lt;/top&gt; &lt;center&gt;&lt;TextArea /&gt;&lt;/center&gt; &lt;bottom&gt; &lt;HBox alignment=\"CENTER_RIGHT\"&gt; &lt;padding&gt; &lt;Insets top=\"5\" left=\"0\" bottom=\"5\" right=\"0\" /&gt; &lt;/padding&gt; &lt;Button text=\"Cancelar\" /&gt; &lt;Button text=\"Salvar\"&gt; &lt;HBox.margin&gt; &lt;Insets top=\"0\" bottom=\"0\" right=\"0\" left=\"5\" /&gt; &lt;/HBox.margin&gt; &lt;/Button&gt; &lt;/HBox&gt; &lt;/bottom&gt;&lt;/BorderPane&gt;Criando os layouts FXML Os arquivos FXML são baseados no padrão XML Podem ser criados de duas formas – Manualmente, usando um editor de textos ou editor de arquivos XML– Através de ferramentas específicas, onde a construção do layout é feita de forma visual O Scene Builder é uma ferramenta gratuita da Oracle que permite a criação de arquivos FXML Layouts criados em FXML podem ser facilmente importados para dentro do JavaFX Pane root = FXMLLoader.load(getClass().getResource(\"/Layout.fxml\"));Controller O controller é uma classe Java que trabalha em conjunto com a estrutura definida no arquivo FXMLpackage joaonogueira.javafx;public class LayoutController { //...}&lt;BorderPane xmlns:fx=\"http://javafx.com/fxml/1\" fx:controller=\"joaonogueira.javafx.LayoutController\"&gt; ...&lt;/BorderPane&gt; O controller pode ter acesso aos controles definidos no arquivo FXML Também trata os eventos ...&lt;TextArea fx:id=\"textArea\" /&gt;...&lt;Button text=\"Cancelar\" onAction=\"#cancel\" /&gt;&lt;Button text=\"Salvar\" onAction=\"#save\"&gt;...public class LayoutController { @FXML//@FXML faz a ligação dos elementos do arquivo FXML com o código Java private TextArea textArea; public void initialize() { }//initialize() é utilizado na inicialização do controller @FXML public void save() { } @FXML public void cancel(ActionEvent event) { }//O parâmetro ActionEventé opcional}Aplicando estilos com CSS O Cascading Style Sheets (CSS) é comumente usado em páginas web Também é aplicado para alterar o comportamento visual dos painéis e controles do JavaFX -styles.css.text-field { -fx-font: 16px \"Serif\"; -fx-font-weight: bold; -fx-background-color: #CCFF99;}#meutexto { -fx-font-size: 30;}.warning { -fx-background-color: \"yellow\";}-Layoult.fxml&lt;TextField text=\"Estou aprendendo JavaFX!\" /&gt;&lt;Label text=\"Meu texto\" fx:id=\"meutexto\" /&gt;&lt;Label text=\"Atenção!\" styleClass=\"warning\" /&gt;-App.javaTextField textField = new TextField(\"Estou aprendendo JavaFX!\");Label label1 = new Label(\"Meu texto\");label1.setId(\"meutexto\");Label label2 = new Label(\"Atenção!\");label2.getStyleClass().add(\"warning\"); Usar um arquivo CSS não é obrigatório-Layoult.fxml&lt;Label text=\"Texto em negrito\" style=\"-fx-font-weight: bold\"/&gt;-App.javaLabel label3 = new Label(\"Negrito\");label3.setStyle(\"-fx-font-weight: bold\"); Um arquivo CSS deve ser associado à uma cena para que os estilos sejam reconhecidosScene scene = new Scene(root, 800, 600);scene.getStylesheets().add(\"styles.css\");Properties &amp; Binding Uma property é uma característica de um objeto– Uma espécie de “atributo mais inteligente” O binding permite ligar properties com objetivo de sincronizaçãoa.propA.bind(b.propB) Uma property pode ser vista como um atributo, mas tem mais recursos Tipos de properties – StringProperty– IntegerProperty– DoubleProperty– BooleanProperty– ObjectPropertypublic class Pessoa {//Os controles do JavaFX também usam properties private StringProperty nome = new SimpleStringProperty();//nome e idade são properties do JavaFX private IntegerProperty idade = new SimpleIntegerProperty(); ...}Convenções no uso de propertiespublic class Pessoa { private StringProperty nome = new SimpleStringProperty(); private IntegerProperty idade = new SimpleIntegerProperty(); public String getNome() {//Getters e setters manipulam as properties return nome.get(); } public void setNome(String nome) { this.nome.set(nome); } public int getIdade() { return idade.get(); } public void setIdade(int idade) { this.idade.set(idade); } public StringProperty nomeProperty() {//Métodos xxxProperty() retornam as properties return nome; } public IntegerProperty idadeProperty() { return idade; }}O Modelo JavaBean Um JavaBean é uma classe que segue algumas convenções– Construtor padrão, sem parâmetros– Métodos getters e setterspublic class Pessoa { private String nome; private int idade; public String getNome() { return nome; } public void setNome(String nome) { this.nome = nome; } public int getIdade() { return idade; } public void setIdade(int idade) { this.idade = idade; }}Os nomes dos métodos getters e setters seguem uma convenção bem definidaAdicionando listeners a properties Quando uma property é alterada, ela notifica listeners registradospessoa.nomeProperty().addListener(new ChangeListener&lt;String&gt;() { @Override public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) { ... }});pessoa.nomeProperty().addListener((observable, oldValue, newValue) -&gt; {//Expressão lambda ...});As classes de properties implementam a interface ObservableValue&lt;T&gt;Bindings Property -&gt; ObservableValuepublic class LayoutController { @FXML TextField txtNome; public void initialize() { Pessoa pessoa = ... txtNome.textProperty().bind(pessoa.nomeProperty());//O texto TextField vai ficar sincronizado com o nome definido no objeto }}Tipos de bindings UnidirecionaltxtNome.textProperty().bind(pessoa.nomeProperty()); BidirecionaltxtNome.textProperty().bindBidirectional(pessoa.nomeProperty());//Apenas entre propertiesJavaFX e as threads O JavaFX possui uma thread principal– JavaFX Application thread– UI thread Esta thread tem uma série de atribuições: Renderizar Tela, Processar Eventos, …Se esta thread demorar para executar, a aplicação vai parecer lentaSolução: realizar o processamento “pesado” em outra thread Uma nova thread pode ser criada utilizando qualquer técnica já conhecidanew Thread(new Runnable() { public void run() { //... }}).start();ExecutorService exec = Executors.newSingleThreadExecutor();exec.submit(new Callable&lt;Void&gt;() { public Void call() throws Exception { //... return null; }});A classe Task O JavaFX define uma classe Task, que deve ser estendida Representa uma tarefa a ser executada em segundo plano public class MyTask extends Task&lt;Integer&gt; {//O tipo parametrizado define o tipo de retorno de call() @Override protected Integer call() throws Exception { //... }} Ciclo de vida de um objeto Task:graph TD A[objeto criado] --&gt; B(Ready) --&gt;|agendado para execução| C(Scheduled) C --&gt;|começa a executar| D(Running) D --&gt;|finaliza com sucesso| E(Succeeded) --- F[A property value é definida com o valor retornado pela tarefa] D --&gt;|exceção é lançada| G(Failed) --- H[A property exception é definida com a exceção lançada] D --&gt;|usuário cancela a tarefa| I(Canceled)Métodos da classe Task Métodos que podem ser sobrescritos– done()– failed()– cancelled()– running()– scheduled()– succeeded() Métodos de atualização da tarefa– updateProgress()– updateMessage()– updateTitle()Os métodos updateXXX() atualizam o valor das properties do objeto TaskCancelamento de tarefas O método cancel() deve ser chamado na tasktask.cancel(); A tarefa deve verificar periodicamente se ela foi canceladawhile(...) { if (isCancelled()) { //... break; }}A classe Service É utilizada para executar uma Taskpublic class MyService extends Service&lt;Integer&gt; { @Override protected Task&lt;Integer&gt; createTask() {//Cria a Task que será executada return new Task&lt;Integer&gt;() { //... }; }} Execução do serviceMyService service = new MyService();service.setOnSucceeded((event) -&gt; ...);service.setOnFailed((event) -&gt; ...);//Adiciona listeners ao service, para serem executados pela UI threadservice.start();//Inicia execução em segundo planoComunicação entre threads Apenas a UI thread pode manipular elementos da interface gráficaPlatform.runLater(new Runnable() { @Override public void run() { //... }});Mudanças feitas em properties públicas de uma task são executadas sempre pela UI thread" }, { "title": "JavaFX - Conceitos e Fundamentos no Java", "url": "/posts/javafx-conceitos-fundamentais-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-02-26 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueO JavaFX JavaFX é uma tecnologia composta por um conjunto de APIs Criação de rich client applications – Ex: formulários, gráficos, multimídia, gráficos 2D e 3D, etc. JavaFX é totalmente feito em Java– Integração com as APIs do Java já conhecidas– Suporte multiplataformaArquitetura do JavaFXEstrutura de cenaApenas uma cena pode estar visível por vezpublic class MainApp extends Application { public static void main(String[] args) { launch(args); } @Override public void init() { //... } @Override public void start(Stage primaryStage) { Button btn = new Button(\"Aperte aqui\"); StackPane root = new StackPane(); root.getChildren().add(btn); Scene scene = new Scene(root, 400, 300); primaryStage.setTitle(\"JavaFX App\"); primaryStage.setScene(scene); primaryStage.show(); }} Layout panes Os nós devem ser organizados na tela na montagem da interface gráfica A melhor forma de organizá-los é através dos painéis de layout Tipos – HBox– VBox– BorderPane– AnchorPane– StackPane– GridPane– FlowPane– TilePaneHBox Organiza os nós horizontalmenteHBox box = new HBox();box.getChildren().add(node);VBox Organiza os nós verticalmenteVBox box = new VBox();box.getChildren().add(node);BorderPane 5 regiões: top, bottom, left, right, centerBorderPane pane = new BorderPane();pane.setTop(node1);pane.setBottom(node2);pane.setLeft(node3);pane.setRight(node4);pane.setCenter(node5);AnchorPane Permite ancorar os nós nos cantosAnchorPane pane = new AnchorPane();pane.getChildren().addAll(node1, node2);AnchorPane.setRightAnchor(node1, 5.0);AnchorPane.setTopAnchor(node1, 5.0);AnchorPane.setLeftAnchor(node2, 5.0);AnchorPane.setBottomAnchor(node2, 5.0);StackPane Empilha os nósStackPane pane = new StackPane();pane.setAlignment(Pos.CENTER_RIGHT);StackPane.setMargin(btn3, new Insets(20, 20, 0, 0));pane.getChildren().addAll(node1, node2, node3);GridPane Organiza em linhas e colunasGridPane pane = new GridPane();pane.add(node1, 0, 0);pane.add(node2, 0, 1);pane.add(node3, 1, 0);pane.add(node4, 1, 1);FlowPane Organiza em linhas ou colunas e faz a quebra se não houver espaçoFlowPane pane = new FlowPane();pane.setOrientation(Orientation.HORIZONTAL);pane.getChildren().addAll(node1, node2, node3, node4, node5, node6);TilePane Organiza os nós como o FlowPane, mas em células com o mesmo tamanhoTilePane pane = new TilePane();pane.setOrientation(Orientation.VERTICAL);pane.getChildren().addAll(node1, node2, node3, node4, node5, node6);ControlesEventos Eventos são ações disparadas em resposta a alguma ação do usuário– Tecla pressionada, mouse clicado, janela redimensionada, etc. Alguns exemplos– KeyEvent– MouseEvent– ActionEvent– WindowEventEvent Handlers Quando um evento é disparado, determinado código pode ser executado em resposta à ocorrência do evento Este código é um event handler Button btn = new Button(\"OK\");btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() { @Override public void handle(ActionEvent event) { //... }}); EventHandler é uma interface funcional É possível utilizar expressões lambda Button btn = new Button(\"OK\");btn.setOnAction(event -&gt; doSomething());" }, { "title": "Acessando Bancos de Dados com JDBC no Java", "url": "/posts/acessando-bancos-dados-jdbc-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-02-19 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueIntrodução ao JDBC Aplicações podem se conectar a diversos tipos de bancos de dados Alteração de código quando o banco de dados fosse alterado JDBC – Java Database Connectivity Surgiu para flexibilizar aplicações É uma camada intermediária entre a aplicação Java e os bancos de dados Possibilita alteração de banco de dados sem alteração no código – Desde que sejam utilizadas apenas chamadas SQL padronizadas Livra o programador da responsabilidade de entender e programar a comunicação com o banco de dadosArquiteturagraph TD subgraph Usadas pelas aplicações A[ResultSet] --- B[Statement] --- C[Connection] D[ResultSet] --- E[PreparedStatement] --- C end C --- F[DriverManager] F --- G[Oracle Driver] --- H[(Oracle Database)] F --- I[ODBC Driver] --- J[(ODBC Database)] F --- K[MySQL Driver] --- L[(MySQL Database)]Todas as classes e interfaces fazem parte do pacote java.sql Classe Descrição DriverManager Gerencia o driver e cria uma conexão com o banco de dados Connection Representa a conexão com o banco de dados Statement Controla e executa uma instrução SQL PreparedStatement Controla e executa uma instrução SQL já preparada no banco de dados ResultSet Contém o conjunto de dados retornado por uma consulta SQL ResultsetMetaData Trata dos metadados dos dados retornados do banco de dados DatabaseMetaData Trata dos metadados do banco de dados Abrindo uma conexão Carregamento do driverClass.forName(\"org.postgresql.Driver\"); Abertura de conexãoConnection conn = DriverManager.getConnection(\"jdbc:postgresql://localhost:5432/nomedb\", \"user\", \"pwd\");As interfaces Statement e PreparedStatementA interface Statement Usada para executar comandos no banco de dados Método Descrição executeQuery() - Executa queries do tipo SELECT - Retorna os resultados em um ResultSet executeUpdate() - Executa queries do tipo INSERT, UPDATE ou DELETE - Retorna o número de registros afetados pela query O objeto da interface Statement é obtido através da interface ConnectionString sql = \"INSERT INTO cliente VALUES (1, 'Cliente 1')\";Statement stmt = conn.createStatement();stmt.executeUpdate(sql);stmt.close(); É recomendado o uso do mesmo Statement para executar diversas instruções no banco de dados O Statement deve ser fechado após a última vez que for usado, através do método close() A interface PreparedStatement A interface PreparedStatement é capaz de pré-compilar comandos a serem executados no banco de dados– Aumento significativo de performance Possibilita facilidades na passagem de parâmetros ao comando SQLString sql = \"INSERT INTO cliente VALUES (?, ?)\";PreparedStatement stmt = conn.prepareStatement(sql);stmt.setInt(1, 1);stmt.setString(2, 'Cliente 1');stmt.executeUpdate();stmt.close();A interface ResultSet Contém os dados retornados pelo banco de dados após a execução de um comando SELECT Possui o método next(), que permite iterar sobre todos os dados retornados pelo banco de dados String sql = \"SELECT id, nome FROM cliente\";Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery(sql);while(rs.next()) { int id = rs.getInt(\"id\"); String nome = rs.getString(\"nome\");}stmt.close(); A interface ResultSet possui métodos que já fazem a conversão do dado para os tipos de dados do Java– getInt(), getString(), getDouble(), etc. É possível obter o valor de um campo através do seu nome, alias ou posição no ResultSetTrabalhando com metadados Interface DatabaseMetaData– Possibilita obter informações a respeito do servidor de banco de dados, como bancos de dados disponíveis, esquemas criados, tabelas, etc.– É obtido através do método getMetaData() da interface Connection Interface ResultSetMetaData– Possibilita obter informações relativas aos dados de um ResultSet, como número de colunas, tipo de dado das colunas, etc.– É obtido através do método getMetaData() da interface ResultSetTransações O assunto transações é abrangente e complexo É importante saber que transações devem ser atômicas – Tudo executa ou nada executa JDBC permite trabalhar com transações em banco de dados Para iniciar uma transação, o auto-commit da conexão deve ser mudado para false, para possibilitar o controle manual da transação Os métodos commit() e rollback() devem ser usados ao término da transação try { conn.setAutoCommit(false); //execução das queries Dentro da transação conn.commit();} catch(SQLException e) { conn.rollback();}Conhecendo a SQLException Praticamente todos os métodos do JDBC lançam exceções do tipo SQLException A classe SQLException possui métodos importantes Método Descrição getMessage() Retorna a mensagem de erro getSQLState() Retorna um dos códigos de estado do padrão ANSI-92 SQL getErrorCode() Retorna o código de erro específico do fornecedor getNextException() Retorna a exceção aninhada, se houver Atualizações em lote JDBC permite agrupar comandos de atualização no banco de dados e mandá-los todos de uma só vez, ao invés de mandá-los um a um (batch) Grande melhora de performance quando da necessidade da atualização de muitos dados String sql = \"INSERT INTO cliente VALUES (?, ?)\";Statement stmt = conn.prepareStatement(sql);stmt.setInt(1, 1);stmt.setString(2, 'Cliente 1');stmt.addBatch();stmt.setInt(1, 2);stmt.setString(2, 'Cliente 2');stmt.addBatch();stmt.executeBatch();stmt.close();Conclusões sobre performance Prefira sempre os PreparedStatements aos Statements Se precisar inserir, atualizar ou excluir dados em lote, use a facilidade de batching do JDBC Mesmo trazendo facilidades, JDBC é complicado por expor a linguagem SQL ao programador Como a linguagem SQL usada nem sempre é padrão entre todos os bancos de dados, às vezes é preciso mudar o código ao mudar o banco de dados Para tentar facilitar, foram criados frameworks ORM (Object-RelationalMapping) O objetivo é que o programador trabalhe apenas com objetos, e não se preocupe com a organização dos dados em tabelas do banco de dados ou linguagem SQL O maior e melhor framework representante desta categoria é o Hibernate – http://www.hibernate.org O sucesso do Hibernate inspirou a criação da JPA (Java Persistence API) pela Oracle" }, { "title": "I/O com a NIO.2 API em Java", "url": "/posts/io-nio.2-api-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-02-12 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueNIO.2 API x Legacy I/O API O Java conta com uma API de I/O desde a sua primeira versão– Esta API tem algumas limitações A New I/O (NIO.2) API surgiu para resolver os problemas que a API legada possui A NIO.2 API surgiu com o Java 7 A tendência é que ela substitua a API de I/O legada gradualmente A interface Path O sistema de arquivos define caminhos para diretórios e arquivos Windows C:\\Users\\Me\\MyFile.txt Unix/home/me/Myfile.txt Um objeto Path representa um caminho– Pode ser de um arquivo ou diretório– O arquivo ou diretório não precisam necessariamente existirManipulando objetos Path A classe Paths possui métodos estáticos, que permitem manipular objetos PathPath p = Paths.get(\"C:\\\\Users\\\\Me\\\\MyFile.txt\");//Cria um objeto Path com base no caminho especificadoPath p = Paths.get(\"C:\", \"Users\", \"Me\", \"MyFile.txt\");//Cria um objeto Path juntando partes do caminho É comum haver situações onde dois ou mais objetos Path precisam ser juntados para gerar um Path completoPath dir = Paths.get(\"/home/me\");Path file = Paths.get(\"MyFile.txt\");Path path = dir.resolve(file);Path path = dir.resolve(\"MyFile.txt\"); ///home/me/MyFile.txtMétodos úteis da classe PathsPath p = Paths.get(\"C:\\\\Users\\\\Me\\\\MyFile.txt\"); Método Retorno p.toString() “C:\\Users\\Me\\MyFile.txt” p.getFileName() “MyFile.txt” p.getParent() “C:\\Users\\Me” p.getNameCount() 3 p.getName(1) “Me” p.subPath(0, 2) “Users\\Me” p.getRoot() “C:\" Path p = Paths.get(\"files\\MyFile.txt\"); Método Retorno p.toAbsolutePath() “C:\\DiretorioCorrente\\files\\MyFile.txt” A classe Files Possui métodos estáticos que permitem manipular arquivosPath path = Paths.get(\"/home/me/MyFile.txt\")boolean exists = Files.exists(path);//Verifica se o arquivo ou diretório existe Outros métodos de Files Método Descrição isReadable(path) Permite leitura? isWritable(path) Permite escrita? isExecutable(path) Pode ser executado? isDirectory(path) É um diretório? isHidden(path) Está oculto? size() Retorna o tamanho em bytes Operações em arquivos e diretórios ExcluirFiles.delete(path);Files.deleteIfExists(path); CopiarFiles.copy(sourcePath, targetPath);Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); MoverFiles.move(sourcePath, targetPath);Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);Lendo e escrevendo dadosInputStream in = Files.newInputStream(path);//Arquivos bináriosBufferedReader reader = Files.newBufferedReader(path);//Arquivos textoInputStream e BufferedReadersão classes que fazem parte da API legada de I/Obyte[] bytes = Files.readAllBytes(path);List&lt;String&gt; lines = Files.readAllLines(path);//Recomendados para arquivos menoresOutputStream out = Files.newOutputStream(path);//Arquivos bináriosBufferedWriter writer = Files.newBufferedWriter(path);//Arquivos textoOutputStream e BufferedWriter são classes que fazem parte da API legada de I/OFiles.write(path, bytes);Files.write(path, lines);//Recomendados para arquivos menoresO enum StandardOpenOptions Várias operações de manipulação de arquivos e diretórios solicitam parâmetros que definem o comportamento destas operações Elemento do enum Descrição WRITE Arquivo para escrita. APPEND Faz append de dados. TRUNCATE_EXISTING Faz o truncamento do arquivo. CREATE_NEW Cria um novo arquivo. Se ele existir, lança exceção. CREATE Se o arquivo existir, abre. Se não existir, cria. DELETE_ON_CLOSE Exclui o arquivo quando a stream é fechada. Criando arquivos Arquivos regularesPath file = Files.createFile(path); Arquivos temporáriosPath file = Files.createTempFile(\"files_\", \".temp\");//C:\\Users\\Me\\AppData\\Local\\Temp\\files_1365648452074156411.tempCriando diretórios Diretórios regularesPath dir = Files.createDirectory(path);Path dir = Files.createDirectories(path);//Cria vários níveis de diretórios Diretórios temporáriosPath dir = Files.createTempDirectory(\"temp_\");//C:\\Users\\Me\\AppData\\Local\\Temp\\temp_6589015846917767979Conteúdo de um diretório A interface DirectoryStream permite iterar sobre o conteúdo de um diretóriotry (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir)) { for (Path path : stream) { //... }} É possível filtrar por padrões no nometry (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, \"*.txt\") {//Glob for (Path path : stream) { //... }}Para saber mais sobre o glob, consulte o javadoc de FileSystem.getPathMatcher()Criando filtros de conteúdos Nem sempre o uso do glob atende às necessidades de filtragem– Ele se baseia apenas em padrões de nome Nestes casos é preciso implementar um filtro customizadoDirectoryStream.Filter&lt;Path&gt; filter =file -&gt; Files.isDirectory(file);// Expressão lambda para o método accept()DirectoryStream&lt;Path&gt; s = Files.newDirectoryStream(dir, filter)) {Iterando sobre a árvore de diretórios A interface FileVisitor possui 4 métodos que devem ser implementados– preVisitDirectory()– postVisitDirectory()– visitFile()– visitFileFailed() É possível também estender a classe SimpleFileVisitor O método Files.walkFileTree() é chamado para iniciar a iteração Watch Service API Permite que a aplicação seja notificada quando um diretório ou arquivo é criado, excluído ou modificadoWatchService watcher = FileSystems.getDefault().newWatchService();WatchKey key = dir.register(watcher,ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); Deve existir um loop na aplicação que fica recebendo os eventosIntegrando NIO.2 com a Legacy I/O API Aplicações antigas (anteriores ao Java 7) não tiveram acesso à NIO.2 API Para que estas aplicações não precisem ser reescritas, existe uma forma de integrar a API legada de I/O com a NIO.2 API Path path = file.toPath();File file = path.toFile();" }, { "title": "Tópicos Avançados de I/O em Java", "url": "/posts/topicos-avancados-io-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-01-29 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueArgumentos de linha de comando O Java permite que argumentos de linha de comando sejam fornecidos para a aplicação Estes argumentos podem ser lidos pelo programa JVM Classe Argumentos java aplicacao.ClassePrincipal 123 abc Lendo os argumentos Os argumentos passados em linha de comando são passados como parâmetro para o método main()public static void main(String[] args) { String arg1 = args[0];//\"123\" String arg2 = args[1];//\"abc\"}args.length retorna o número de argumentosA classe java.util.Properties Representa uma coleção similar a um Map Mapeia uma chave a um valor Ainda bastante usada para ler arquivos de configuração escritos na forma “chave = valor” # Arquivo 'config.txt'# Configurações da aplicaçãonomeAplicacao = Minha Aplicaçãoversao = 1.0debug = trueLendo e escrevendo em arquivos de propriedades O carregamento dos dados do arquivo pode ser feito automaticamente para dentro de um objeto da classe PropertiesProperties props = new Properties();FileInputStream fis = new FileInputStream(\"config.txt\");props.load(fis);fis.close();String nomeAplicacao = props.getProperty(\"nomeAplicacao\");String versao = props.getProperty(\"versao\");String debug = props.getProperty(\"debug\"); Com o Properties é possível também salvar os dados num arquivo de configuraçãoProperties props = new Properties();props.setProperty(\"nomeAplicacao\", \"Minha Aplicação\");props.setProperty(\"versao\", \"1.0\");props.setProperty(\"debug\", \"true\");FileOutputStream fos = new FileOutputStream(\"config_save.txt\");props.store(fos, \"Gerado pela Aplicação\");fos.close(); Arquivo de saída gerado (config_save.txt)#Gerado pela Aplicaçãoversao=1.0debug=truenomeAplicacao=Minha Aplicação Para mais informações sobre a classe Properties, consulte o JavadocSerialização de objetos Serializar significa transformar em bytes Objetos são serializados para que possam ser: – transferidos pela rede– armazenados no disco rígidoA interface Serializable Deve ser implementada pelas classes cujos objetos serão serializadospublic class Mensagem implements Serializable {} Esta interface não possui qualquer método que deva ser implementado pela classeObjectInputStream Classe usada para criar uma stream de entrada de onde podemos ler objetosObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"out.bin\"));//O construtor recebe uma InputStreamMessage m = (Message) ois.readObject();ois.close();ObjectOutputStream Classe usada para criar uma stream de saída onde podemos escrever objetosMessage m = new Message(\"texto\");ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"out.bin\"));//O construtor recebe uma OutputStreamoos.writeObject(m);oos.close();Serialização dos atributos Quando um objeto serializado possui referências a outros objetos, estes objetos também são serializados– Todos os objetos referenciados pela classe devem implementar a interface Serializable É possível descartar atributos da serialização usando o modificador transientpublic class Mensagem { private transient String tempMsg;}Controlando a serialização Existem duas formas de ter total controle sobre a serialização– Implementando os métodos: writeObject(ObjectOutputStream out) readObject(ObjectInputStream in)– Implementando a interface Externalizable: writeExternal(ObjectOutput out) readExternal(ObjectInput in) A JVM chama os métodos caso eles existamControle de versão Quando um objeto é serializado, a JVM cria um código numérico para a classe– Este código não é randômico– É baseado nos nomes dos atributos e assinaturas dos métodos da classe Este número identifica a classe, de forma que se algo na classe mudar, este número também muda Ao tentarmos ler um objeto serializado depois que a classe for modificada, uma InvalidClassException será lançada Nem sempre este comportamento é desejado Para evitar que isso aconteça, devemos fornecer este número de versionamento manualmente private static final long serialVersionUID = 1415906L; Isto garante que o processo de leitura de um objeto serializado será feito de forma correta" }, { "title": "Programação Distribuída com RMI em Java", "url": "/posts/programacao-distribuida-rmi-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-01-22 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueIntrodução ao RMI Remote Method Invocation Permite chamar métodos em objetos que podem estar espalhados ela rede Baseado numa arquitetura cliente/servidor RMI registry É um repositório de objetos remotos Permite a localização de objetos por nome Deve ser executado em algum computador da rede e seu endereço deve ser conhecido graph TD A[Objeto Remoto] --&gt;|O objeto remoto é registrado no registry| B(RMI Registry) C[Cliente] --&gt;|O cliente busca o objeto no registry pelo nome| BTrabalhando com objetos remotosA interface do objeto remotopublic interface Calc extends Remote {//A interface deve estender java.rmi.Remote public int somar(int x, int y) throws RemoteException;//Os métodos declarados serão acessíveis remotamente public int subtrair(int x, int y) throws RemoteException;//Todos os métodos devem lançar java.rmi.RemoteException}Implementando os métodospublic class CalcImpl extends UnicastRemoteObject implements Calc {//Tipicamente extende UnicastRemoteObject, classe que implementa a interface Calc public CalcImpl() throws RemoteException { } @Override//Implementação dos métodos da interface public int somar(int x, int y) { return x + y; } @Override public int subtrair(int x, int y) { return x - y; }}Registrando o objetoCalc c = new CalcImpl();//Cria o objetoRegistry registry = LocateRegistry.createRegistry(1099);//Inicia o RMI registry na porta 1099registry.rebind(\"calc\", c);//Registra o objeto no registry com o nome calcImplementando um clienteString url = \"rmi://localhost:1099/calc\";//Constrói a URL usada na busca do objetoCalc calc = (Calc) Naming.lookup(url);//Procura o objeto no registry e recebe a sua referênciaint r = calc.somar(10, 20));//Invoca o método no objeto remotoStubs e skeletonsgraph LR A(Cliente) --&gt; B(Stub) B --&gt;|Rede| C(Skeleton) C --&gt; D(Calclmpl) O stub é um representante do objeto remoto no cliente. É implementado pelo Java. O skeleton recebe as informações pela rede e invoca o objeto real. É implementado pelo Java. Objetos das classes que trafegam pela rede devem implementar Serializable RMI registry e os stubsgraph LR A(Objeto Remoto) --&gt;|O stub do objeto é registrado no registry| B(RMI Registry) C(Cliente) --&gt;|O cliente busca o objeto pelo nome| B B --&gt;|O cliente recebe o stub do objeto remoto| C C --&gt; D((Stub)) D --&gt;|Quando o cliente invoca o método usando o stub, a chamada trafega pela rede e é feita no objeto remoto| A" }, { "title": "Programação em Rede com Sockets TCP/IP e UDP/IP", "url": "/posts/programacao-rede-sockets/", "categories": "Estudos-faculdade", "tags": "redes, web", "date": "2021-01-15 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueO que são sockets Mecanismo de comunicação entre dois programas que funcionam na mesma rede Modelo cliente/servidor – Uma aplicação servidor é executada numa determinada máquina e tem um socket ligado a uma porta específica dessa máquina– O servidor espera que um cliente faça um pedido de ligação através desse socketSockets TCP/IP Existe uma conexão entre o cliente e o servidor– Permite utilização de fluxos de dados (streams) A comunicação é confiável– Sem perda de dados– Sem inversão de ordem dos pacotesgraph TD A[O cliente tenta se conectar ao servidor por uma porta] --- B[fa:fa-desktop Cliente] B --- C[fa:fa-door-open Porta] B --- D[ ] D --&gt;|requisição de conexão| E[fa:fa-door-open Porta] E --- F[fa:fa-server Servidor] F --- G[fa:fa-door-open Porta] G --&gt;|dados| C C --&gt;|dados| G F --- H[O servidor conecta o cliente numa nova porta, por onde é feito o tráfego dos dados]Sockets UDP/IP Não existe uma conexão entre o cliente e o servidor– Envio de datagramas (remetente, receptor, conteúdo) A comunicação não é confiável– Dados podem ser perdidos– Datagramas podem chegar fora de ordem Muito mais veloz que sockets TCP/IPgraph TD A[O cliente manda datagramas para o servidor] --- B[fa:fa-desktop Cliente] B --&gt;|fa:fa-file envio de datagramas| E[fa:fa-door-open Porta] E --- F[fa:fa-server Servidor]Multicast Envio de datagramas para um grupo de destinatários Utiliza protocolo UDP Grupos multicast (IPs classe “D”) – de 224.0.0.0 a 239.255.255.255graph TD A[O cliente manda uma mensagem para um grupo] --- B[fa:fa-desktop Cliente] B --&gt; C((Grupo Multicast)) C --&gt; D[fa:fa-desktop] &amp; E[fa:fa-desktop] &amp; F[fa:fa-desktop] D &amp; E &amp; F --- G[Os computadores cadastrados no grupo recebem a mensagem]" }, { "title": "Concorrência e Paralelismo com java.util.concurrent", "url": "/posts/concorrencia-paralelismo-java.util.concurrent/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-01-08 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueIntrodução Mecanismos para trabalhar com programação concorrente– Classe Thread– Interface Runnable– Modificador synchronized– Métodos wait(), notify() e notifyAll() A partir da versão 5 do Java foi introduzido o pacote java.util.concurrent, que criou novos mecanismos para trabalhar com programação concorrente Além do pacote java.util.concurrent, existem também outros dois novos pacotes: – java.util.concurrent.locks– java.util.concurrent.atomic Estes três pacotes incorporam novas funcionalidades para trabalhar com threads:– Executores de tarefas– Coleções que suportam concorrência– Pool de threads– Operações atômicas com variáveis– Comunicação entre threads com uso de condições– etc.Threads “Processos Leves” Uma thread representa uma linha de execução em um processo Um processo pode ter uma ou mais threads executando simultaneamente As threads compartilham recursos do processo Interfaces Runnable e CallableRunnable Esta interface é implementada por classes que desejam ter seu código executado em uma thread separada A classe deve implementar o método run() public class Localizador implements Runnable {\tpublic void run() {\t\t//código da thread\t}} A interface Runnable tem dois problemas– O método run() não pode retornar dados– O método run() não pode lançar checked exceptionsCallable Criada para resolver os problemas da interface Runnablepublic class Localizador implements Callable&lt;String&gt; {//O tipo de retorno do método call() é parametrizado\tpublic String call() throws Exception {//O método pode lançar exceções\t\t//código da thread\t}}Criando e executando threads Usando o novo pacote java.util.concurrent você não precisa mais lançar mão da classe Thread para criar e executar threads A criação e execução das threads fica a cargo dos executores (executors) Trabalhando com uma thread: public class Handler implements Runnable {\tpublic void run() {\t\t//código da thread\t}}ExecutorService e = Executors.newSingleThreadExecutor();//Cria um executor para uma threade.execute(new Handler());//Recebe um Runnable como parâmetro e o executae.shutdown(); Trabalhando com um pool de threads fixo:public class Handler implements Runnable {\tpublic void run() {\t\t//código da thread\t}}ExecutorService e = Executors.newFixedThreadPool(5);//Cria um executor baseado num pool de threads de tamanho fixoe.execute(new Handler());//Recebe um Runnable como parâmetro e o executae.shutdown();Sincronização Existem porções de código que não podem ser executadas por duas threads ao mesmo tempo– Região crítica O Java trabalha com o conceito de monitor, que garante esta sincronização– Um monitor pode ser qualquer objeto– Cada monitor possui um lock, que é entregado à thread que acessa a região crítica– O modificador synchronized é usado para delimitar a região crítica– Threads sem lock aguardam Com a chegada do pacote java.util.concurrent.locks, não é mais necessário usar o modificador synchronized Um novo conceito de lock é usado no lugar: – ReentrantLock– ReentrantReadWriteLockReentrantLock Quando a thread chama o método lock() no objeto, ela possui acesso exclusivo, até que chame o método unlock() Se outra thread tentar chamar o método lock() neste meio tempo, ficará aguardando ReentrantLock l = new ReentrantLock();l.lock();//Garante acesso exclusivo ao códigotry {\t//região crítica} finally {\tl.unlock();//Libera o acesso para outras threads}ReentrantReadWriteLock Possui um par de locks: um para leitura e outro para escrita O lock de leitura pode ser obtido por múltiplas threads simultaneamente Na hora em que uma thread possui o lock de escrita, ela tem acesso exclusivo (nenhuma outra thread pode estar lendo ou escrevendo) ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();Lock r = rwl.readLock();Lock w = rwl.writeLock();Os métodos lock() e unlock() são invocados para obter e liberar os locksComunicação entre threads Na forma “clássica”, a comunicação entre threads era feita usando três métodos– wait()– notify()– notifyAll() No pacote java.util.concurrent.locks, são usadas as condições (conditions)ReentrantLock l = new ReentrantLock();Condition c = l.newCondition();//Cria uma condiçãol.lock();try {\twhile (count &lt; 10) {\t\tc.await();//Faz a thread dormir até que ela seja avisada de que pode acordar\t}\tc.signal();//Acorda uma thread que estava aguardando} finally {\tl.unlock();} Forma Clássica Usando Condições wait() await() notify() signal() notifyAll() signalAll() Tarefas futuras Às vezes você precisa iniciar uma thread para realizar um processamento assíncrono e esta thread vai retornar um valor no futuro O pacote java.util.concurrent tem a classe FutureTask que serve para este propósito public class Somador implements Callable&lt;Integer&gt; {\tprivate int x;\tprivate int y;\t\tpublic Somador(int x, int y) {\t\tthis.x = x;\t\tthis.y = y;\t}\t\tpublic Integer call() throws Exception {\t\treturn x + y;\t}}ExecutorService e = Executors.newSingleThreadExecutor();Somador s = new Somador(10, 5);FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(s);//Uma FutureTask usa um Callable para realizar a tarefae.execute(task);int soma = task.get();//O método get() retorna o resultado vindo do Callable.e.shutdown();O método get() bloqueia até que o resultado esteja disponívelOperações atômicas Em um ambiente multithread às vezes é necessário sincronizar o acesso a uma variável para garantir a consistência do seu valor O pacote java.util.concurrent.atomic possui classes que fazem operações de forma atômica em variáveis sem o uso de locks Existem diversas classes que suportam este tipo de operação atômica – AtomicInteger– AtomicIntegerArray– AtomicBoolean– AtomicBooleanArray– etc. Todas elas funcionam de forma semelhanteAtomicInteger i = new AtomicInteger(10);//Representa o 10int valor = i.incrementAndGet();//Incrementa o valor e retorna o novo valor (operação atômica)AtomicIntegerArray a = new AtomicIntegerArray(new int[]{1, 2, 3});//Representa um arrayint valor = a.getAndDecrement(1);//Retorna o valor do índice 1 do array e decrementa o valor (operação atômica) Programação paralela com a API Fork &amp; Join Executar tarefas ao mesmo tempo buscando um objetivo comum O Java sempre deu suporte à programação concorrente A partir do Java 7, a linguagem passa a ter suporte à programação paralela – Fork &amp; Join API Por que programação paralela?– Computadores e dispositivos multicore– Divisão de uma tarefa “pesada” em tarefas mais “leves” Soma de valores de um array A Fork &amp; Join API permite o uso de programação paralela Ela é baseada na divisão de um problema em problemas menores, dividindo a tarefa entre os processadores Baseada em duas operações – Fork: cria uma subtarefa para ser executada de forma assíncrona– Join: aguarda até que a subtarefa seja completadagraph TD A(Tarefa) --&gt;|Fork| B(Subtarefa) A --&gt;|Fork| C(Subtarefa) B --&gt;|Join| A C --&gt;|Join| A B --&gt;|Fork| D(Subtarefa) B --&gt;|Fork| E(Subtarefa) D --&gt;|Join| B E --&gt;|Join| BCriando tarefas Uma tarefa deve ser uma classe que herde de RecursiveTask ou RecursiveActiongraph TD A[Tarefa retorna alguma informação] --- B[RecursiveTask] C[Tarefa não retorna informação] --- D[RecursiveAction] B --&gt; E[ForkJoinTask] D --&gt; Epublic class SumArray extends RecursiveTask&lt;Long&gt; {\tpublic Long compute() {\t\tSumArray subTask = new SumArray();\t\tsubTask.fork();//Submete uma subtarefa para execução\t\t// Faz o processamento necessário...\t\tLong result = subTask.join();//Aguarda a subtarefa terminar\t}} O início da execução da tarefa é feito através do método invoke() da classe ForkJoinPoolSumArray task = new SumArray();ForkJoinPool pool = new ForkJoinPool();//Cria um pool de threadsLong result = pool.invoke(task);//Executa a tarefa e fica aguardando o resultadoUsar ou não usar paralelismo? A programação paralela só pode ser usada quando– Uma tarefa pode ser dividida em subtarefas– Uma subtarefa não depende do resultado de outras subtarefas Testes são necessários para encontrar o grau de paralelismo que vai trazer o maior ganho de performance– Em alguns casos o uso do paralelismo pode deixar o código mais lento" }, { "title": "Manipulando Coleções com a Stream API em Java", "url": "/posts/manipulando-colecoes-stream-api-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2021-01-01 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueO que é a Stream API API que permite combinar operações– Usada principalmente em coleções do Java Introduzida no Java 8 Aproveita o uso de expressões lambda Funciona bem para coleções pequenas e também para coleções muito grandes – Usa a abordagem de lazy evaluation A Stream API permite encadear as operações (pipeline)List&lt;Integer&gt; newList = list.stream()\t.sorted()\t.filter(e -&gt; e &gt;= 2 &amp;&amp; e &lt;= 8)\t.map(e -&gt; e * e)\t.collect(Collectors.toList());O tipo Stream As coleções List e Set possuem o método stream()Stream&lt;Integer&gt; stream = list.stream(); O objeto Stream é a porta de entrada para a Stream API O tipo parametrizado T depende do tipo da coleção Para arrays, o código muda int[] array = new int[10];Stream&lt;int[]&gt; stream = Stream.of(array);Operações A Stream API possui uma série de operações para manipulação de dados 2 tipos Intermediárias Retornam um novo objeto Stream Possibilitam o pipeline Ex: sorted(), limit(), filter(), map() Terminais Geram um resultado final (redução) Finalizam o uso da stream Ex: collect(), reduce(), count(), max() sorted() Ordena os elementos da coleção Permite fornecer ou não um Comparator Operação intermediária stream.sorted((e1, e2) -&gt; e1.getNome().compareTo(e2.getNome())) //Expressão lambda que substitui uma instância de Comparator&lt;T&gt;limit() Define um tamanho máximo para a coleção Os elementos que excedem o limite fornecido são removidos Operação intermediária Só os 10 primeiros elementos são mantidosfilter() Filtra os resultados de acordo com um critério Recebe um parâmetro Predicate Operação intermediária stream.filter(e -&gt; e &gt; 10);//Expressão lambda que determina a filtragem de elementos maiores que 10distinct() Remove elementos duplicados Operação intermediária stream.distinct();map() Mapeia um elemento em outro elemento (transformação) Recebe um parâmetro Function&lt;T, R&gt; Operação intermediária stream.map(e -&gt; e + 2);//Expressão lambda que incrementa 2 unidades a cada elemento Existem também mapeamentos especializados– mapToInt() −&gt; IntStream– mapToDouble() −&gt; DoubleStream– mapToLong −&gt; LongStreamcollect() Finaliza o pipeline, gerando um resultado Operação terminal A classe Collectors tem métodos estáticos que auxiliam nesta operação Exemplos: stream.collect(Collectors.toList())// List&lt;T&gt;stream.collect(Collectors.toSet())// Set&lt;T&gt;stream.collect(Collectors.counting())// Longstream.collect(Collectors.summingInt(e -&gt; e.getIdade()))// Integercount() Faz a contagem de elementos Operação terminal long c = stream.count();Referenciando construtores Além de referenciar métodos, é possível também referenciar construtorespublic class Pessoa {\tprivate String nome;\tpublic Pessoa(String nome) {\t\tthis.nome = nome;\t}}List&lt;String&gt; nomes = Arrays.asList(\"José\", \"Maria\", \"Pedro\");List&lt;Pessoa&gt; pessoas = nomes.stream()\t.map(Pessoa::new) //Equivale a: .map(e -&gt; new Pessoa(e))\t.collect(Collectors.toList());Streams paralelas Uma stream paralela pode ser processada simultaneamente por vários núcleos de processamentoList&lt;Integer&gt; list = list.parallelStream()\t.sorted()\t.map(e -&gt; e * e)\t.collect(Collectors.toList()); Para que o resultado seja consistente, as operações intermediárias precisam ser independentes" }, { "title": "Expressões Lambda em Java", "url": "/posts/expressoes-lambda-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-12-25 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueExpressões Lambda Maior inovação da versão 8 do Java O nome lambda vem do conceito matemático de cálculo lambda Expressões lambda trazem o Java mais próximo do paradigma de programação funcional Uma expressão lambda pode ser considerada como um objeto – Pode ser referenciada por uma variável– Pode ser passada como parâmetro para métodos e utilizada como retorno Em Java, uma expressão lambda é utilizada em substituição a uma inner class anônimaRunnable r = new Runnable() {\t@Override\tpublic void run() { //Inner class anônima\t\tSystem.out.println(\"ABC\");\t}};new Thread(r).start();Runnable r = () -&gt; System.out.println(\"ABC\");//Expressão lambdanew Thread(r).start();new Thread(() -&gt; System.out.println(\"ABC\")).start();//Expressão lambdaResultado: código mais simples e intuitivo Uma expressão lambda é representada da seguinte forma:(Parâmetros) -&gt; { Corpo } //operador arrowExemplos de sintaxe:Interfaces funcionais Uma interface funcional tem duas características É uma interface Possui apenas 1 método Uma expressão lambda pode ser atribuída a uma variável de uma interface funcionalRunnable r = () -&gt; System.out.println(\"ABC\");Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareTo(s2);Comparable&lt;String&gt; c = s -&gt; 0;ActionListener l = e -&gt; System.out.println(\"123\");Interfaces que já pertenciam ao Java agora passam a ser interfaces funcionais@FunctionalInterface Esta annotation define uma interface como interface funcional@FunctionalInterfacepublic interface Generator {\tpublic String generate();} Seu uso não é obrigatório Se @FunctionalInterface for utilizada, o compilador checa se a interface define apenas 1 método Interface funcional: Predicate@FunctionalInterfacepublic interface Predicate&lt;T&gt; {\tboolean test(T t);}Predicate&lt;String&gt; p = s -&gt; s.length() &gt; 5; //true se o tamanho da String for maior do que 5 O tipo T define o tipo a ser testado Retorna um boolean Interface funcional: Consumer@FunctionalInterfacepublic interface Consumer&lt;T&gt; {void accept(T t);}Consumer&lt;Integer&gt; c = i -&gt; System.out.println(i);//Processa i escrevendo o seu valor no console O tipo T define o tipo a ser processado Não retorna informação (void) Interface funcional: Function&lt;T, R&gt;@FunctionalInterfacepublic interface Function&lt;T, R&gt; {\tR apply(T t);}Function&lt;String, Integer&gt; f = s -&gt; Integer.parseInt(s);//Transforma uma String em um int O tipo T define o tipo de origem O tipo R define o tipo de destino a ser retornado Novas funcionalidades em coleções A Collections API ganhou novas funcionalidades para aproveitar o uso de expressões lambdaList&lt;Integer&gt; l = new ArrayList&lt;&gt;();l.add(1);l.add(2);l.add(3);l.forEach(item -&gt; System.out.println(item));//Consumer&lt;T&gt;l.removeIf(item -&gt; item % 2 == 0);//Predicate&lt;T&gt;Referências a métodos Permite converter métodos já existentes em expressões lambdal.forEach(item -&gt; System.out.println(item));l.forEach(System.out::println);//Operador double colon (::)Os parâmetros da expressão lambda são repassados para o métodoClosures Expressões lambda têm a capacidade de acessar variáveis definidas externamente Este recurso é denominado closure int mult = 2;//Variável definida fora da expressão lambdaFunction&lt;Integer, Integer&gt; f = (x -&gt; x * mult);System.out.println(f.apply(5));Variáveis externas acessadas por expressões lambda são implicitamente definidas como final No caso da variável externa ser um atributo de classe, o final implícito não se aplica O valor considerado é o do momento da execução public class MyClass {\tprivate int mult = 2;\tpublic void executar() {\t\tFunction&lt;Integer, Integer&gt; f = (x -&gt; x * mult);\t\tmult = 5;\t\tSystem.out.println(f.apply(5));//Imprime o valor 25\t}}" }, { "title": "Inner Classes em Java", "url": "/posts/inner-classes-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-12-18 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueIntrodução Inner classes são classes declaradas dentro de outras classesclass MyOuter { //Outer class\tclass MyInner { //Inner class\t}} Quando compiladas, geram bytecodes diferentes– MyOuter.class– MyOuter$MyInner.class As inner classes podem ser divididas em 4 tipos– Regular inner class– Method-local inner class– Anonymous inner class– Static inner classRegular inner class Declarada como membro de uma classe Possui acesso aos elementos da classe dentro da qual está inserida public class MyOuter {\tprivate int n = 10;\tprivate class MyInner {\t\tpublic void imprimirN() {\t\t\tSystem.out.println(n); //A inner class enxerga o atributo n\t\t}\t}} Uma instância de uma inner class não pode existir sem estar associada a uma instância de uma outer class Normalmente é a outer class que instancia a inner class public class MyOuter {\tprivate class MyInner {\t\t//...\t}\tpublic void criarInner() {//A instanciação é feita como se fosse com qualquer outra classe\t\tMyInner i = new MyInner();\t}} O operador this referencia o próprio objeto Dentro de uma inner class, this referencia a instância da inner class public class MyOuter {\tprivate class MyInner {\t\tpublic void m() {\t\t\tSystem.out.println(\"Ref inner: \" + this);\t\t\tSystem.out.println(\"Ref outer: \" + MyOuter.this);//Para referenciar a outer class\t\t}\t}}Method-local inner class Declarada dentro de um método Apenas o método enxerga a classe public class MyOuter {\tpublic void m() { \t\tclass MyInner {\t\t\tpublic void imprimirMensagem() {\t\t\t\tSystem.out.println(\"Mensagem!\");\t\t\t}\t\t}\t\tMyInner i = new MyInner();\t\ti.imprimirMensagem();\t}} A inner class pode acessar variáveis locais do método, desde que estas sejam final ou não tenham seu valor alteradopublic class MyOuter {\tpublic void m() { \t\tfinal String msg = \"Mensagem!\";//final pode ser omitido\t\tclass MyInner {\t\t\tpublic void imprimirMensagem() {\t\t\t\tSystem.out.println(msg);\t\t\t}\t\t}\t\tMyInner i = new MyInner();\t\ti.imprimirMensagem();\t}}Anonymous inner class Não possui nome Classes anônimas são sempre subclasses de uma classe ou implementação de uma interface Sobrescrevem ou implementam métodos da superclasse ou interface public class Porta {\tpublic void abrir() {\t\tSystem.out.println(\"abrir\");\t}}public class Casa {\tprivate Porta p = new Porta() { //Classe anônima sendo uma subclasse de Porta\t\tpublic void abrir() {\t\t\tSystem.out.println(\"porta anônima\");\t\t}\t};\tpublic void m() {//O método invocado é o método sobrescrito\t\tp.abrir();\t}} Exemplo: Usando um java.util.Comparator– Interface que possui o método compare()Comparator&lt;String&gt; comparator = new Comparator&lt;String&gt;() {\tpublic int compare(String o1, String o2) {\t\treturn o1.compareTo(o2) * -1;//A classe anônima implementa a interface Comparator\t}};TreeSet&lt;String&gt; s = new TreeSet&lt;String&gt;(comparator);//A referência ao objeto é usada no construtor do TreeSet O exemplo pode ser simplificado ainda maisTreeSet&lt;String&gt; s = new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() {\tpublic int compare(String o1, String o2) {\t\treturn o1.compareTo(o2) * -1;\t}}); Neste exemplo a classe anônima é passada diretamente como parâmetro para o construtor do TreeSetStatic inner class Não é realmente uma inner class porque não tem um relacionamento especial com a outer class Ela é apenas uma classe declarada dentro de outra classe Basta declarar a classe como static public class MyOuter {\tstatic class MyInner {\t\tpublic void imprimir() {\t\t\tSystem.out.println(\"Mensagem!\");\t\t}\t}}MyOuter.MyInner i = new MyOuter.MyInner();i.imprimir(); Uma static inner class famosa no Java é a Map.Entry, cujos objetos são retornados quando o método entrySet() é invocado" }, { "title": "Annotations e a Reflection API no Java", "url": "/posts/annotations-reflection-api-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-12-11 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueAnnotations Mecanismo criado a partir do Java 5 São declarações no código que podem ser usadas por ferramentas ou programas externos Não influenciam diretamente na execução do código @ClassInfo(autor = \"João Nogueira\", data = \"11/12/2020\")public class MyClass {\t...}public @interface ClassInfo { //declaração\tString autor();\tString data();\tint versao() default 1; //valor padrão} Quando a annotation possui apenas um elemento value, ele pode ser omitido quando a anotação é usadapublic @interface Autor {\tString value();}@Autor(\"João Nogueira\")public class MyClass() {\t...}@Retention Configura como a anotação deve se comportar perante ao compilador e à JVM Tipos RetentionPolicy.RUNTIME A anotação pode ser lida em tempo de execução pela JVM RetentionPolicy.CLASS A anotação é lida pelo compilador mas não pode ser lida em tempo de execução RetentionPolicy.SOURCE A anotação é ignorada pelo compilador @Retention(RetentionPolicy.RUNTIME)public @interface ClassInfo {\tString autor();\tString data();\tint versao() default 1;}@Target Indica em qual elemento a annotation pode ser aplicada Tipos ElementType.TYPE Classe, interface ou enum ElementType.METHOD Métodos ElementType.FIELD Atributos etc. @Target(ElementType.TYPE)public @interface ClassInfo {\tString autor();\tString data();\tint versao() default 1;}@Override Indica que um método sobrescreve outro É opcional, mas quando utilizada gera erro de compilação se o método anotado não estiver sobrescrevendo um método da superclasse @Overridepublic String toString() { //Se o método toString() não existir na superclasse, gera erro de compilação\treturn \"...\";}@SuppressWarnings Utilizada para remover mensagens de warning do código O seu uso mais comum é para remover mensagens de conversão de tipos quando o generics é utilizado Pode anotar classes, métodos e código List&lt;String&gt; l = new ArrayList();//Warning: “The expression of type ArrayList needs unchecked conversion to conform to List&lt;String&gt;”@SuppressWarnings(\"unchecked\")List&lt;String&gt; l = new ArrayList();//O warning desapareceReflection API A Reflection API do Java permite que as classes conheçam sobre suas estruturas internas O ponto de entrada é um objeto Class, que guarda informações sobre uma classe Class c = String.class;Class c = Class.forName(\"java.lang.String\");Class&lt;String&gt; c = String.class;Class&lt;String&gt; c = (Class&lt;String&gt;) Class.forName(\"java.lang.String\");O objeto Class O objeto Class pode representar também outros elementos que não sejam classes, como interfaces e enums A partir do objeto Class, é possível descobrir quais são os atributos, construtores e métodos Método Descrição getFields() Retorna um array de atributos getField() Retorna um atributo específico getConstructors() Retorna um array de construtores getConstructor() Retorna um construtor específico getMethods() Retorna um array de métodos getMethod() Retorna um método específico Instanciando objetos Com a Reflection API, é possível instanciarmos objetos quando conhecemos apenas o nome da classeClass c = Class.forName(\"dev.joaonogueira.MyClass\");MyClass m = (MyClass) c.getDeclaredConstructor().newInstance();Invocando métodos Outro uso comum da Reflection API é para invocar métodosClass c = Class.forName(\"dev.joaonogueira.MyClass\");MyClass o = (MyClass) c.getDeclaredConstructor().newInstance();Method m = c.getMethod(\"imprimir\", String.class);//Procura o método imprimir() da classe, que recebe uma String como parâmetrom.invoke(o, \"algum texto\");//Invoca o método m no objeto o, passando o parâmetro para o método" }, { "title": "Generics em Java", "url": "/posts/generics-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-12-04 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueIntrodução O Generics foi introduzido a partir do Java 5 Similar aos templates em C++ Permitem a parametrização de tipos de dados Sem generics:List strings = new ArrayList();strings.add(\"abc\");strings.add(\"def\"); strings.add(new Integer(1));String s = (String) strings.get(0);Com generics:List&lt;String&gt; strings = new ArrayList&lt;String&gt;();strings.add(\"abc\");strings.add(\"def\"); strings.add(new Integer(1)); //Não compila porque o objeto não é uma StringString s = strings.get(0);Definindo uma classe com genericspublic class Gerenciador {\t\tprivate Object obj; //O uso de Object possibilita que qualquer objeto seja utilizado\t\tpublic void setObjeto(Object obj) {\t\tthis.obj = obj;\t}\tpublic Object getObjeto() {\t\treturn obj;\t}}Casa c = new Casa();Gerenciador g = new Gerenciador();g.setObjeto(c);c = (Casa) g.getObjeto();public class Gerenciador&lt;T&gt; {\t\tprivate T obj; //Agora o tipo do dado é parametrizável\tpublic void setObjeto(T obj) {\t\tthis.obj = obj;\t}\tpublic T getObjeto() {\t\treturn obj;\t}}Casa c = new Casa();Gerenciador&lt;Casa&gt; g = new Gerenciador&lt;Casa&gt;();g.setObjeto(c); //Apenas uma instância de Casa pode ser fornecidac = g.getObjeto(); //O casting não é necessárioGenerics e as subclasses Suponha que existem as classes– Animal– Cachorro (estende de Animal) O código abaixo funciona normalmenteCachorro[] cachorros = new Cachorro[2];cachorros[0] = new Cachorro();cachorros[1] = new Cachorro();Animal[] animais = cachorros; //É possível atribuir um array de Cachorro a um array de Animal devido à herançaO mesmo código usando generics:List&lt;Cachorro&gt; cachorros = new ArrayList&lt;Cachorro&gt;();cachorros.add(new Cachorro());cachorros.add(new Cachorro());List&lt;Animal&gt; animais = cachorros; //Não é possível atribuir, mesmo sendo uma lista da subclasse Em generics, a atribuição só pode ser feita se o tipo parametrizado é o mesmoWildcard Utilizado para deixar em aberto o tipo parametrizado Representado por “?” public void imprimir(Collection&lt;?&gt; c) { //A coleção pode ser de qualquer tipo\tfor(Object o : c) {\t\tSystem.out.println(o);\t}}Wildcard e o extends Quando é necessário deixar o tipo do dado em aberto mas garantir que este tipo deve estender de determinada classe, é possível usar o extendspublic void imprimir(Collection&lt;? extends Animal&gt; c) { //A coleção pode ser de qualquer tipo que seja uma subclasse de Animal ou a própria classe Animal\tfor(Animal a : c) {\t\ta.andar();\t}} Quando a restrição deve ser feita a classes que implementam uma interface, o extends também é usadopublic void imprimir(Collection&lt;? extends Comparable&gt; c) { //Comparable é uma interface, mas o extends é usado mesmo assim\t//...}Quando o extends é usado, não é possível adicionar elementosWildcard e o super Quando é necessário deixar o tipo do dado em aberto mas garantir que este tipo deve ter uma determinada superclasse, é possível usar o superpublic void imprimir(Collection&lt;? super Cachorro&gt; c) { //A coleção pode ser de qualquer tipo que seja uma superclasse de Cachorro ou a própria classe Cachorro\t//...}Quando o super é usado, a coleção pode receber novos elementosDefinindo métodos com generics Além do tipo parametrizado poder ser definido a nível de classe, ele também pode ser definido a nível de métodoprivate &lt;T&gt; List&lt;T&gt; criarLista(T e) { //T é o tipo parametrizado\tList&lt;T&gt; l = new ArrayList&lt;T&gt;();\tl.add(e);\treturn l;}List&lt;String&gt; l1 = criarLista(\"a\");List&lt;Integer&gt; l2 = criarLista(2); //A lista é criada e retornada com o tipo do parâmetro" }, { "title": "Desenvolvendo com o uso do Maven em Java", "url": "/posts/desenvolvendo-maven-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-11-27 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueO Maven O Maven é um projeto da Apache– Open source Objetivos principais– Gerenciamento de build– Geração de relatórios– Geração de documentação Baseado no conceito de POM– Project Object ModelFuncionamento do Maven:Estrutura de um projeto Maven O Maven define uma estrutura base para os projetos JavaO arquivo pom.xml Descreve as características do projeto, dependências, plug-ins a serem executados, etc.&lt;project&gt;\t&lt;modelVersion&gt;1.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;dev.joaonogueira&lt;/groupId&gt;\t&lt;artifactId&gt;example&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/project&gt; Conceitos– Group ID• Normalmente referencia a empresa– Artifact ID• Nome do artefato ou projeto– Version• Versão do artefatoGerenciamento de dependências O Maven é capaz de gerenciar dependências de outros artefatos de forma automática– JARs– Projetos O arquivo pom.xml define a dependência– A dependência é baixada do repositório central e fica armazenada no repositório local– Dependências transitivas também são resolvidas automaticamente– O projeto passa a referenciar o artefato Exemplo de dependência da API Apache Commons I/O&lt;project&gt;\t&lt;modelVersion&gt;1.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;dev.joaonogueira&lt;/groupId&gt;\t&lt;artifactId&gt;example&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;dependencies&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;commons-io&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.3.2&lt;/version&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;&lt;/project&gt;Repositório central do Maven O gerenciamento de dependências funciona com base em um repositório central– Os artefatos ficam todos disponibilizados neste repositório– Cada artefato no repositório é identificado pelo group ID, artifact ID e versão" }, { "title": "Expressões regulares em Java", "url": "/posts/expressoes-regulares-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-11-20 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueIntrodução Expressões regulares também são chamadas de regex Utilizadas para encontrar padrões dentro de um conjunto de informações Regras gerais – A busca por padrões é feita da esquerda para direita– Caracteres não são consumidos mais de uma vezMetacaracteres Permitem que a busca seja feita de forma mais dinâmica, ao invés de buscar um caractere específico Metacaracter ** Descrição** \\d Dígito (0 a 9) \\s Espaço em branco \\w Caracteres alfanuméricos (dígitos, letras e “_”) . Qualquer caractere Consulte o Javadoc da classe Pattern para conhecer outros metacaracteresExemplo de uso: O uso dos colchetes (“[“ e “]”) define um grupo “ou” de caracteres[abc] -&gt; Caractere a ou b ou c[?1%] -&gt; Caractere ? ou 1 ou % Combinado com o hífen (“-”), indica uma faixa (range)[a-f] -&gt; Caracteres de a a f[a-f0-9] -&gt; Caracteres de a a f ou 0 a 9Metacaracteres e Strings Muitas vezes os padrões de procura (que podem usar metacaracteres) são definidos em objetos String O problema é que “\\” é utilizado como caractere de escape em strings – \\n = quebra de linha– \\t = tabulação Para que um caractere “\" possa ser adicionado numa string, ele precisa ser precedido por outro caractere “\"String p = \"\\d\"; //Não compilaString p = \"\\\\d\"; //OKString p = \"\\w\\d\"; //Não compilaString p = \"\\\\w\\\\d\"; //OKQuantificadores Os quantificadores permitem especificar padrões baseados em sequência– Ex: zero ou mais dígitos, uma ou mais letras, um ou nenhum espaço em branco, etc. Quantificador Significado * Zero ou mais ocorrências + Uma ou mais ocorrências ? Nenhuma ou uma ocorrência Exemplo de uso: Expressão regular para representar um CEP nos seguintes formatos: – 34509-390, 34509 390, 34509390Os parênteses indicam os dados associados ao quantificador Expressão regular para representar uma string composta por uma ou mais letras (maiúsculas ou minúsculas), um hífen e um ou mais números([A-Za-z])+-([0-9])+As Classes Pattern e Matcher A classe Pattern representa uma expressão regular, que será utilizada na identificação de algum texto A classe Matcher é quem executa o processo de busca pelo padrão nos dados fornecidos Pattern p = Pattern.compile(\"ab+\"); //Pattern utilizadoMatcher m = p.matcher(\"aabbccab\"); //Texto para a buscawhile (m.find()) { //Encontra o padrão\tint start = m.start(); //Posição inicial\tString group = m.group(); //String encontrada\tSystem.out.println(start + \" =&gt; \" + group);}Resultado1 =&gt; abb6 =&gt; abSubstituição de Padrões A classe Matcher, além de encontrar padrões, é capaz de realizar substituições no textoPattern p = Pattern.compile(\"bc\");Matcher m = p.matcher(\"abcabcabcab\");StringBuffer sb = new StringBuffer();while (m.find()) {\tm.appendReplacement(sb, \"XX\"); //Vai escrevendo o texto substituído em sb}m.appendTail(sb); //Adiciona à sb o restante do textoResultado: aXXaXXaXXab Os métodos replaceFirst() e replaceAll() da classe String também são bastante utilizados para substituição com base em padrõesString s = \"abc0def1ghi2\";s.replaceFirst(\"\\\\d\", \"-\"); //abc-def1ghi2s.replaceAll(\"\\\\d\", \"-\"); //abc-def-ghi-Tokenização É o processo de dividir uma grande quantidade de dados em pedaços menores, chamados tokens Um delimitador é utilizado para indicar como os tokens serão divididos – Expressões regulares podem ser utilizadas como delimitadoresgraph LR A(a,b,c,d,e) --&gt;|\",\"| B[a b c d e] --- C(Um caractere é usado como delimitador) D(a0b00c000d0000e) --&gt;|\"0+\"| E[a b c d e] --- F(Um ou mais zeros são usados como delimitador) G(a.b.c.d.e) --&gt;|\"\\.\"| H[a b c d e] --- I(\"O caractere . é usado como delimitador\")O Método split() A classe String possui o método split(), utilizado para dividir um texto em tokens O método split() retorna um String[] String texto = \"a&lt;&gt;b&lt;&gt;c&lt;&gt;d\";String[] tokens = texto.split(\"&lt;&gt;\");A Classe Scanner A classe Scanner é excelente para trabalhar com tokenização Vantagens – Os dados de entrada podem estar em arquivos, streams ou strings– Controle no processo de tokenização, que é feito em loop– Conversão automática para tipos primitivosString registro = \"1; Produto 1; 3; 29,90\";Scanner scanner = new Scanner(registro);scanner.useDelimiter(\"; \");scanner.useLocale(new Locale(\"pt\", \"BR\"));long id = scanner.nextLong();String nome = scanner.next();int qtde = scanner.nextInt();double valor = scanner.nextDouble(); //Extrai os tokens já convertidosList&lt;Integer&gt; numeros = new ArrayList&lt;Integer&gt;();String texto = \"1,2,3,4,5\";Scanner scanner = new Scanner(texto);scanner.useDelimiter(\",\");while (scanner.hasNext()) {\tnumeros.add(scanner.nextInt()); //Fica em loop enquanto houver tokens}" }, { "title": "Programação Multithread e Sincronismo em Java", "url": "/posts/programacao-multithread-sincronismo-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-11-13 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueProcessos e ThreadsThreads Threads são consideradas processos leves Um processo pode ter uma ou mais threads em execução “simultânea” As threads de um processo compartilham o heap do processo – Área de memória onde ficam armazenados os objetos Muitas aplicações são multithread– Ex: editor de textoEscalonamento de Threads Um núcleo (core) de um processador só pode executar uma tarefa por vez O escalonador divide o tempo do processador entre as threads (time slice) Isto dá a falsa impressão de que as tarefas são executadas simultaneamente Na presença de múltiplos processadores ou processadores multi-core, é possível a execução verdadeiramente simultânea Estados de Uma Threadgraph TD A(Criada) --&gt;|thread iniciada| B(Aguardando) B --&gt;|escalonador| C(Executando) C --&gt;|escalonador| B C --&gt;|operação de I/O, bloqueio via código| D(Bloqueada) D --&gt;|fim da operação de I/O, fim do bloqueio| B C --&gt;|fim do código da thread| E(Finalizada)Criando Threads Uma thread pode ser criada através da extensão da classe Threadpublic class MinhaThread extends Thread {\tpublic void run () {\t\t//código da thread\t}}MinhaThread t = new MinhaThread();t.start(); Outra alternativa é através da implementação da interface Runnablepublic class MinhaThread implements Runnable {\tpublic void run () {\t\t//código da thread\t}}Thread t = new Thread(new MinhaThread());t.start();Executando Threads Independente da forma como é criada, o código que será executado pela thread deve ser implementado dentro do método run() Quando o método run() termina, a thread também termina Prioridades em Threads Threads podem ter prioridades– Não existe garantia de que as prioridades serão seguidas Constantes– MIN_PRIORITY (1)– NORM_PRIORITY (5)– MAX_PRIORITY (10) O método yield() pode ajudar outras threads de mesma prioridade a executarCompartilhamento de Dados Threads compartilham o heap do processo Sincronização de Threads Muitas vezes é necessário que várias threads acessem o mesmo objeto– Race Conditions Sincronizar as threads é necessário para evitar acesso simultâneo às regiões críticas (critical sections) A sincronização de threads em Java é feita através do uso de monitores Monitor é um objeto Java qualquer que cuida de uma região crítica Só é permitida a execução de uma thread por vez As outras threads ficam aguardando É possível sincronizar o método todo (método synchronized) public synchronized void metodo() {\t//código sincronizado} É possível sincronizar apenas um bloco (bloco synchronized)synchronized(monitor) {\t//código sincronizado}Thread-Safe Um recurso é thread-safe quando existe a garantia de que ele funcionará adequadamente na presença de várias threads– Algumas coleções antigas do Java eram thread-safe– Variáveis locais são sempre thread-safeComunicação Entre Threads Às vezes a atividade de uma thread depende da atividade de outra– Comunicação é necessária Métodos Método Descrição wait() Faz a thread esperar até que outra thread a notifique ou que determinado tempo tenha passado notify() Notifica uma thread que está aguardando notifyAll() Notifica todas as threads que estão aguardando (uma delas acessa a região crítica e as outras voltam a esperar) Problemas de Sincronização Starvation– Uma thread nunca consegue executar Deadlock– Duas ou mais threads estão paradas aguardando por algo que nunca vai acontecer– Travamento do sistema Problemas Clássicos “Produtor e Consumidor” “Leitor e Escritor” “Jantar dos Filósofos” “Barbeiro Adormecido” Considerações Finais Quando o assunto é thread, muito pouco é garantido Cuidado com o sincronismo dos dados Encontrar problemas de sincronismo é bastante difícil Quando for programar multithread, tome bastante cuidado e saiba o que você está fazendo " }, { "title": "Fundamentos de IO em Java", "url": "/posts/fundamentos-io-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-11-06 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueAPI de I/O do Java Está localizada no pacote java.io A API de I/O gerencia a entrada e saída de dados – Console, arquivos, sockets, etc. Todas as operações de I/O são baseadas em fluxo de dados (streams)– InputStream: fluxo de entrada– OutputStream: fluxo de saída A API usa polimorfismo para esconder detalhes de onde a informação vem e para onde ela vai Pelas streams, trafegam bytes – InputStream: é capaz de ler bytes de algum lugarInputStream is = new FileInputStream(\"entrada.txt\");int b = is.read();InputStream is = System.in;int b = is.read();– OutputStream: é capaz de escrever bytes em algum lugarOutputStream os = new FileOutputStream(\"saida.txt\");os.write(65);OutputStream os = System.out;os.write(65);Lendo caracteres Para lermos caracteres, devemos usar uma “ponte”, que converte bytes em caracteresInputStream lê bytes - InputStreamReader lê caracteresInputStream is = new FileInputStream(\"entrada.txt\");InputStreamReader isr = new InputStreamReader(is);char c = (char) isr.read();Lendo Strings Para lermos strings, devemos usar um objeto que consegue juntar os caracteresInputStreamReader lê caracteres - BufferedReader lê stringsInputStreamReader isr = new InputStreamReader(is);BufferedReader br = new BufferedReader(isr);String s = br.readLine();Escrevendo caracteres e stringsOutputStream - OutputStreamWriter - BufferedWriterOutputStream os = new FileOutputStream(\"saida.txt\");OutputStreamWriter osw = new OutputStreamWriter(os);BufferedWriter bw = new BufferedWriter(osw);bw.write(\"texto\");Streams em Arquivos É possível usar também as classes FileReader e FileWriter para lermos e escrevermos arquivos textoReader r = new FileReader(\"entrada.txt\");//CaracteresWriter w = new FileWriter(\"saida.txt\");BufferedReader br = new BufferedReader(r);//StringsBufferedWriter bw = new BufferedWriter(w);Scanner e PrintStream Servem para facilitar o trabalho de ler e escrever dados em streams– Scanner: lê dados de uma stream de entradaScanner s = new Scanner(new FileInputStream(\"entrada.txt\"));//Pode ser utilizado qualquer InputStream ou Readerwhile(s.hasNextLine()) {\tString token = s.nextLine();//Possibilidade de trabalhar com tokens O Scanner possui facilidades para quebrar strings com base em delimitadores– PrintStream: escreve dados em uma stream de saídaPrintStream ps = new PrintStream(new FileOutputStream(\"saida.txt\"));//Pode ser utilizada qualquer OutputStreamps.println(\"texto\");//Os métodos print() e println() facilitam a escrita de dados System.out é uma PrintStreamA classe java.io.File Permite acesso às informações sobre um arquivo ou diretório no sistema de arquivos– nome, diretório, tamanho em bytes, permissões de escrita e leitura, etc. Não representa obrigatoriamente um arquivo existente no sistema de arquivosFile f = new File(\"C:/Arquivos/arquivo.txt\"); Alguns métodos importantes: Método Descrição isDirectory() Informa se é um arquivo ou um diretório exists() Informa se o arquivo (ou diretório) existe getName() Obtém o nome do arquivo ou diretório getPath() Obtém o caminho completo do arquivo ou diretório listFiles() Lista os arquivos de um diretório Try-with-resources Permite o fechamento automático de recursos (chamada ao método close())InputStream is = null;try {\tis = new FileInputStream(\"entrada.txt\");\t...} finally {\tif (is != null) {\t\tis.close();\t}}try (InputStream is = new FileInputStream(\"entada.txt\")) { //Closeable ou AutoCloseable\t...}" }, { "title": "Coleções de dados em Java", "url": "/posts/colecoes-dados-java/", "categories": "Estudos-faculdade", "tags": "dados, java", "date": "2020-10-30 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftblueArrays Arrays são utilizados para agrupar dados de um mesmo tipoEm Java, array é um objetoint[] distancias;distancias = new int[8]; //Array de int com 8 posiçõesdouble[] notas = new double[5]; //Array de double com 5 posiçõesO array é alocado no heap, inicializado e indexado de 0 ao seu (tamanho-1). Acessos fora deste intervalo resultam em erro. Não é possível declarar arrays com tamanho negativo Arrays podem ter tamanho 0 Formas de inicializar os arrays:int[] array = new int[5];int array[] = new int[5];int[] array = { 1, 2 };int[] array = new int[]{ 1, 2 };Arrays de referências Além de tipos primitivos, arrays também podem guardar referências a objetosCadeira[] cadeiras = new Cadeira[5]; Neste caso, cada posição do array referencia um objeto armazenado no heapPercorrendo arrays Utilizando o foraint[] array = new int[10];for(int i = 0; i &lt; array.length; i++) {\tSystem.out.println(array[i]);} Utilizando o enhanced-foraint[] array = new int[10];for(int i : array) {\tSystem.out.println(i);}Desvantagens dos Arrays Depois de criado, não é possível modificar o tamanho de um array Dificuldade em encontrar elementos dentro do array quando o índice não é conhecido Ao remover elementos, sobram “buracos” no array Varargs O uso de varargs permite que métodos possam receber um número variável de parâmetrospublic int somar(int... valores) {\t...} Os parâmetros passados via varargs são lidos como como arrayspublic int somar(int... valores) {\tint soma = 0;\tfor (int valor : valores) {\t\tsoma += valor;\t}\treturn soma;} É possível passar o parâmetro diretamente como um arrayint[] array = { 10, 20, 30 };somar(array); Parâmetros do tipo varargs podem ser misturados com parâmetros “normais” Parâmetros varargs devem ser sempre os últimos definidos no método public void metodo(int x, boolean y, String... params) {\t...}A Collections API Possui um conjunto de classes e interfaces para facilitar o trabalho com coleções de dados– Listas– Conjuntos– MapasListas Permitem elementos duplicados Mantêm ordenação específica entre os elementos Representadas pela interface java.util.List ArrayList É a implementação de listas mais utilizada Trabalha internamente com um array List l = new ArrayList(); Usando o método add(), podemos adicionar elementos no fim da lista ou em uma posição qualquerList lista = new ArrayList();lista.add(\"José\");lista.add(\"João\");lista.add(1, \"Maria\");A lista cresce conforme o necessário O método size() retorna o tamanho da lista O método get() retorna o elemento da posição especificada Todas as coleções são genéricas Trabalham apenas com tipos Object É preciso fazer casting da referência ao obter um elemento String nome = (String) lista.get(1);Percorrendo Listas Usando o iterator:Iterator iter = lista.iterator();while(iter.hasNext()) {\tString nome = (String) iter.next();\t...} Usando o enhanced-for?for(Object obj : lista) {\tString nome = (String) obj;\t...}Usando Generics com Listas Permite restringir os tipos de dados em coleções Vantagens – Evita casting, que pode ser feito de forma errada– Faz a verificação do tipo de dado em tempo de compilaçãoList&lt;String&gt; lista = new ArrayList&lt;String&gt;(); //Determina o tipo de dado dos elementos da coleçãoList&lt;String&gt; lista = new ArrayList&lt;&gt;(); //Usando diamondlista.add(\"texto\"); //OKlista.add(1); //Erro de compilaçãoString s = lista.get(1); //O casting não é necessário Iterar sobre listas que usam generics é mais simplesIterator&lt;String&gt; iter = lista.iterator();while(iter.hasNext()) {\tString nome = iter.next();\t...}for(String nome : lista) {\t...}Ordenação de Listas A ordenação possibilita que os elementos fiquem posicionados de acordo com algum critério A classe Collections traz um método estático sort() para fazer ordenação de listas A ordenação só funciona em um dos seguintes casos: – Se os elementos da coleção implementarem a interface java.lang.Comparable– Se um java.util.Comparator for utilizado A utilização de uma dessas interfaces obriga o programador a implementar a regra de como os elementos serão ordenadosListas Imutáveis Lista que não pode sofrer alteração de elementos A partir do Java 9 existe uma forma simples de criar essas listas List&lt;Integer&gt; l = List.of(1, 2, 3, 4); // Qualquer quantidade de elementosConjuntos Representam conjuntos como na matemática Não permitem elementos duplicados A ordem dos elementos no conjunto pode não ser a mesma da ordem de inserção Representados pela interface java.util.Set HashSet Implementação de conjunto que não possui nenhuma garantia com relação à ordem dos elementosSet conjunto = new HashSet();conjunto.add(\"A\");conjunto.add(\"G\");conjunto.add(\"C\");conjunto.add(\"F\");conjunto.add(\"F\");// Os elementos duplicadossão ignoradosLinkedHashSet Garante que, ao iterar sobre os elementos, a ordem de iteração será a mesma da inserçãoSet conjunto = new LinkedHashSet();conjunto.add(\"A\");conjunto.add(\"G\");conjunto.add(\"C\");conjunto.add(\"F\");TreeSet Os elementos são ordenados por algum critério no momento em que são inseridos no conjunto O critério é definido como nas listas – Implementação da interface java.lang.Comparable– Uso de um java.util.ComparatorSet conjunto = new TreeSet();conjunto.add(\"A\");conjunto.add(\"G\");conjunto.add(\"C\");conjunto.add(\"F\");//Os elementos são ordenados em ordem alfabética//A classe String implementa a interface Comparable e define este comportamentoDistinção de elementos Conjuntos não armazenam objetos iguais– Mas como especificar quais objetos são iguais? Dois métodos devem ser implementados por classes cujos objetos são usados em conjuntos– equals()public class Linguagem {\tprivate String nome;\tprivate String descricao;\t\t@Override\tpublic boolean equals(Object obj) {\t\tif (this == obj)\t\t\treturn true;\t\tif (obj == null)\t\t\treturn false;\t\tif (getClass() != obj.getClass())\t\t\treturn false;\t\tLinguagem other = (Linguagem) obj;\t\tif (nome == null) {\t\t\tif (other.nome != null)\t\t\t\treturn false;\t\t} else if (!nome.equals(other.nome))\t\t\treturn false;\t\treturn true;\t}}– hashCode()public class Linguagem {\tprivate String nome;\tprivate String descricao;\t@Override\tpublic int hashCode() {\t\tfinal int prime = 31;\t\tint result = 1;\t\tresult = prime * result + ((nome == null) ? 0 : nome.hashCode());\t\treturn result;\t}} Métodos pertencem à classe Object A implementação da classe Object compara referências de memória Regras teóricas – Se dois objetos são iguais, devem ter o mesmo hash code– Se dois objetos são diferentes, podem ou não ter o mesmo hash code Regras práticas– Ambos os métodos funcionam juntos Sobrescreva ambos ou nenhum– Use o mesmo critério de igualdade na implementação de ambos os métodosPercorrendo Conjuntos Conjuntos não são indexados Podem ser utilizados o iterator ou o enhanced-for Iterator&lt;String&gt; iter = conjunto.iterator();while(iter.hasNext()) {\tString nome = iter.next();\t...}for(String nome : conjunto) {\t...}Usando Generics com Conjuntos O generics também pode ser utilizado com conjuntos do mesmo modo como é feito com as listasSet&lt;String&gt; conjunto = new HashSet&lt;String&gt;();Conjuntos Imutáveis Conjunto que não pode sofrer alteração de elementos A partir do Java 9 existe uma forma simples de criar esses conjuntos Set&lt;String&gt; s = Set.of(\"A\", \"B\", \"C\"); //Qualquer quantidade de elementosMapas Utilizados quando é necessário mapear uma chave a um valor Chaves e valores podem ser qualquer tipo de objeto Representados pela interface java.util.Map HashMap Implementação de mapa que não possui nenhuma garantia com relação à ordem das chaves Os métodos put() e get() podem ser usados para adicionar e obter elementos do mapa, respectivamente ContaCorrente c1 = new ContaCorrente(123);ContaCorrente c2 = new ContaCorrente(321);Map contasMap = new HashMap(); //associação entre clientes e contascontasMap.put(\"cliente1\", c1);contasMap.put(\"cliente2\", c2);ContaCorrente c = (ContaCorrente) contasMap.get(\"cliente1\"); // O get() obtém o valor associado à determinada chave O generics também pode ser usado em mapasMap&lt;String, ContaCorrente&gt; contasMap = new HashMap&lt;String, ContaCorrente&gt;();TreeMap As chaves dos elementos são ordenadas por algum critério no momento em que estes são inseridos no mapa O critério é definido como nas listas – Implementação da interface java.lang.Comparable– Uso de um java.util.ComparatorMapas: retornando Coleções A interface java.util.Map possui métodos para retornar sua lista de chaves e de valores, e até cada entrada chave/valor do mapaletrasMap.keySet(); //Retorna um Set com as chaves do mapaletrasMap.values(); //Retorna uma Collection com os valores do mapaletrasMap.entrySet(); //Retorna um Set de objetos Map.EntryMapas Imutáveis Mapa que não pode sofrer alteração de elementos A partir do Java 9 existe uma forma simples de criar esses mapas: Map&lt;Integer, String&gt; m = Map.of(1, \"A\", 2, \"B\", 3, \"C\");Map&lt;Integer, String&gt; m = Map.ofEntries(\tMap.entry(1, \"A\"), \tMap.entry(2, \"B\"), \tMap.entry(3, \"C\")); " }, { "title": "Organização do código Java", "url": "/posts/organizacao-codigo-java/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-10-23 09:00:00 -0300", "snippet": " Baseado nos cursos da SoftbluePacotes As classes podem ser organizadas em pacotes Objetivos – Organização– Possibilitar que classes possam ter o mesmo nome O nome do pacote é mapeado para um diretório no sistema de arquivoscom.treinamento.java.Exemplo -&gt; com/treinamento/java/Exemplo.javaClasses dentro de um pacote Devem estar na estrutura correta no sistema de arquivos O seu pacote deve ser declarado usando o package – Esta declaração deve ser feita na primeira linhapackage com.treinamento.java;public class Exemplo {...}Convenção de Nome dos Pacotes Contém apenas letras minúsculas Normalmente é definido um nome que não terá conflito com pacotes criados por terceiros Como encontrar as Classes Usar o fully qualified namecom.java.Exemplo e = new com.java.Exemplo(); Usar o importimport com.java.Exemplo;...Exemplo e = new Exemplo();O uso do import Os imports devem ser usados logo após o uso do package (caso exista) É possível importar todas as classes de um pacote import com.java.*; Importar classe por classe é preferível por questões de organização de códigoVisibilidades package e protectedVisibilidade package Quando não definimos modificadores para classes, atributos, métodos ou construtores, eles assumem a visibilidade package por padrão Package significa que todas as classes do mesmo pacote possuem o acesso Visibilidade protected Quando um método, atributo ou construtor possui o modificador protected– As subclasses têm acesso ao atributo– Outras classes do mesmo pacote também têm acessoJavadoc O Javadoc é a documentação do seu projeto– Classes, construtores, métodos, pacotes, etc. Gerado a partir de comentários no código O Java possui uma ferramenta para exportar o Javadoc A própria API do Java é gerada a partir da ferramenta Javadoc Criação de arquivos JAR Java ARchive Conjunto de classes compactadas no padrão ZIP, mas com extensão JAR O JAR é um componente de software – Agrupa código comum– Possui relativa independência O JDK possui um utilitário para gerar arquivos JARConvenções do código Java Códigos escritos em Java devem seguir algumas convenções– Esta padronização ajuda na manutenção do código– Facilita a leitura do código por outros desenvolvedores Classe e interface– Deve ser um substantivo– Começa com letra maiúscula e segue a notação camel caseclass Estadointerface DVDPlayerclass CasaDeMadeira Método– Deve ser um verbo– Começa com letra minúscula e segue a notação camel casevoid comer()int getIdade()void processarPagamento() Variável– Deve ter um nome que descreva seu propósito de forma clara– Começa com letra minúscula e segue a notação camel casedouble notaint qtdeItensCasa casaDaPraia Constante– Todas as letras são maiúsculas e o caractere “_” é usado para separar as palavras– A regra se aplica a elementos de enums e atributos com os modificadores static finalint VALORString ARQUIVO_CONFIGenum Prioridade {\tALTA,\tMEDIA,\tBAIXA} Blocos de código Convenção para estruturas que usam “{“ e “}” para delimitar um bloco de código if (valor &gt; 10) {\t...}public class Caneta {\t...}" }, { "title": "Anotações sobre primeiros estudos em Java", "url": "/posts/java-primeiros/", "categories": "Estudos-faculdade", "tags": "java", "date": "2020-10-16 09:00:00 -0300", "snippet": " Baseadas na documentação e nos cursos da SoftblueIntroduçãoJVM - Java Virtual Machine - Isolamento total da aplicação - é possível obter métricas e trabalhar com otimização - Garbage collectionA JVM é uma especificação - outras empresas podem fazer suas implementações - é possível trocar a JVM sem recompilar os códigosPrincípio WORA “Write Once, Run Anywhere”Código-fonte (arquivo.java) –javac-&gt; bytecode (arquivo.class) -&gt; JVMPerformance: HotSpot (JVM identifica código bastante executado) e JIT (Just In Time Compiler dos HotSpots)JRE - Java Runtime Environment - JVM + bibliotecasNomes de projeto em letra minúscula - nomes de classe com letra maiúscula - convenção do javaNew Gradle ProjectTodos os códigos precisam estar dentro de classesTodo código começa a executar pelo método mainPara rodar o modo debug no eclipse é preciso marcar um break point, na lateral da linha de códigofunções -&gt; em Orientação a Objetos é métodos. Nomes de método em camelCaseComando Source no Eclipse corrige a identação.JDK + ItelliJ/Eclipse + Maven + Gradle + WrappersWrappersPara evitar incompatibilidade de versão entre as ferramentas de build de diferentes desenvolvedores.É uma forma de estabelecer controle de versões das ferramentas entre todos os membros da equipe.Spring initializerhttps://start.spring.ioComentários//uma linha/* em bloco*/ Bibliotecas Checkstyle e PMD verificam boas práticas de código.Conceitos IniciaisVariáveis fortemente tipadas e operadores (no java todas as variáveis devem possuir um tipo e um nome)Nomes de variáveis devem começar com letra minúsculaO Java não inicializa as variáveis automaticamente, então você sempre deve atribuir um valor antes de usar a variável.int idade; (4bytes)byte // short // float // longdouble nota; (casas decimais com ponto)boolean ligado;char (apenas valores positivos, indica um caractere, representado entre aspas simples ‘a’)String nome; (não é um tipo primitivo. colocar valor entre aspas duplas)var x; (tipo de variável genérica, ela vai assumir o primeiro tipo baseado no valor que receber, e não pode mudar depois)Array: double[] notas = new double [número de posições];double[] notas2 = {8.5, 9.0, 7.5}Escopo de variáveis: uma variável criada dentro de um bloco (como repetição, por exemplo, só existe dentro desse bloco).&amp;&amp; E   OU Operadores de incremento e decremento ++ –Int x = 10; —&gt; x=11 pré-fixadoInt y = ++x; y=11Int x = 10; —&gt; x=11 pós-fixadoInt y = x++; y=10CastingAtribuir uma variável/valor de um tipo a uma variável de outro tipoImplícito: o java faz a conversão do tipo de dado automaticamente (no limite do tamanho do tipo: byte-short-int-long-float-double) double x = 10 (int)Explicito: a conversão deve ser feita pelo programador double d = 100.0; int i = (int) d;Cuidado, o casting explicito pode gerar inconsistência entre os valores.Comandos de decisãoif(condição) {}else if(condição) {}else{}switch(valor int ou convertido para int, enum ou String){case 0: …break; default:}case 0 -&gt; {} //a seta dispensa break e permite atribuir o resultado de switch a uma variávelOperador ternário substitui if elsetest ? doThisIfTrue : elseDoThisComandos de repetiçãofor(inicialização; condição; incremento) {}for(elemento in array) {}while(condição) {}do {} while(condição)Comandos de controlebreak interrompe repetiçãocontinue interrompe a execução atual da repetição mas permite a continuação do laço desde o inícioPrioridades em operadoresAritmético &gt; raiz e potenciação - multiplicação e divisão - soma e subtraçãoRelacional &gt; Lógico - não - e - ouCriar métodosNo Java os parâmetros são sempre copiados, nunca passados por referência.Um parâmetro é usado ao declarar a função. Um argumento é usado ao chamar uma função.static void nomeDoMetodo(parâmetros separados por vírgula) { }static int[] nomeDoMetodo( ) { }É possível criar métodos com o mesmo nome, mas eles precisam se diferenciar em parâmetros (tipo, quantidade ou ambos).Método main: public static void main(String[] args){}Classes/Métodos do sistemaSystem.out.println(nota); //println pula uma linhaSystem.out.print();Math.sqrt()Math.pow(,)JshellIncluso no jdk (pasta bin, executar com parâmetro -v), permite criar e testar códigos simples.Classes e ObjetosUma classe representa um tipo de dados, é uma estrutura. Um modelo para construir/instanciar objetos.public class Livro { //Um arquivo .java pode ter apenas uma classe declarada como pública dentro dele.String isbn; //O java inicializa os atributos automaticamente.int numPaginas;void emprestar () {} //método}Assinatura de um método: tipoDeRetorno[double, void etc] nome (parâmetros, zero ou mais, e todo o parâmetro deve ter um tipo definido)Sobrecarga de métodos: criar métodos com mesmo nome mas com assinatura diferente. Apesar do nome, são métodos completamente diferentes.Criar objeto: NomeDaClasse variável = new NomeDaClasse() //acesso dos atributos/métodos com objeto.atributoCada objeto criado com o new é único.Uma variável cujo tipo é uma classe não guarda o objeto diretamente, mas uma referência a memória (ponteiro ao heap) onde o objeto foi criado.As variáveis declaradas em métodos (locais) são criadas na memória stack (tipo pilha). Toda vez que um método termina, tudo é removido da stack.Os objetos são criados numa área de memória heap. String é objeto também, não tipo primitivo.Duas variáveis que apontam para o mesmo objeto no heap não geram duplicatas, ambas trabalham no mesmo objeto.No java não há passagem de parâmetros por referência, apenas por cópia. Quanto se trata de ponteiro/referencia a um objeto, a referência é copiada. Como as variáveis na stack são apagadas após o fim do método, para que o conteúdo não seja perdido (se é o que você deseja) ou você instrui o método a retornar o valor (return) ou utiliza como parâmetro uma variável que armazena um ponteiro (referencia) a um objeto do heap, e não uma variável com tipo primitivo.Garbage Collector: serviço da JVM que remove objetos do heap que não são mais utilizados pela aplicação (variavel=null remove a referência ao heap, mas não destrói o objeto, por isso o garbage collector existe, e é independente e incontrolável, rodando em segundo plano).Operador this: não é obrigatório, é utilizado para diferenciar um atributo do objeto de um argumento do método, ou, para fornecer a referência do próprio objeto para outro método.Modificadores de acesso, Construtores e elementos estáticosModificadores de acessoprivate: atributo ou método visível apenas para a classe que o declara. Usar para métodos auxiliares dentro da mesma classe, sem necessidade de chamada externa.public: visível para todas as classes.Se não definir um dos dois modificadores, o padrão é package, ou seja, visibilidade apenas dentro do pacote.Normalmente atributos são private e métodos public, mas não é regra. O ideal é que os objetos colaborem através da troca de mensagem (chamadas de métodos) e não acessando atributos diretamente.Classes quase sempre são declaradas como public, e no Java apenas pode haver uma classe public por arquivo. Nome do arquivo igual ao nome da classe.Classes não declaradas como public são inner classes.Princípio do encapsulamentoEncapsular é esconder detalhes de funcionamento do programa, sendo fundamental para permitir que o programa seja suscetível a mudanças.Métodos getters e settersUsados para acessar e alterar atributos marcados como private. Protegem os atributos, pois permitem a validação do acesso ou alteração. Também evitam a mudança de código em vários lugares. Não utilize getter e setters quando não for necessário.Getters: métodos para expor valores dos atributos.Setters: métodos para alterar valores dos atributos.atributo: nome // método getter: getNome() // método setter: setNome()Para atributos booleanos o nome do método getter pode ser isNome()ConstrutoresO construtor de uma classe é chamado toda a vez que um objeto da classe é instanciado. O construtor possui o mesmo nome da classe. Não possui tipo de retorno, o que diferencia dos métodos:public class SalaDeAula { //classepublic SalaDeAula () {} //construtor}Invocar o construtor: SalaDeAula s = new SalaDeAula();Quando o construtor não é fornecido, o Java fornece um construtor padrão (sem parâmetros). Toda classe deve possuir um.Um construtor com parâmetros podem ser utilizados para setar valores inicias para o objeto.Os construtores também podem ser sobrecarregados. this() dentro de um construtor pode ser utilizado para invocar outro construtor da mesma classe (neste caso o this() deve obrigatoriamente ser a primeira instrução do bloco.Atributos e métodos estáticosAlgumas vezes, atributos e métodos podem não estar atrelados a um objeto específico, mas sim à classe. Atributos ou métodos da classe são assim definidos através do modificador static. Os valores dos atributos estáticos são compartilhados entre todas as instâncias da classe.Métodos estáticos só podem acessar atributos ou outros métodos que também sejam estáticos. O acesso é feito utilizando diretamente a classe, não é necessário criar um objeto. Os atributos estáticos são uma forma bastante usada para criar constantes no Java. O modificador final pode ser usado para marcar o valor da constante como fixo. Por convenção, nomes de constantes são escritos em maiúsculas, com espaços usando _.O bloco staticUma classe pode ter um, apenas um, bloco static. static {}Esse bloco é executado quando a classe é referenciada pela primeira vez, iniciando atributos estáticos e executando código antes que a classe seja utilizada. É executado apenas uma vez.O tipo de dado recordAlgumas vezes criar classes gera muito código desnecessário. O record armazena e transporta atributos, dispensando a criação de classe tradicional.Os atributos definidos no record não podem ser alterados. O record também disponibiliza automaticamente o construtor e os métodos getter para os atributos.public record Quadrado (atributos) {\tpublic double calcularArea() {\t\treturn lado * lado;\t}}A classe SystemMétodos estáticos úteis:System.in //entrada padrãoSystem.out // saída padrãoSystem.exit(int) // termina a JVMSystem.currentTimeMillis() // retorna o tempo atual em msMétodo mainpublic static void main (String[] args) {}Herança e PolimorfismoHerança• A herança é um mecanismo que permite que uma classe possa herdar o comportamento de outra classe, ao mesmo tempo em que novos comportamentos podem ser estabelecidos• A vantagem da herança é agrupar coisas comuns para poder reaproveitar códigograph BT subgraph Subclasses A[Fixo] C[Celular] end subgraph Superclasse B[Telefone] end A --&gt;B C --&gt; B• Toda classe em Java herda de apenas uma superclasse.Se uma superclasse não for definida, o Java faz a classe herdar de Object• Atributos e métodos declarados com o modificador protected podem ser acessados pelas suas subclassesO atributo é declarado como protected na superclasseMétodos da subclasse possuem acesso ao atributo declarado na superclassepublic class Celular extends Telefone { protected String numero; ...}public class Fixo extends Telefone {\tpublic void adicionarDDD (String ddd) {\t\tString n = ddd + this.numero;\t} ...}Sobrescrita de métodos• Técnica também conhecida como overriding• Quando uma classe herda de outra, ela pode redefinir métodos da superclasse, isto é, sobrescrever métodos – Os métodos sobrescritos substituem os métodos da superclasse – A assinatura do método sobrescrito deve ser a mesma do método original.public class Celular extends Telefone { public void telefonar(){\t...\t}}public class Fixo extends Telefone { public void telefonar(){\t...\t}}O método que foi sobrescrito pode ser acessado pelo método que o sobrescreveu através da palavra-chave superpublic class Fixo extends Telefone { public void telefonar(){\t\tsuper.telefonar();\t}}Sobrescrevendo métodos de Object• Método toString()– As classes podem sobrescrever este método para mostrarem uma mensagem que as representem– O método System.out.println(), por exemplo, utiliza este método• Método equals(Object)– É a forma que o Java tem de comparar objetos pelo seu conteúdo ao invés de comparar as referências (como acontece ao usarmos “==”)Polimorfismo• É a capacidade que um método tem de agir de diferentes formas, dependendo do objeto sobre o qual está sendo chamado• Quando ocorre a chamada de um método, a JVM decide qual método invocar dependendo do objeto instanciado na memóriaclassDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal: +falar() void class Duck{ +falar() void } class Fish{ +falar() void } class Zebra{ +falar() void }Cada animal implementa o método falar() do seu modoO método invocado é determinado pelo tipo do objeto que está armazenado na memóriaA forma como objeto é referenciado não influencia na decisão sobre qual método será invocadoO tipo pelo qual o objeto é referenciado determina quais métodos e/ou atributos podem ser invocadosO operador instanceOfUtilizado para verificar se um objeto pertence à determinada classeNormalmente é utilizado antes de realizar um cast, para garantir que a operação é válidaAnimal a = new Cachorro();a instanceOf Cachorro; //truea instanceOf Animal; //trueClasses abstratas e InterfacesClasses abstratas Usadas quando não faz sentido termos instâncias de determinadas classes Manter a consistência do programa Utilizar o modificador abstract na declaração da classe public abstract class Animal{} Não é permitida a existência de objetos da classe se ela for abstrata. É permitido criar referências à classe: Animal a = new Cachorro();Métodos abstratos Utilizados quando não faz sentido termos a implementação do método em determinada classe Para declarar um método abstrato, basta utilizar o modificador abstract na declaração do método public abstract class Animal{\tpublic abstract void falar();} Todas as classes não-abstratas que herdam de uma classe abstrata são obrigadas a implementar os métodos abstratos Os métodos chamados correspondem aos métodos implementados nas subclasses Classes abstratas não precisam obrigatoriamente ter métodos abstratos Métodos abstratos só podem existir em classes abstratas Interfaces A interface define métodos, mas não os implementa – Com exceção de métodos que usam os modificadores default, static e private A implementação é de responsabilidade de quem implementa a interface O foco é no que o objeto faz, e não em como ele faz Interfaces possibilitam mudanças de implementação muito mais facilmente, pois quem chama o método não conhece a sua implementação Interfaces não possuem atributos (só constantes) public interface AreaCalculavel{\tpublic double calcularArea();}public class Quadrado implements AreaCalculavel {\tprivate double lado;\tpublic double calcularArea() {\t\treturn lado * lado;\t}} Interfaces podem estender outras interfaces Classes podem estender outra classe, mas apenas podem implementar interfaces Uma classe pode implementar uma ou mais interfaces Métodos Default Uma interface pode definir métodos com o modificador default Neste caso, o método é implementado diretamente na interface Este recurso surgiu no Java 8, a fim de permitir o suporte à expressões lambda em interfaces que já faziam parte da linguagem public interface Calculator {\tdouble calculate();\tdefault double calculatePow(double x, int y) {\t\treturn Math.pow(x, y);\t}}Métodos Estáticos Interfaces também podem implementar métodos definidos com o modificador static O método é acessível diretamente pela interface, sem precisar que ocorra a criação de objetos public interface Calculator {\tdouble calculate();\tstatic double calculatePow(double x, int y) {\t\treturn Math.pow(x, y);\t}}Métodos Privados A versão 8 do Java introduziu os métodos default e static em interfaces Isso trouxe um problema – Onde agrupar a lógica comum desses métodos? A solução foi introduzir, a partir do Java 9, métodos private em interfaces public interface Logging {\tdefault void logInfo(String msg) {\t\tlog(\"INFO: \" + msg);}default void logError(String msg) {\tlog(\"ERROR: \" + msg);}private void log(String msg) { //Implementa a lógica comum entre os métodos\t// Conecta no BD\t// Grava o log\t// Fecha a conexão\t}}Classes Abstratas ou Interfaces? A escolha entre classes abstratas ou interfaces tem dois aspectos Conceitual Classes abstratas são classes que não podem ter instâncias Interfaces determinam como um objeto será exposto Prático Uma classe pode implementar mais de uma interface Uma classe abstrata pode conter atributos Classes abstratas e interfaces têm o objetivo comum de favorecer o uso do polimorfismo Tratamento de ExceçõesAvisando Sobre Falhas em Métodos• Você precisa avisar quem chamou o método e informar que o método não executou como deveria. Como fazer?– As abordagens mais comuns são• Usar booleanos• Usar magic numbers Problema de Usar Booleanos E se o retorno não for tratado? O que falhou? Problema de Usar Magic Numbers E se o retorno não for tratado? Como entender este código sem uma tabela de códigos de erro? Exceções Exceções representam algo estranho ao sistema que normalmente não ocorre Em Java, o tratamento de exceções é feito por um código diferente do código executado quando não ocorre a exceção Classes Que Representam Exceções Exceções são representadas por classes As classes devem herdar direta ou indiretamente de Exception O Java tem classes que representam diversos tipos de exceção, mas o programador pode criar exceções específicas de acordo com a necessidade Checked Exceptions• Herdam direta ou indiretamente de Exception Só não podem herdar de RuntimeExceptionUnchecked Exceptions Também chamadas de runtime exceptions Herdam direta ou indiretamente de RuntimeException Lançando Exceções O lançamento de exceções é feito através do throwpublic void fazerAlgo() throws Exception { //O throws indica que o método pode lançar a exceção\tthrow new Exception(); //O throw é usado para lançar a exceção} É possível também lançar subclasses da exceção declarada pelo throwspublic void fazerAlgo() throws Exception { //A declaração throws Exception está de acordo com a exceção lançada pelo método\tthrow new IOException(); //IOException é uma subclasse de Exception}Tratando Exceções Exceções podem ser tratadas através do uso do bloco try/catch Determinado código tenta (try) executar um método e, caso alguma exceção aconteça, ele pega (catch) a exceção ocorrida e faz o que deseja Após uma exceção ter alcançado o bloco catch, o código volta o seu fluxo normal de execução public void m1() throws IOException, SQLException {\t...}public void m2() { //Dependendo da exceção, o bloco catch correspondente é executado\ttry {\t\tm1();\t} catch (IOException e) { //No máximo um bloco catch é executado\t\t...\t} catch (SQLException e) {\t\t...\t}\t...} É possível fazer o catch de mais de uma exceção ao mesmo tempo (Multi-catch)try {\tm();} catch (MyException1 | MyException2 | MyException3 e) {\t...}Lançando Unchecked Exceptions Estas exceções normalmente são provocadas por problemas de programação, não devendo ser tratadas Por este motivo, o Java não obriga o programador a tratar as unchecked exceptions Se uma exceção for lançada pelo método main(), a JVM termina Exceções muito genéricas dificultam no entendimento do problema Assertions Garantir qualidade do código, executando testes que permitem validar a lógica e as suposições sobre o programa São usadas em tempo de desenvolvimento e desabilitadas em produção Se a assertion falhar, a JVM lançará um AssertionError public void metodo(int arg) { \tassert arg &gt; 0;\t... }public void metodo(int arg) { \tassert arg &gt; 0 : \"arg menor que 0\"; //Funciona como o exemplo anterior, mas a string fornecida será passada no construtor do AssertionError\t... } Por padrão, as assertions ficam desabilitadas Para habilitá-las, é preciso passar o parâmetro –ea ao iniciar a JVM java -ea MinhaClasse Não use assertions para validar parâmetros de métodos públicos Métodos públicos têm um comportamento bem definido sobre o que ocorre na passagem de parâmetros Este comportamento deve ser o mesmo, havendo assertions ou não Não escreva assertions que interfiram na execução da aplicação Estando a assertion habilitada ou não, a aplicação deve funcionar da mesma forma Strings, Datas e NúmerosStrings Armazenam conjuntos de caracteres As strings são objetos, logo podem ser construídas como qualquer outro objeto Depois de criada, uma string nunca tem seu valor alterado String s = \"abc\";s.toUpperCase(); //s deixa de ser \"abc\" e referencia uma nova string, \"ABC\"String s = \"abc\";s.concat(\"def\"); //s deixa de ser \"abc\" e referencia uma nova string, \"abcdef\" O operador “+” pode ser utilizado na concatenação de strings Para comparar strings, o método equals() deve ser utilizado O equals() compara o conteúdo ao invés de comparar endereços de memória Métodos da Classe String Método Descrição charAt(int) Retorna o caractere de uma posição indexOf(String) Retorna a posição em que uma string aparece pela primeira vez na string principal length() Retorna o tamanho da string split(String) Divide a string de acordo com um critério substring(int, int) Retorna uma parte da string toLowerCase() Converte os caracteres para minúsculo toUpperCase() Converte os caracteres para maiúsculo StringBuilder Como strings são imutáveis, manipular a mesma string diversas vezes pode ocupar muita memória desnecessariamente Bastante comum em concatenação de strings dentro de um loop A classe StringBuilder resolve este problema Existe também a classe StringBuffer, que tem exatamente a mesma função mas que possui todos os seus métodos sincronizados StringBuilder sb = new StringBuilder(\"abc\");//O objeto é instanciado com o valor inicial \"abc\"sb.append(\"def\");//Outras strings vão sendo concatenadassb.append(\"ghi\");sb.append(\"jkl\");String s = sb.toString();//É gerada uma string que contém todas as modificações feitas no objeto sbMétodos da Classe StringBuilder Método Descrição append(String) Concatena uma string delete(int, int) Remove parte de uma string insert(int, String) Insere uma string em uma determinada posição reverse() Inverte os caracteres toString() Retorna o conteúdo do objeto como uma string Formatando Strings A formatação de strings pode ser feita facilmente através dos métodos format() e printf() da classe PrintStream System.out é um PrintStream, portanto é possível formatar a saída para o console A classe String também possui o método format() Formatando Números Java possui a classe NumberFormat, utilizada para formatar números Possui suporte à localização Locale l = new Locale(\"pt\", \"BR\");NumberFormat nf = NumberFormat.getInstance();String s = nf.format(1000.5);System.out.println(s); //1.000,5NumberFormat nf = NumberFormat.getCurrencyInstance(l);String s = nf.format(1000.5);System.out.println(s);//R$ 1.000,50Locale l = new Locale(\"en\", \"US\");NumberFormat nf = NumberFormat.getInstance(l);String s = nf.format(1000.5);System.out.println(s);//1,000.5Números randômicos Java é capaz de gerar números randômicos, que na verdade são pseudo-randômicos Sementes iguais geram sequências iguais A classe Random pode ser utilizada para gerar números randômicos Outra opção é utilizar o método Math.random() Gera números do tipo double Os números são distribuídos entre 0 e 0,99999… Como implementar um método que define um intervalo de geração de números? Calcula o intervalo entre os números Gera um double randômico entre 0 e 0,9999… Multiplica o valor pelo intervalo Trunca as casas decimais Soma o resultado com o início do intervalo A classe Math Possui uma série de métodos estáticos voltados para operações matemáticas comuns Método Descrição abs() Valor absoluto (sem sinal) max() Valor máximo entre dois valores min() Valor mínimo entre dois valores ceil() Arredonda um valor para cima floor() Arredonda um valor para baixo round() Arredonda um valor para cima ou para baixo sqrt() Raiz quadrada pow() Potenciação toDegrees() Ângulo de radianos para graus toRadians() Ângulo de graus para radianos Trabalhando com Datas Java possui quatro classes principais para trabalhar com datas Classe Descrição java.util.Date Representa uma data e hora. java.util.Calendar Possibilita a conversão e manipulação de datas e horas. java.text.DateFormat Formata datas e horas. java.util.Locale Representa uma localidade. É utilizada com datas para formatá-las de acordo com a localidade desejada. Uma nova API de datas e horas foi adicionada a partir do Java 8java.time Diversas classes para representar diferentes conceitos Classes imutáveis, o que as torna thread-safe Nome da Classe O que representa LocalDate Uma data (com dia, mês e ano) LocalTime Uma hora (com hora, minuto, segundo e milissegundo) LocalDateTime Uma data e hora Period Um período de tempo (em anos, meses, dias, semanas) Duration Uma duração de tempo (em dias, horas, minutos, segundos) MonthDay Um par de mês e dia (Ex: dia de aniversário) YearMonth Um par de ano e mês (Ex: data de validade do cartão de crédito) Instant Um instante no tempo, com precisão de nanossegundos Nome do Enum O que representa ChronoUnit Unidades de tempo (dias, meses, anos, horas, minutos, etc.) Integração com Código Legado As classes Date e Calendar ganharam métodos para converter a sua representação para um objeto InstantEnums, Classes Wrappers e AutoboxingEnums Os enums (enumerations) permitem restringir variáveis a apenas valores previamente determinados Ajudam a reduzir bugs no código Podem ser declarados dentro de uma classe (da mesma forma que atributos) Podem ser declarados num arquivo próprio (como se fossem uma classe) Constantes sem usar enums:public static final int VOLUME_ALTO = 0;public static final int VOLUME_MEDIO = 1;public static final int VOLUME_BAIXO = 2;Usando enums:enum Volume {\tALTO,\tMEDIO,\tBAIXO}Usando Enums no código:Volume v1 = Volume.ALTO; //OKVolume v2 = 100; //Não compilaif (v1 == Volume.BAIXO) { //OK. É possível utilizar o operador \"==\" na comparação}Volume[] v = Volume.values(); //Retorna um array com os elementos do enumOutros elementos de um Enum:public enum Prioridade {\tALTA(10), //valores do enum\tMEDIA(5),\tBAIXA(1);\t\tprivate int valor; //atributo\tPrioridade(int valor) { //construtor privado\t\tthis.valor = valor;\t}\tpublic int getValor() { //método\t\treturn valor;\t}}int v = Prioridade.ALTA.getValor();Classes wrappers São as classes que representam os tipos primitivos– Desta forma os tipos primitivos podem ser adicionados a coleções ou retornados por um método que retorna objetos Possuem diversos métodos utilitários para os tipos primitivos– Converter tipos primitivos para strings e vice-versaClasses Wrappers x Tipos Primitivos: Tipo Primitivo Classe Wrapper boolean Boolean byte Byte short Short char Character int Integer float Float long Long double Double Integer i1 = new Integer(10); //Wrappers do valor inteiro 10Integer i2 = new Integer(\"10\");Integer i1 = Integer.valueOf(\"10\");Integer i2 = Integer.valueOf(\"1010\", 2); //Wrapper do valor inteiro 10, fornecido em base bináriaDouble d1 = new Double(30.3); //Wrappers do valor decimal 30.3Double d2 = new Double(\"30.3\");Double d1 = Double.valueOf(\"30.3\");Character c1 = new Character('a'); //Wrapper do caractere 'a'Objetos wrappers são imutáveis: seu valor não pode ser alteradoUtilitários de conversão:Integer i1 = new Integer(10); //Converte um Integer para os tipos primitivos int e floatint i = i1.intValue();float f = i1.floatValue();int i2 = Integer.parseInt(\"10\"); //Converte uma String para um intdouble d1 = Double.parseDouble(\"4.5\"); // Converte uma String para um doubleint i3 = Integer.parseInt(\"abc\"); //Lança uma exceçãoAutoboxing Faz as conversões entre os tipos primitivos e seus wrappers de forma automática Os wrappers continuam sendo imutáveis O autoboxing é apenas uma facilidade para o programador – Internamente, os tipos primitivos continuam sendo “embrulhados” e “desembrulhados”i = i + 2;//para o compilador:int t = i.intValue();t = t + 2;i = new Integer(t);" }, { "title": "Anotações sobre Git - GitHub", "url": "/posts/git-github/", "categories": "Estudos-faculdade", "tags": "git", "date": "2020-10-02 09:00:00 -0300", "snippet": "Navegação via command line interface e instalação Windows Unix     cd cd change directory .. subir um nível de pasta dir ls listar o conteúdo da pasta -a exibe arquivos ocultos mkdir mkdir criar pasta   del/rmdir rm -rf del para arquivos   cls clear clear screen + L echo echo imprime texto no terminal &gt;hello.txt retorna o resultado da função para um arquivo mv   mover arquivo   Apertar tab autocompleta se houver um diretório com o nome que você está digitando.Entendendo como o Git funciona por baixo dos panosSHA1 - A sigla SHA significa Secure Hash Algorithm, é um conjunto de funções hash criptográficas projetadas pela NSA. A encriptação gera conjunto de caracteres identificador de 40 dígitos. É uma forma curta de representar um arquivo.Objetos do GIT Blobs: Os blobs armazenam os arquivos no git, contendo metadados (blob tamanho-do-arquivo \\0 conteúdo) sobre os mesmos; hash diferente de um arquivo solitário. Trees: As trees armazenam blobs, com mais metadados do git (tree tamanho \\0 blob sha arquivo) e um sha próprio. Commits: O commit armazena indicação de alterações, com metadados (commit tamanho tree sha parente sha autor mensagem timestamp) e um sha próprio.Ciclo de vida dos arquivos no Git git init inicia o git em uma pasta, criando um repositório git add arquivo adiciona arquivos modificados no stage para commit git commit -m “mensagem” cria um commit git status apresenta o status atual do repositório git add * adiciona todos os arquivos git -rm remove arquivos do stage git restore descarta alterações no repositório sequenceDiagram participant Untracked participant Unmodified participant Modified participant Staged Unmodified-&gt;Staged: Tracked Untracked-&gt;&gt;Staged: Adiciona o arquivo Unmodified-&gt;&gt;Modified: Edita o arquivo Modified-&gt;&gt;Staged: \"Stage\" o arquivo Unmodified-&gt;&gt;Untracked: Remove o arquivo Staged-&gt;&gt;Unmodified: CommitIntrodução ao GitHub git config –list acessa as configurações do git git remote add origin endereço Apontar um diretório local para um repositório remoto git push origin master Empurra as alterações para o GitHub git pull origin master Puxa alterações do GitHub para o repositório local git clone endereço Clonar repositório É recomendável configurar o git com o mesmo email e username do GitHub" }, { "title": "Anotações sobre Agile - Scrum", "url": "/posts/agile-scrum/", "categories": "Estudos-faculdade", "tags": "agile, scrum", "date": "2020-09-25 11:15:00 -0300", "snippet": "Agile - ScrumEstimativa e Planejamento com Agile Planejamento é essencial; planos são inúteis. Tempo e orçamento (pessoas) são constantes. Escopo é negociável. O plano fica mais preciso com o tempo porque ele é constantemente revisado para refletir a performance real do time. A única medida de sucesso é o valor de negócio entregue aos clientes. Escopo é flexível e mudanças de qualquer tipo são bem-vindas a qualquer momento. Não é possível controlar através de um plano; libertar o time na segurança de Agile a direcioná-lo é minha única forma de controle. O produto funcionando é a única medida de progresso e de valor entregue. Manifesto ágil:graph LR A[Indivíduos e interações] --&gt;|sobre| B[Processos e ferramentas] C[Produto funcional] --&gt;|sobre| D[Documentação compreensiva] E[Colaboração com o cliente] --&gt;|sobre| F[Negociação de contratos] G[Resposta à mudança] --&gt;|sobre| H[Seguir um plano] Princípios Ágeis: Nossa maior prioridade é satisfazer o cliente através da entrega contínua e adiantada de software com valor agregado. Mudanças nos requisitos são bem-vindas, mesmo tardiamente no desenvolvimento. Processos ágeis tiram vantagem das mudanças visando vantagem competitiva para o cliente. Entregar frequentemente software funcionando, de poucas semanas a poucos meses, com preferência à menor escala de tempo. Pessoas de negócio e desenvolvedores devem trabalhar diariamente em conjunto por todo o projeto. Construa projetos em torno de indivíduos motivados. Dê a eles o ambiente e o suporte necessário e confie neles para fazer o trabalho. O método mais eficiente e eficaz de transmitir informações para e entre uma equipe de desenvolvimento é através de conversa face a face. Software funcionando é a medida primária de progresso. Os processos ágeis promovem desenvolvimento sustentável. Os patrocinadores, desenvolvedores e usuários devem ser capazes de manter um ritmo constante indefinidamente. Contínua atenção à excelência técnica e bom design aumentam a agilidade. Simplicidade -a arte de maximizar a quantidade de trabalho não realizado- é essencial. As melhores arquiteturas, requisitos e designs emergem de equipes auto- organizáveis. Em intervalos regulares, a equipe reflete sobre como se tornar mais eficaz e então refina e ajusta seu comportamento de acordo. Pilares do Scrum: TransparênciaVisibilidade para todos envolvidos no processo produtivo Inspeção — Insight: o que está acontecendo? Adaptação — Refletir e melhorar Elementos do ScrumPlanejamento: Sprint Planning e Daily ScrumScrum FrameworkArquitetura do ScrumIron triangle: tempo, custo e escopo. Qualidade não é negociável.Release Planning: Sprint Planning: Responsabilidades: — Trazer o PBL (product backlog) priorizado — Explicar os itens de alta prioridades para o time Participantes: PO (product owner), SM (scrum master), Time de Desenvolvimento. Consiste de duas partes: — Na primeira parte é decidido o que será feito no Sprint e estabelecida uma meta. — Na segunda parte é decidido como atingir a meta. Podemos entregar essa quantidade nesse Sprint? Daily Scrum: A participação do PO é opcional. Por que você participaria? O que você diria ao time? Melhora a comunicação e promove a transparência entre os envolvidos no processo produtivo (o Time de Desenvolvimento). Promove a tomada rápida de decisão. Promove o compartilhamento do conhecimento. Histórias de usuário é metodologia Agile, não Scrum especificamente. Papeis e responsabilidades Product Owner: Representante da área de Negócios; PO não é um Comitê; Define as funcionalidades do software (Product Backlog); Prioriza as funcionalidades de acordo com o valor do negócio; Garante que o time de desenvolvimento entenda os itens do Backlog no nível necessário. SCRUM Master: Garantir o uso correto do SCRUM; Scrum Master não é Gerente de Projetos; Age como facilitador; Auxilia o Product Owner no planejamento e estimativas do backlog; Auxilia a equipe a remover impedimentos; Treina o time em autogerenciamento e interdisciplinaridade. Time de desenvolvimento: Possui habilidades suficientes para desenvolver, testar, criar e desenhar, ou seja, tudo que for necessário para entregar o software funcionando. Como estimar com a EquipeOs níveis de planejamento: Nível Frequência de realização Quem participa Foco do encontro Produto 1-2 vezes por ano Product Owner e executivos Estratégia de lançamento do produto Roadmap 3-4 vezes por ano Product Owner e executivos Evolução do produto no tempo Release 6-8 vezes por ano Product Owner e Time de Desenvolvimento Tradeoffs entre funcionalidade e datas de entrega Sprint Cada 1-4 semanas Product Owner e Time de Desenvolvimento Que funcionalidades podem ser entregues no Sprint Diário Todo dia Time de Desenvolvimento Como completar funcionalidades Estimando tamanho em cada nível: Nível Frequência de realização Unidade de medida de tamanho Produto 1-2 vezes por ano T-Shirt Sizing Roadmap 3-4 vezes por ano Story Points e/ou T-Shirt Sizing Release 6-8 vezes por ano Story Points Sprint Cada 1-4 semanas Story Points e horas Diário Todo dia Horas Comparação relativa: O tamanho de um item é dado calculando-se o esforço de se implementar o item. Fatores determinantes do esforço: complexidade, tempo, habilidade, riscos. T-Shirt Sizing: Seleciona-se uma história como referência e assinala- se um tamanho. Se a próxima história for maior, classifica-se à direita da referência. Se a próxima história for menor, classifica- se à esquerda da referência. Story Points: Adicionam uma camada de comparação relativa para facilitar o processo de estimativa. • Usados para estimar o esforço de uma história. • Estimativa relativa; 2 story points requer mais esforço que I story point e 8 sp requer muito mais esforço que I sp. • Usa-se um subconjunto da série de Fibonacci. Story Points nos falam a diferença proporcional de tamanho. T-Shirt Sizes nos falam apenas quem é maior ou menor, sem proporcionalidade. Estimando com o time; O processo de estimativa em Scrum sempre ocorre com a equipe: knowledge of crowds! Todos devem conhecer a perspectiva de cada um na equipe multifuncional Planning poker Vantagens em estimar com a equipe — O processo de estimativa em equipe promove o compartilhamento do conhecimento — Diminui os riscos do projeto — Aumenta a qualidade do produto em desenvolvimento — Promove responsabilidade e comprometimento Velocidade: quantidade de story points que uma equipe entrega por Sprint. Calculando Velocidade e Esforço Deixando a equipe encontrar sua velocidade O objetivo de um processo empírico com o Scrum; Falhar faz parte do aprendizado: punição e pressão advindas de erros de estimativas de duração, limitam a criatividade e performance; Executivos precisam entender que travando escopo, tempo e orçamento, não existe metodologia de gerenciamento de projetos que funcione; Calculando a velocidade Útil quando o time nunca trabalhou junto, ou sua composição mudou significativamente Observe a velocidade por pelo menos um Sprint• Use a tabela abaixo para antecipar a velocidade futura (Cohn, 2005)Exemplo: Sprints Completados Multiplicador inicial Multiplicador final 1 0.6 1.60 2 0.8 1.25 3 0.85 1.15 4 ou mais 0.9 1.10 Velocidade observada Sprints Completados Low End High End 29 1 17 46 29 2 23 36 29 3 24 33 » 29 4 26 31 Observações de velocidade Velocidades observadas: 20, 25, 28, 26, 16, 20, 26, 26 Descarte dados de Sprint com anomalias Crie uma lista em ordem crescente: 16, 20, 20, 25, 26, 26, 28 Use a tabela abaixo para determinar a velocidade com 90% de confiança: Número de observações Enésima velocidade Intervalo de velocidade Velocidade mediana 8 2 20 (n menor)-26(n maior) (20+26)/2 = 23 Pattern: Manter seus times estáveis aumenta a previsibilidade Colete velocidade por tantos Sprints quantos forem possíveis. Com cinco ou mais Sprints, pode-se criar uma predição de alta confiança Use a enésima observação mais baixa e a enésima observação mais alta em uma lista de velocidades para obter um intervalo com 90% de confiança Número de observações Enésima velocidade Número de observações Enésima velocidade 5 1 16 5 8 2 18 6 11 3 21 7 13 4 23 8 Métricas: Uma métrica é um padrão para medir ou avaliar alguma coisa. Medida é uma quantidade, uma proporção, ou uma comparação qualitativa. Quantidade: “Existem 25 bugs a corrigir na aplicação hoje.” Proporção: “Essa semana existem 10% menos bugs que na semana passada.” Comparação qualitativa: A nova versão do software é mais fácil de usar que a antiga.” Três tipos de métricas: Informacional - diz o que está acontecendo • Diagnóstico - identifica áreas de melhoria Motivacional - influencia o comportamento Uma métrica pode funcionar em várias categorias. Exemplo: oferecendo um alto valor para os clientes (informacional) pode aumentar o moral da equipe (motivação). Cuidado com os efeitos colaterais indesejados: efeito Hawthorne Exemplo: recompensar as pessoas por consertar erros podem resultar em aumento dos erros, pois as pessoas criam oportunidades para ganhar as recompensas. Medir resultado, não atividade. Medir tudo necessário e nada mais. Velocidade: Princípio: Nossa maior prioridade é satisfazer o cliente através da entrega antecipada e contínua de software de valor. O que é: observação empírica da capacidade da equipe para o trabalho; útil para projetar a provável data de conclusão de uma determinada quantidade de escopo; útil para estimar a quantidade de escopo que pode ser entregue em uma determinada data. Diagnóstico: Padrões em tendências na evolução da velocidade pode indicar vários problemas, fornece uma base para os esforços de melhoria contínua Motivação: Os membros da equipe tem orgulho em conseguir alta velocidade e mantê-la estável. " }, { "title": "Anotações sobre Raciocínio lógico e lógica quantitativa", "url": "/posts/raciocinio-logico/", "categories": "Estudos-faculdade", "tags": "lógica", "date": "2020-09-18 11:15:00 -0300", "snippet": "Baseado no Livro: LEITE, A. E.; CASTANHEIRA, N. P. Raciocínio lógico e lógica quantitativa. Curitiba: InterSaberes, 2017.Capítulo 1 - Lógica matemáticaLógica clássica - intuitiva e não matemática. Diferente, portanto, da Lógica matemática.Proposição: conjunto de palavras ou símbolos que exprime um pensamento de sentido completo, mas que assume um de dois valores lógicos (V ou F). Sentenças declarativas. Pode ser simples ou composta.Princípio da identidade: todas as coisas são idênticas a si próprias.Princípio da não contradição: uma proposição não pode ser verdadeira e falsa ao mesmo tempo.Princípio do terceiro excluído: toda proposição ou é verdadeira, ou é falsa, ou seja, não há um terceiro valor.Três formas de raciocínio: dedução para chegar a conclusão, indução para determinar a regra e abdução para determinar a premissa. Não E Ou ou… ou… se… então… se e somente se $\\sim$ $\\wedge$ $\\vee$ $\\veebar$ $\\to$ $\\leftrightarrow$ Conectivos das operações: negação, conjunção, disjunção, disjunção exclusiva, condicional ou implicação, bicondicional ou dupla implicação.A conjunção também é conhecida como produto lógico de preposições. A disjunção também é conhecida como soma lógica de preposições.O valor lógico de uma proposição simples é indicado por V(p) e de uma proposição composta por V(P).Capítulo 2 - Tabela VerdadeUma tabela-verdade é um dispositivo prático que mostra todos os valores lógicos de uma proposição.O número de linhas de uma tabela-verdade é dado por 2n, onde n é o número de proposições simples que compõem a proposição composta.Tabela-verdade do conectivo se… então($\\to$) p q $p\\to q$ V V V V F F F V V F F V A proposição condicional, também chamada implicação, é falsa, por definição, quando p for verdadeira e q for falsa. Nos demais casos, ela é verdadeira, como mostrado na tabela-verdade.Tabela-verdade do conectivo se e somente se ($\\leftrightarrow$) p q $p\\leftrightarrow q$ V V V V F F F V F F F V A tabela-verdade nos mostra que a proposição bicondicional, também chamada de dupla implicação, é verdadeira somente quando A e B têm o mesmo valor lógico.Duas proposições são equivalentes quando suas tabelas-verdade forem iguais. A equivalência é representada por $\\Leftrightarrow$. Não confundir com $\\leftrightarrow$ (bicondicional).Capítulo 3 - Tautologia, contradição e contingênciaQuando uma proposição composta é sempre verdadeira, temos uma tautologia. Quando é sempre falsa, trata-se de uma contradição. Caso não seja nem uma tautologia, nem uma contradição, estamos diante de uma contingência.Capítulo 4 - Teoria dos conjuntosConjunto é todo o agrupamento de elementos com características semelhantes.A notação de um conjunto é feita por uma letra maiúscula. O elementos são representados entre vírgulas (ponto e vírgula no caso de números não inteiros) dentro de chaves, ou por uma propriedade em linguagem matemática, ou por diagramas de Euler/Venn.Quando falamos em pertinência, estamos nos referindo a pertencimento; ou seja, se afirmamos que determinado elemento faz parte de um conjunto, então ele pertence ao conjunto. $\\in \\notin $Já a noção de inclusão refere-se a conjuntos diferentes que estão relacionados. Da relação de inclusão, surge a noção de subconjunto. Se um conjunto A possui n elementos, então esse conjunto tem 2n subconjuntos.Representação dos símbolos: Símbolos Significado $\\subset$ Está contido em $\\not\\subset$ Não está contido em $\\supset$ Contém $\\not\\supset$ Não contém Dois ou mais conjuntos são iguais quando têm exatamente os mesmos elementos. Um conjuntos unitário é aquele que contém um único elemento. Um conjunto vazio é aquele que não possui elementos, representado por {} ou $\\emptyset$.Consideremos um conjunto S. O conjunto formado por todos os subconjuntos dele é o conjunto das partes de S; nós o representamos por P(S). Importante lembrar que o conjunto vazio é um subconjunto de qualquer conjunto.A união ou reunião de dois ou mais conjuntos é representada pelo símbolo $\\cup$. a. $A \\cup A=A$ Idempotência b. $A \\cup B=B\\cup A$ Comutativa c. $A \\cup \\emptyset=A$ Elemento neutro para a união d. Se $A \\subset B=A$, então $A\\cup B=B$ Inclusão relacionada e. $(A \\cup B)\\cup C=A\\cup(B\\cup C)$ Associativa A interseção de dois ou mais conjuntos é o conjunto cujos elementos pertencem simultaneamente a cada um deles, representado por $\\cap$. a. $A\\cap A = A$ Idempotência b. $A\\cap B =B\\cap A$ Comutativa c. $A\\cap \\emptyset = \\emptyset$ Elemento nulo para a interseção d. Se $A \\subset B$, então $A\\cap B=A$ Inclusão relacionada e. $(A \\cap B)\\cap C=A\\cap(B\\cap C)$ Associativa Importante destacar que, quando interseção de dois conjuntos quaisquer é igual a um conjunto vazio, ou seja, não há qualquer elemento comum a eles, é dado o nome de conjuntos disjuntos.Quando temos dois conjuntos, A e B, a diferença entre eles é representada por A - B, em que os elementos pertencentes ao conjunto A não fazem parte do conjunto B. a. $A-A=\\emptyset$ Não verifica a idempotência b. $A-\\emptyset=A$   c. $\\emptyset -A=f$   d. Se $A\\subset B$, então $A-B=\\emptyset$   e. $A-B\\neq B-A$ Não é comutativa f. $(A-B)-C\\neq A-(B-C)$ Não é associativa g. Se $A\\cap B=0$, então $A-B=A$ e $B-A=B$   A diferença simétrica entre dois conjuntos A e B é o conjunto dos elementos que pertencem à união de A e B, mas não pertencem à interseção deles. É representada por $\\Delta$. a. $A=\\emptyset$ se e somente se $B=A\\Delta B$   b. $A\\Delta A=\\emptyset$ Não verifica a idempotência c. $A\\Delta B=B\\Delta A$ Comutativa d. $A\\cap (B\\Delta C)=(A\\cap B)\\Delta(A\\cap C)$ Distributiva e. $(A\\Delta B)\\Delta C=A\\Delta(B\\Delta C)$ Associativa Dados dois conjuntos A e B tais que $B\\subset A$, chamamos de complementar de B em A o conjunto $\\overline{B}$ constituído pelos elementos do conjunto A que não pertencem ao conjunto B, em outras palavras, $\\overline{B}=A-B$.É verdadeira a propriedade $\\overline{\\overline{A}}=A$ (idempotência), ou seja, o complementar do complementar de um conjunto A é o próprio conjunto A.Leis de Augustus de Morgan: O complementar da reunião de dois conjuntos A e B é a interseção dos complementares desses conjuntos $(\\overline{A\\cup B})=\\overline{A}\\cap\\overline{B}$.2. O complementar da reunião de uma coleção finita de conjuntos é a interseção dos complementares desses conjuntos. O complementar da interseção de dois conjuntos A e B é a reunião dos complementares desses conjuntos $(\\overline{A\\cap B})=\\overline{A}\\cup\\overline{B}$.4. O complementar da interseção de uma coleção finita de conjuntos é a reunião dos complementares desses conjuntos.Dados os conjuntos A, constituído por x elementos, e B por y elementos, chamamos produto cartesiano A x B o conjunto constituído pelos pares ordenados (x , y).Capítulo 5 - Operações lógicas com sentenças abertasResumidamente, dizemos que p(x) é uma sentença aberta em determinado conjunto se e somente se p(x) passar a uma proposição ao se substituir a variável x por um elemento desse conjunto. Essa proposição poderá ser falsa ou verdadeira. Chamemos V(p) o conjunto-verdade de uma sentença aberta.a. Negação Dada a sentença aberta p, Sua negação é $\\sim p$. O conjunto-verdade de $\\sim p$ em A é $V(\\sim p) = C(A)$ $V(p)=C(A){x\\in A p(x)}$, em que C(A) é o complemento de A. b. ConjunçãoDadas duas sentenças abertas p(x) e q(x) em um conjunto A, $p(x)\\wedge q(x)$ será verdadeira se houver um elemento $a\\in A$ que satisfaça ao mesmo tempo p(x) e q(x). Em outras palavras, o conjunto-verdade da sentença aberta $p(x)\\wedge q(x)$ em A será a interseção dos conjuntos-verdade V(p) e V(q), que representamos por: $V(p\\wedge q)=V(p)\\cap V(q)={x\\subset A|p(x)}\\cap {x\\in A|q(x)}$.c. DisjunçãoDadas duas sentenças abertas p(x) e q(x) em um conjunto A, $p(x)\\vee q(x)$ serão verdadeiras se houver um elemento $x\\in A$ que satisfaça pelo menos uma das sentenças abertas p(x) e q(x). Em outras palavras, o conjunto-verdade da sentença aberta $p(x)\\vee q(x)$ em A será a união dos conjuntos-verdade V(p) e V(q), que representamos por:d. Condicional ou implicação Dadas duas sentenças abertas p(x) e q(x) em um conjunto A, $p(x)\\to q(x)$ terá como conjunto-verdade = $V(p\\to q)=V(\\sim p)\\cup V(q)=C(A) V(p)\\cup V(q)$. Dessa definição, deduzimos que o conjunto-verdade $V(p\\to q)$ é a união dos conjuntos-verdade das sentenças abertas $\\sim p(x)$ e q(x). Portanto, $V(p\\to q)={x\\in A \\sim p(x)}\\cup {x\\in A q(x)}$. e. Bicondicional ou dupla implicação Dadas duas sentenças abertas p(x) e q(x) em um conjunto A, $p(x)\\leftrightarrow q(x)$, temos como conjunto-verdade $V(p\\leftrightarrow q)=V(p\\to q)\\cap V(q\\to p)=[V(\\sim p)\\cup V(q)]\\cap[V(\\sim q)\\cup V(p)]$. Dessa definição, deduzimos que o conjunto-verdade é a interseção dos conjuntos-verdade das sentenças abertas em A,$p(x)\\to q(x)$ e $q(x)\\to p(x)$; ou seja $V(p\\leftrightarrow q)=[{x\\in A \\sim p(x)}\\cup {x\\in A q(x)}]\\cap[{x\\in A \\sim q(x)}\\cup {x\\in A p(x)}]$. Quantificadores são utilizados para transformar sentenças abertas em proposições. $\\forall$ Qualquer que seja ou para todo (universal); $\\exists$ existe (existencial).Capítulo 6 - Implicações lógicasDizemos que uma proposição p implica logicamente uma proposição q quando em suas tabelas-verdade não ocorrer V e F numa mesma linha, nessa ordem. Representamos a relação de implicação lógica pelo símbolo $\\Rightarrow$.Não podemos confundir essa representação de implicação ($\\Rightarrow$) com a do conectivo “se… então…” ($\\to$). O símbolo $\\to$ representa uma operação lógica entre as proposições simples p e q, que resulta na proposição composta $p\\to q$. Então, podemos ter como resultado o valor lógico V ou o valor lógico F. Já o símbolo $\\Rightarrow$ representa a não ocorrência de V e F na mesma linha, na tabela-verdade de $p\\to q$, ou seja, $p\\to q$ é uma tautologia.Uma sentença aberta implica outra sentença aberta quando o conjunto-verdade da primeira está contido no conjunto-verdade da segunda. A recíproca também é verdadeira, ou seja, se a segunda sentença aberta implica a primeira sentença aberta, o conjunto-verdade da segunda está contido no conjunto-verdade da primeira.Propriedades das implicações:1ª) Uma implicação $p\\Rightarrow q$ só é verdadeira se a condicional $p\\rightarrow q$ for uma tautologia.2ª) A propriedade reflexiva e dada por $p\\Rightarrow p$.3ª) A propriedade transitiva é dada pela relação: se $p\\Rightarrow q$ e se $q\\Rightarrow r$, então $p\\Rightarrow r$. A transitividade se estende a qualquer quantidade de proposições.4ª) A propriedade antissimétrica é dada pela relação: se $p\\Rightarrow q$ e se $q\\Rightarrow p$, então $p\\iff r$. O símbolo $\\iff$ representa equivalência lógica.Entre implicações, há as seguintes relações:1ª) $p\\Rightarrow q$ e $q\\Rightarrow p$ (recíprocas). Devemos observar que duas proposições recíprocas não são necessariamente equivalentes, pois uma pode ser verdadeira, e a outra, não.2ª) $p\\Rightarrow q$ e $\\sim p\\Rightarrow\\sim q$ (inversas). Novamente é preciso observar que duas proposições inversas não são necessariamente equivalentes, pois uma pode ser verdadeira, e a outra, não.3ª) $p\\Rightarrow q$ e $\\sim q\\Rightarrow\\sim p$ (contrapositivas). Neste caso, duas proposições contrapositivas são logicamente equivalentes, pois, se uma é verdadeira, a outra também será.Temos as seguintes implicações básicas, também conhecidas como regras de inferência, pois são usadas para executar os passos de uma demonstração ou de uma dedução: $p\\Rightarrow p\\vee q$ (adição) $q\\Rightarrow p\\vee q$ (adição) $p\\wedge q\\Rightarrow p$ (conjunção) $p\\wedge q\\Rightarrow q$ (conjunção) $q\\wedge p\\Rightarrow p$ (conjunção) $q\\wedge p\\Rightarrow q$ (conjunção) $p\\wedge q\\Rightarrow p$ (simplificação) $p\\wedge q\\Rightarrow q$ (simplificação) $(p\\vee q)\\wedge(p\\vee\\sim q)\\Rightarrow p$ (simplificação disjuntiva) $p\\rightarrow q\\Rightarrow p\\rightarrow(p\\wedge q)$ (absorção) $(p\\rightarrow q)\\wedge p\\Rightarrow q$ (regra Modus Ponens) $(p\\rightarrow q)\\wedge\\sim q\\Rightarrow\\sim p$ (regra Modus Tollens) $(p\\vee q)\\wedge\\sim p\\Rightarrow q$ (silogismo disjuntivo) $(p\\vee q)\\wedge\\sim q\\Rightarrow p$ (silogismo disjuntivo) $(p\\rightarrow q)\\wedge(q\\rightarrow r)\\Rightarrow p\\rightarrow r$ (silogismo hipotético) $[p\\rightarrow(q\\vee r)]\\wedge\\sim q\\Rightarrow p\\rightarrow r$ (eliminação) $[(p\\rightarrow q)\\wedge(r\\rightarrow s)\\wedge(p\\vee r)]\\Rightarrow q\\vee s$ (dilema construtivo) $[(p\\rightarrow q)\\wedge(r\\rightarrow s)\\wedge(\\sim p\\vee\\sim s)]\\Rightarrow\\sim p\\vee\\sim r$ (dilema destrutivo) $p\\rightarrow q\\Rightarrow p\\rightarrow q\\vee r$ (regra da atenuação) $\\sim p\\rightarrow p\\Rightarrow p$ (regra da retorsão) $(p\\rightarrow r)\\wedge(q\\rightarrow r)\\Rightarrow(p\\vee q)\\rightarrow r$ (prova por casos)Teorema contrarecíproco:A proposição $p(x)\\Rightarrow q(x)$ é verdadeira se e somente se $\\sim q(x)\\Rightarrow\\sim p(x)$ também for verdadeira. Há, portanto, equivalência entre as implicações. Observe, entretanto, que não há equivalência entre as proposições $p\\rightarrow q$ e $\\sim p\\rightarrow\\sim q$.Capítulo 7 - Equivalências lógicasProposições são equivalentes quando suas tabelas-verdade forem iguais, fenômeno representado pelo símbolo $\\Leftrightarrow$. Não podemos confundir a equivalência ($\\Leftrightarrow$) com o conectivo “se, e somente se” ($\\leftrightarrow$).a. Se duas proposições são ambas tautológicas, então são proposições equivalentes.b. Se duas proposições são ambas contradições, então são proposições equivalentes.c. p$\\Leftrightarrow$p (reflexiva).d. Se $p\\Leftrightarrow q$ então $q\\Leftrightarrow p$ (simétrica).e. Se $p\\Leftrightarrow q$ e $q\\Leftrightarrow r$, então $p\\Leftrightarrow r$ (transitiva).Equivalências básicas: $p\\wedge p\\iff p$ (idempotentes) $p\\vee p\\iff p$ (idempotentes) $\\sim\\sim p\\iff p$ (dupla negação) $p\\wedge q\\iff q\\wedge p$ (comutativas) $p\\vee q\\iff q\\vee p$ (comutativas) $p\\wedge (q\\wedge r)\\iff(p\\wedge q)\\wedge r$ (associativa) $p\\vee (q\\vee r)\\iff(p\\vee q)\\vee r$ (associativa) $p\\leftrightarrow q\\iff q\\leftrightarrow p$ (comutativa) $p\\leftrightarrow q\\iff (p\\rightarrow q)\\wedge (q\\rightarrow p)$ (bicondicional) $p\\leftrightarrow q\\iff (p\\wedge q)\\vee (\\sim p\\wedge\\sim q)$ (bicondicional) $\\sim(p\\wedge q)\\iff\\sim p\\vee\\sim q$ (lei de De Morgan) $\\sim(p\\vee q)\\iff\\sim p\\wedge\\sim q$ (lei de De Morgan) $p\\wedge (p\\vee q)\\iff p$ (absorção) $p\\vee (p\\wedge q)\\iff p$ (absorção) $p\\rightarrow q\\iff p\\rightarrow (p\\wedge q)$ (absorção) $p\\wedge (q\\vee r)\\iff (p\\wedge q)\\vee (p\\wedge r)$ (distributiva) $p\\vee (q\\wedge r)\\iff (p\\vee q)\\wedge (p\\vee r)$ (distributiva) $(p\\rightarrow q)\\iff (\\sim q\\rightarrow\\sim p)$ (contrapositiva) $(q\\rightarrow p)\\iff (\\sim p\\rightarrow\\sim q)$ (recíproca da contrapositiva) $(p\\rightarrow q)\\iff\\sim p\\vee q$ (negação da condicional) $\\sim(p\\rightarrow q)\\iff\\sim(\\sim p\\vee q)\\iff p\\wedge\\sim q$ (negação da condicional) $\\sim(p\\leftrightarrow q)\\iff p\\vee q$ (negação da bicondicional) $p\\wedge q\\rightarrow r\\iff p\\rightarrow(q\\rightarrow r)$ (exportação-importação) $\\sim p\\rightarrow p\\iff p$ (Regra de Clavius)Equivalências entre implicações:a. $p\\Rightarrow q\\Leftrightarrow\\sim q\\Rightarrow \\sim p$b. $p\\Rightarrow q\\Leftrightarrow\\sim (p\\wedge\\sim q)$c. $p\\Rightarrow q\\Leftrightarrow\\sim p\\vee q$Capítulo 8 - Argumentos e silogismosUm argumento é uma afirmação de que, tendo um grupo finito de proposições com p = 1, 2, 3, …, n teremos como consequência uma proposição final que chamaremos de q. As proposições p, são premissas do argumento, e a proposição final é a conclusão. Um argumento que tenha as premissas e a conclusão q, é representado por:$p_1,p_2,p_3,…,p_n\\vdash q$O silogismo é todo argumento constituído por duas premissas que resultam numa conclusão.Um sofisma ou falácia é um argumento que não é válido, ou seja, um falso raciocínio lógico com aparência de verdadeiro, que nos leva a cometer um erro.Um paradoxo é um raciocínio que se faz a partir de premissas não contraditórias, mas que levam a uma conclusão contraditória. Também pode representar a ausência de lógica, apesar de aparentar um raciocínio correto.Um argumento é válido quando as premissas conduzem a uma conclusão obrigatória. Isso significa dizer que a validade de um argumento é em função da sua construção, e não do seu conteúdo.Quantificadores: todo, algum (pelo menos um) e nenhum.Equivalência entre todo e nenhum: “Nenhum A é B” = “Todo A é não B”; “Todo A é B” = “Nenhum A é não B”Negação para todo, algum e nenhum: “Todo A é B” - “Algum A não é B”; “Algum A é B” - “Nenhum A é B”; “Nenhum A é B” - “Algum A é B”.Dizemos que duas ou mais proposições são inconsistentes quando elas não podem ser simultaneamente verdadeiras. Assim, um argumento é inconsistente quando suas premissas não podem ser simultaneamente verdadeiras.Capítulo 9 - Lógica quantitativa e aplicações da lógica matemáticaCapítulo 10 - Circuitos lógicos" }, { "title": "Impedindo que uma barra de navegação fixa role sobre o conteúdo quando você clica em links internos", "url": "/posts/scroll-margin-top-propriedade/", "categories": "Estudos-faculdade", "tags": "web, css", "date": "2020-09-11 11:15:00 -0300", "snippet": "Se você tem uma barra de navegação na sua página marcada como position: fixed; no topo da tela, e você adiciona links internos para rolar a mesma página, você pode acabar com uma situação em que a barra de navegação sobrepõe o conteúdo da página.Para resolver isso você pode aplicar ao elemento de conteúdo que está sendo sobreposto a propriedade scroll-margin-top:section {scroll-margin-top: 1em;}Como o nome sugere, essa propriedade adiciona uma margem top válida apenas para o ato de rolar a página.Então você pode testar um valor compatível com a altura da sua barra de navegação, para que não sobreponha o conteúdo quando a página rolar." }, { "title": "Anotações sobre Kotlin", "url": "/posts/kotlin/", "categories": "Estudos-faculdade", "tags": "kotlin, android", "date": "2020-09-04 08:00:00 -0300", "snippet": "Introdução Open-source software (OSS) Orientada a objetos e funcional 100% compatível com Java Statically Typed Concise Safe Interoperable (pode trabalhar em conjunto com código Java) Kotlin roda na JVM: Kotlin code (.kt) -&gt; Kotlinc (compilador) -&gt; Byte code (.class) -&gt; JVM Não utiliza ponto e vírgula Não possui operador ternário tradicional Type safe e null safe Inferência de tipo Smart castConfiguração do Android Studio#Kotlin Em Android SDK, além de baixar as versões que você quer utilizar, marque “show package details” e baixe as “Google APIs Intel x86 Atom System Image” e “Intel x86 Atom System Image” respectivas de cada versão do Android, para um emulador mais eficiente. Depois, na aba SDK Tools, marque “show package details” e selecione: a versão mais recente do “Android SDK Build-Tools”, “Android Emulator”, “Android SDK Platform-Tools”, “Android SDK Tools” “Google Play Services”, “Google USB Driver”, “Intel x86 Emulator Accelerator (HAXM installer)”. Em “Support Repository”, selecione a versão mais recente do “ConstraintLayout for Android” e do “Solver for Constraint Layout”, e marque também “Android Support Repository” e “Google Repository”. (não disponível em versão mais recente do Android Studio) Ativar a virtualização: Nos processadores AMD é chamado AMD-V (sempre habilitado). Nos processadores Intel é chamado VT-X (pode estar desabilitado). Nos Recursos do Windows, ativar Hyper-V ou Plataforma do Hipervisor do Windows. Na pasta do projeto “Gradle Scripts”, no arquivo Build.gradle (Module: …), adicionar a plugins: id ‘kotlin-android-extensions’, para recursos estendidos do Kotlin Padrões de projeto e de código#KotlinMotivaçãoConvenções de código são um conjunto de recomendações para definir o estilo de codificação usado em métodos, variáveis, nome de classes, organização e nomenclatura de arquivos, comentários e outros recursos da linguagem. Convenciona-se para que a leitura seja mais fácil ao se deparar com um código desconhecido e também para que não haja diferentes estilos de programação dentro de um projeto, uma vez que frequentemente projetos são executados por diversas pessoas. As convenções descritas aqui estão no site oficial da linguagem Kotlin.Ponto e vírgulaA linguagem deixa como opcional o uso do ponto e vírgula e dessa maneira, como Kotlin preza pela limpeza do código, o uso do ponto e vírgula é desencorajado. Caso seja declarado na IDE, não haverá problema de compilação, mas haverá o aviso constante de que não é necessário.Nomenclaturas de código● Uso de camelCase começando com letra minúscula e evitando underline para: ○ variáveis ○ métodos ○ atributos de classe ● Identação com espaços com o auxílio da própria IntelliJ IDEA ou Android Studio. ● Variáveis privadas da classe se iniciam com m minúsculo seguido do nome da variável usando camelCase.Para constantes, marcados com a palavra const ou declarações val fora de classes e funções, devem usar todas as letras maiúsculas separados com underline.Métodos que façam sobrecarga são próximos uns dos outros.ClassesSe um arquivo Kotlin possuir uma classe somente, o nome do arquivo deve ser o mesmo nome da classe com a extensão .kt. Se um arquivo contiver múltiplas classes, o ideal é que o nome do arquivo seja algo que descreva a responsabilidade da classe da melhor maneira e mais sucinta possível. Para a nomenclatura, usar o padrão CammelCase com a primeira letra sempre maiúscula. Já para os parâmetros definidos dentro das classes, caso sejam poucos, podem ser escritas em uma única linha. Classes com construtores mais longos devem ser formatadas para que cada propriedade fique em uma linha. Além disso, o parênteses para fechar o construtor deve ficar em uma nova linha.Objects, companion objects, métodos que façam a sobrescrita da classe pai e construtores secundários ficam no início da classe.Chaves - {}Em if/else, while, for, do..while, try..catch, funções e classes sempre utilizar as chaves para abertura e fechamento do corpo das instruções.Unit (Void)O tipo Unit corresponde a nulo. Em funções que não há retorno, não há necessidade de declarar o retorno como Unit, basta deixar em branco. Caso a função possua retorno, então é necessário declarar o tipo.Activities e LayoutNomes de arquivos de layout devem ser prefixados com os elementos que representam: Componente Classe Nome do Layout Activity UserProfileActivity activity_user_profile.xml Fragment SignUpFragment fragment_sign_up.xml Dialog ChagePasswordDialog dialog_change_password.xml Arquivos XMLQuando um elemento não tiver nenhum conteúdo dentro das tags, deve-se usar “self closing” tags.Identificadores de elementosIdentificadores de elementos são escritos em minuscula_com_underline. Elemento Prefixo TextView text_ EditView edit_ Button button_ ImageView image_ Menu menu_ Estrutura principalfun main() { }Variáveisvar nome //variável mutávellateinit var nome //lateinit indica que a variável será inicializada tardiamenteval pi = 3.14 //variável imutávelconst val PI = 3.14 //constante cujo valor é atribuído durante a compilaçãovar caractere: Char = 'a'var nome: String = \"João\"var idade: Int = 10var preco: Double = 10.50 //padrão da linguagem para números. Para float ou long adicione letra 3.5f 600Lvar booleano: Bool = truevar nomes = arrayOf(\"nome1\", \"nome2\", \"nome3\", 520)var numeros = intArrayOf(10, 20, 30)Tipos.MAX_VALUE Int Boolean Long Char Float Byte Double Short Array Null Atribuiçãoval MaxValue = if (a&gt;b) a else if (a&lt;b) b else bFormatação de stringsfun main() { val frase = \"Kotlin é uma linguagem\" val caracteristica = \"show\" println(frase+caracteristica) println(\"Kotlin é uma linguagem\" + caracteristica) println(\"Kotlin é uma linguagem $caracteristica\") println(\"Kotlin é uma linguagem ${caracteristica.length}\") val stg = \"lskadlsadfj\" + \"alskdfjiweasdf\" + \"kldfgjsldkfgjlk\" val stg = \"\"\"lskadlsadfj alskdfjiweasdf kldfgjsldkfgjlk\"\"\" } Capitalização .capitalize(), .toUpperCase(), .toLowerCase(), .decapitalize() Remoção de espaços ou caracteres inadequados .trimEnd(), .trimStart(), .trim() Substituição de caracteres .replace(x, y) Formatação .format(valor) Empty x Blank Métodos de comparação; .isEmpty(), .isBlank(), .isNullOrBlank(), .isNullOrEmpty Se o tamanho da string for 0 está empty e blank Se o tamanho for &gt;0 mas todos os caracteres são espaços em branco, está blank mas não empty. Funçõesfun calculaBonus (a: Int, b: Int, c: String = “valor default”) : Int { //quando a função tem retorno, o tipo é indicado depois dos parâmetros. Quando há um valor default ele não precisa ser passado obrigatoriamente println(\"O bônus é: ${a+b}\") return a+b}N parâmetrosfun media (vararg notas: Float) { //vararg permite receber um numero variável de parâmetros if (notas.isNotEmpty()){ var soma = 0f for (nota in notas) { soma += nota } println(\"A média é ${soma/notas.size}\") }} fun &lt;T&gt; diversos (vararg valores: T) { //define um tipo genérico que aceita parâmetros de tipos diversos }Funções de uma única linha Infere o tipo de retornofun calculaBonus (a: Int, b: Int, c: Int) = println(\"O bônus é: ${a+b*c}\")Funções/extensões Prefixo fun Tipo.nomeDaFunção() Cria uma função que só pode ser chamada por um tipo específico, cujo valor pode ser referenciado dentro da função como this: fun String.randomCapitalizedLetter() = this[(0..this.lenght-1).random()].toUpperCase()Função localFunção interna a outra função, não acessivel diretamente, quase como se fosse private. Acessivel pela função pai, que pode ser chamada.Funções infixinfix fun Int.isHalfOf (value: Int) = value / 2 == thisfun main (args: Array&lt;Strings&gt;) {\t10.isHalfOf(40)\t10 isHalfOf 30 //Infix só pode ser usada com 1 parâmetro}Higher Order Functionsfun operator (x: Int, y: Int, op: (Int, Int) -&gt; Int): Int {\tval ret = op(x,y)\treturn ret}fun sum (x: Int, y:Int) = x+yfun main (args: Array&lt;String&gt;) {\tval list = listOf(1, 2, 3, 4)\tlist.forEach( {println(it)} ) //funções que recebem outras funções como parâmetro\toperator(1, 2, ::sum) //:: para indicar a função pelo nome sem assinatura}Lambdasfun operator (x: Int, y: Int, op: (Int, Int) -&gt; Int): Int {\tval ret = op(x,y)\treturn ret}fun main (args: Array&lt;String&gt;) {\toperator(10, 20, {a, b -&gt; a+b})\t\tval l1 = {a: Int, b: Int -&gt; a+b}//os lambdas conseguem executar apenas uma instrução\tval l2: (Int, Int) -&gt; Int = {u, i -&gt; u+i} //para executar mais de uma instrução é possível utilizar funções anonimas fun() {}\toperator(10, 20, l1)\toperator(10, 20, l2)}Operadores Aritméticosunários+=. ++, –, -=a++ (postfix) / –a(prefix)infix binários Soma(+) a.plus(b) Subtrair(-) a.minus(b) Multiplicar(*) a.times(b) dividir(/) a.div(b) %(resto da divisão) a.mod(b) Operadores relacionaisBinários/infixResultado sempre booleano == (igual a) a.equals(b) != (diferente) !(a.equals(b)) &gt; (Maior que) a.compareTo(b)&gt;0 &lt; (Menor que) a.compareTo(b)&lt;0 &gt;= (Maior ou igual) a.compareTo(b)&gt;=0 &lt;= (Menor ou igual) a.compareTo(b)&lt;=0 Operadores lógicos &amp;&amp; (e) and binário/infix || (Ou) or binário/infix ^ (ou exclusivo) xor binário/infix ! (negação) not unário/prefix Operadores in e range in (contém) !in (não contém) Se o valor está presente em uma lista ou uma faixa de valores range(int.int) Range cria um intervalo de valores Operator Overloading a + b a.plus(b) operator fun plus (b: TYPE): TYPE a - b a. minus(b) operator fun minus (b: TYPE): TYPE a * b a.times(b) operator fun times (b: TYPE): TYPE a / b a.div(b) operator fun div (b: TYPE): TYPE a..b a.rangeTo(b) operator fun rangeTo (b: TYPE): TYPE a in b b.contains(a) operator fun contains (b: TYPE): Boolean a += b a.plusAssign(b) operator fun plusAssign (b:TYPE): Unit a - = b a.minusAssign(b) operator fun minusAssign (b:TYPE): Unit a *= b a.timesAssign(b) operator fun timesAssign (b:TYPE): Unit a/= b a.divAssign(b) operator fun divAssign (b:TYPE): Unit a&gt;b a.compareTo(b) &gt;0 operator fun compareTo (b:Type): Int a&lt;b a.compareTo(b)&lt;0 operator fun compareTo(b:TYPE): Int a&gt;=b a.compareTo(b) &gt;=0 operator fun compareTo (b: Type): Int a&lt;=b a.compareTo(b)&lt;=0 operator fun compareTo (b: Type): Int Operador Elvis (?)val test: Int? = null //permite atribulir valor null a variávelval num: Int = test ?: 100 //se test for null, atribua 100, para evitar errosControle de fluxo if else if( idade &lt;= 9 ){ } else if( idade &gt;= 10 &amp;&amp; idade &lt;= 18 ){ } else{ }fun calculaIdade (idade: Int) : Boolean { //depois dos : indica o tipo de retorno da função return idade &gt;=18}val str = if(valor==10) \"sim\" else \"não\" //é possível utilizar if else diretamente na atribuição de uma variávelControle de fluxo – Whenwhen (c) { \"soma\" -&gt; { return a+b } \"subtração\" -&gt; { return a-b } else -&gt; { println(\"Operação incorreta\") return 0 }} when (a) { in 0..100 -&gt; { // o in e os dois pontos permitem criar um range, um intervalo de valores println(\"o número está entre 0 e 100\") }}Loops for e while Aceita os comandos in, range, until, downTo e step. forEach while( numero &lt;= 5 ){ } do{ }while(var palavra in palavras); for (i in 1..100 step 2) { print(\"$i \")}for (j in 100 downTo 0) { print(\"$j \")}Conversão de valores A operação entre valores de tipo diferente gera um resultado do tipo de maior tamanho. A conversão de valores deve ser explicita. Double 64 .toDouble() Float 32 .toFloat() Long 64 .toLong() Int 32 .toInt() Short 16 .toShort() Byte 8 .toByte() Char   .toChar() Exceções Tratamento para evitar a quebra da execuçãotry { println(\"joão\".toInt())}catch(e: NumberFormatException) { //exceção específica println(\"Erro na conversão de string para inteiro\")}catch(e: Exception) { //coloque a exceção mais genérica por último, do contrátio o erro sempre cairá nela e não na específica println(\"Erro genérico\")}finally { //sempre é executado, independentemente de erro //aqui poder incluir uma verificação, caso tenha havido erro, para encerrar o processo}Null Safe O operador Elvis em Kotlin permite que variáveis assumam valor nulo, dando mais segurança ao evitar erros relacionados a null.val str: String? = nullprintln(str?.length) //o operador elvis previne o erroprintln(str!!.lenght) // o operador !! permite que o erro ocorraPacotes Pacotes servem para separar códigos/usos, manter pacotes concisos e coesosimport basic.* //o asterisco indica que todos os recursos do pacote serão importadosClasses e Objetosclass Casa { //padrão de nomenclatura, classes com primeira letra maiúscula var cor: String = \"\" fun abrirJanela(qtdJanelas: Int){ //padrão de nomenclatura, métodos e propriedades em camelCase println(\"Abrir janela total: $qtdJanelas \") } fun abrirPorta(){ println(\"Abrir porta\") } fun abrirCasa(){ this.abrirJanela() this.abrirPorta() }}fun main(args: Array&lt;String&gt;) { val casa = Casa() //criação do objeto casa.cor = \"Amarela\" casa.abrirJanela( 10 ) val casa2 = Casa() casa2.cor = \"Vermelha\" println(casa.cor) println(casa2.cor)}Construtoresclass Casa( var cor: String) { //construtor primário, definido na declaração da classe var cor: String var vagasGaragem: Int constructor( vagasGaragem: Int ){ //construtor secundário, evitar utilizar ambos pedindo o mesmo parâmetro. Pode ser usado para pedir parâmetros adicionais, diferentes do construtor primário this.cor = cor this.vagasGaragem = vagasGaragem } init{ //inicializa as propriedades passadas para o construtor primário this.cor = cor this.vagasGaragem = vagasGaragem } fun detalhesCasa(){ println(\"A casa tem a cor: $cor, vagas: $vagasGaragem \") }}fun main(args: Array&lt;String&gt;) { val casa = Casa(\"Amarela\", 2) casa.detalhesCasa()}Herançaopen class Animal{ //no kotlin, por padrão, as classes não podem ser herdadas. Para fazer isso utilizar open open fun dormir(){ //o open aqui permite que o método seja sobrescrito pelas classes filhas println(\"Dormir\") } fun correr(){ println(\"Correr\") }}class Cao : Animal() { //notação para indicar herança override fun dormir(){ //sobrescrita de método super.dormir() //chama o método original println(\"como um cao\") //acrescenta a alteração sobrescrita } fun latir(){ println(\"Latir\") } fun latir(i: String){ //sobrecarga de método (overload). Método com mesmo nome, mas com parâmetros e implementação diferentes println(\"Latir como um $i\") } }class Passaro: Animal() {}fun main(args: Array&lt;String&gt;) { val cao = Cao() cao.dormir() cao.correr() cao.latir() val passaro = Passaro()}Modificadores Static e Final Ao tornar o atributo estático, ele fica acessível sem a necessidade de instanciar a classe em um objeto. O objeto marcado como final não pode ser alterado/sobrescrito. Constantes e Variáveis estáticasclass Constantes { companion object NOME { //companion object armazena constantes, funções e variáveis estáticas. O nome é opcional val TABLE = \"mesa\" //notação de constantes em maiúsculas fun teste() [ println(\"teste\") ] } object VENDAS { //nome obrigatório. É possível criar objects dentro de objectes, criando hierarquias var OBJETO = \"cadeira\" }}fun main() { Constantes.TABLE Constantes.NOME.TABLE Constantes.VENDAS.OBJETO}Getters e Setters O Kotlin cria getters e setters automaticamente, sem a necessidade de criação explicita (exceto quando você quer criar validações próprias, aí utilizar Field).Fieldclass Maquina (var marca: String) { var nucleos: Int =0 get() { println(\"get for chamado\") return field //a palavra field é utilizada para getters e setters para evitar chamadas recursivas } set(value) { println(\"set foi chamado\") field = value \t}}Classes EnumA clase enum pode ser utilizada como uma representação dos próprios objetos, sem instâncias.enum class Prioridade1 { //As classes enum servem para listar possibilidades BAIXA, MEDIA, ALTA}enum class Prioridade2 (val id: Int) { //classes enum também podem ser utilizadas como parâmetros de outras classes BAIXA(id:1) { override fun toString(): String{ return \"string de prioridade baixa\" } }, MEDIA(id:5), ALTA(id:10) //é possível fazer override dos atributos de um enum para, por exemplo, convertê-los em tipos primitivos para permitir comparações e verificações.}fun main(args: Array&lt;String&gt;) { println(Prioridade1.BAIXA) println(Prioridade2.BAIXA.id) for (p in Prioridade2.values()) { println(\"$p - ${p.id} - ${p.ordinal}\") //o atributo ordinal indica a posição do atributo no enum } }Data ClassArmazenar um estado imutavel em um objeto.data class Pessoa (var nome: String, var telefone: Int) { //data class é utilizada para agregar dados/atributos, que podem ser passados para outras funções e classes com mais facilidade}fun cadastro (var pessoa: Pessoa) {}//ao comparar 2 objetos em uma expressão lógica, são comparadas as posições de memória, mas quando utilizamos data class, são utilizados os atributos para comparação. Permite verificar a função .hashcode() para comparar e também copiar todos os valores para uma nova instância (.copy()).Classes Abstratasinterface Presidenciavel { //interface marca uma classe como uma interface//interface não pode ter valores, estados, variáveis abstract fun participarEleicao() //metodo abstrato sem corpo sem as chaves. As classes filhas são obrigadas a sobrescrever o método}abstract class Cidadao { //classe abstrata não pode ser instanciada, usada apenas para herança init{ //a funçõa init é sempre executada, independente de quantos objetos da classe são instanciados var cpf: String = 000.000.000-00 } fun direitosDeveres(){ println(\"Todo cidadão tem direitos e deveres\"); }}class Obama : Cidadao(), Presidenciavel() { //classe concreta instanciável @override fun participarEleicao(){ println(\"Participar eleicão Estados Unidos\"); }}//a herança em kotlin é sempre simples. Ou seja, uma classe só pode herdar de outra, mas pode implementar diversas interfacesInterface Pode-se dizer, grosso modo, que uma interface é um contrato que quando assumido por uma classe deve ser implementado. Interface é utilizada pois podemos ter muitos objetos (classes) que podem possuir a mesma ação (métodos), porém, podem executá-las de maneiras diferentes. A interface também é utilizada pois o Kotlin não permite herança múltipla (extends). Veja no exemplo de código anterior. With//Para chamar muitas funções de uma mesma classe ao mesmo tempo, pode-se usar withfun main () { var m = Maquina(marca: \"spto\") with(m) { ligar() processar() desligar() }}Nested ClassClasse internaclass Computer (val processador: String) {\tinner class Memory () { //classe interna\t}}fun main (args: Array&lt;String&gt;) {\tval m1: Computer.Memory = Computer().Memory()}Sealed ClassSealed Class limita o acesso da classe para herança ao mesmo aquivo onde ela está.sealed class Computer (val processador: String) {\t\t}Modificadores de Acesso private -&gt; Visível apenas dentro da classe protected -&gt; Funciona como o “private”, mas é visível em subclasses open -&gt; Visível em todo lugar, caso não seja definido é o padrão. internal -&gt; Lembra o Public, mas sua visibilidade é restringida ao módulo, sendo então visível dentro de um mesmo módulo.#Kotlinopen class Animal { internal var nome = \"marley\" fun dormir(){ println(\"Dormir\") }}class Cao : Animal() { fun exibeNome(){ println( \"Método exibe nome: $nome\" ) }}fun main(args: Array&lt;String&gt;) { val cao = Cao() cao.exibeNome() println( animal.nome )}ColeçõesO Kotlin não possui coleções próprias, ele utiliza as mesmas do Java.package collectionsfun main (args: Array&lt;Strings&gt;){\t//List, array, set, hashmap\tval l1 = listOf(\"Madrid\", \"São Paulo\", \"Berlin\") //imutável\tval l2 = mutableListOf(\"Madrid\", \"São Paulo\", \"Berlin\") //mutável\tval array = arrayListOf(\"Madrid\", \"São Paulo\", \"Berlin\") //utiliza os métodos do Java\tval s1 = setOf(\"Madrid\", \"São Paulo\", \"Berlin\") //não aceita elementos repetidos\tval s2 = mutableSetOf(\"Madrid\", \"São Paulo\", \"Berlin\") //não aceita elementos repetidos\tval h1 = hashMapOf&lt;String, String&gt;(Pair(\"key\", \"value\"), Pair(\"França\", \"Paris\")) //hashmap\tval h2 = mapOf&lt;String, String&gt;(Pair(\"key\", \"value\"), Pair(\"França\", \"Paris\")) //igual hashmap\tval h3 = mutableMapOf&lt;String, String&gt;(Pair(\"key\", \"value\"), Pair(\"França\", \"Paris\")) //igual hashmap}package XIIIColecoesdata class Receita(val nome: String, val calorias: Int, val ingredientes: List&lt;Ingredientes&gt; = listOf())data class Ingredientes(val nome: String, val quantidade: Int)fun main() { // Cria lista de dados val data = listOf( Receita( \"Lasanha\", 1200, listOf( Ingredientes(\"Farinha\", 1), Ingredientes(\"Presunto\", 5), Ingredientes(\"Queijo\", 10), Ingredientes(\"Molho de tomate\", 2), Ingredientes(\"Manjerição\", 3) ) ), Receita(\"Panqueca\", 500), Receita(\"Omelete\", 200), Receita(\"Parmegiana\", 700), Receita(\"Sopa de feijão\", 300), Receita( \"Hamburguer\", 2000, listOf( Ingredientes(\"Pão\", 1), Ingredientes(\"Hamburguer\", 3), Ingredientes(\"Queijo\", 1), Ingredientes(\"Catupiry\", 1), Ingredientes(\"Bacon\", 3), Ingredientes(\"Alface\", 1), Ingredientes(\"Tomate\", 1) ) ) ) // Tenho receitas na lista? println(\"Tenho receitas? ${if (data.any()) \"sim\" else \"não\"}.\") // Quantas receitas tenho na coleção? println(\"Tenho ${data.count()} receitas.\") // Tenho alguma receita de Lasanha? println(\"Tenho receitas de Lasanha? ${if (data.any { it.nome.contains(\"Lasanha\") }) \"sim\" else \"não\"}.\") // Quantas receitas de Lasanha? println(\"Tenho ${data.count { it.nome.contains(\"Lasanha\") }} receitas de Lasanha.\") // Qual a primeira e última receita? println(\"A primeira receita é: ${data.first().nome}.\") println(\"A última receita é: ${data.last().nome}.\") // Qual a soma de calorias? val sumCalories = data.sumBy { it.calorias } println(\"A soma de calorias é: $sumCalories\") // Me dê as duas primeiras receitas val firstTwo = data.take(2) for (x in firstTwo.withIndex()) { println(\"${x.index + 1} - ${x.value.nome}\") } // Sei como fazer panqueca? E sushi? val knowPanqueke = data.filter { it.nome == \"Panqueca\" }.any() println(\"Sei fazer panqueca? ${if (knowPanqueke) \"sim\" else \"não\"}\") val knowSushi = data.filter { it.nome == \"Sushi\" }.any() println(\"Sei fazer sushi? ${if (knowSushi) \"sim\" else \"não\"}\") // Quais são as comidas com mais de 500 calorias? data.filter { it.calorias &gt; 500 }.forEach { println(it.nome) } // Qual a receita mais calórica? E a menos calórica? val maisCal = data.maxBy { it.calorias } println(\"Mais calórica: ${maisCal?.nome}\") val menosCal = data.minBy { it.calorias } println(\"Menos calórica: ${menosCal?.nome}\") // Faça uma lista com o nome dos pratos data.map { it.nome } // Qual a média de calor de todas as receitas? val media = data.map { it.calorias }.average() println(\"A média de calorias é: $media.\") // Lista de dados simples val listaInteiros = listOf(1, 2, 6, 67, 7, 3, 34, 56, 3, 3, 2, 5, 34, 2) println(\"Lista distinta: ${listaInteiros.distinct()}.\") println(\"Máximo: ${listaInteiros.max()}.\") println(\"Mínimo: ${listaInteiros.min()}.\") // Eliminar receitas com mesmo nome println(data.distinctBy { it.nome }) // Ordenar uma lista listaInteiros.sorted() listaInteiros.sortedDescending() // Inverter uma lista listaInteiros.reversed()}Imagens Adicionar arquivos de imagem na pasta “res/drawable”. A classe R. armazena o id dos elementos de interface. Utilizar como unidade de tamanho “dp” para imagens e “sp” para textos, para melhor ajuste a diferentes telas. Botão Ao criar uma função que será ativada por botão na interface (onClick), essa função deverá receber como parâmetro uma view: Recuperar view por id: findViewbyID(R.id.nome_da_id) as tipodowidget ou Com o plugin Kotlin Android Extensions, você pode referenciar o id diretamente. fun gerarFrase(view: View){ val totalIntensArray = frases.size val numeroAleatorio = Random().nextInt( totalIntensArray ) texto.setText( frases[ numeroAleatorio ] )}Orientação padrão do app (em caso de rotação) Para definir uma orientação fixa acesse o arquivo AndroidManifest.xml na pasta manifests e adicione, após&lt;activity android:name=\".MainActivity\"&gt;\t&lt;android:screenOrientation=”portrait”&gt;Banco de dados (SQLite)Armazenamento de dadosBanco de dados relacional ○ Estrutura de tabelas ● Tipos de dados permitidos ○ TEXT, REAL, INTEGER, NULL, BLOBO SQLite é uma pequena biblioteca, implementada em C que oferece acesso a uma base de dados relacional SQL e suportando até 2 TB de dados. Seu armazenamento é feito em um arquivo de texto dentro do dispositivo, e não existe a necessidade de se estabelecer qualquer tipo de conexão JDBC ou ODBC por exemplo.#Kotlinpackage com.example.convidados.service.repositoryimport android.content.ContentValuesimport android.content.Contextimport android.text.Selectionimport com.example.convidados.service.constants.DataBaseConstantsimport com.example.convidados.service.model.GuestModelimport java.lang.Exceptionimport java.util.ArrayListclass GuestRepository private constructor(context: Context) { // Acesso ao banco de dados private var mGuestDataBaseHelper: GuestDataBaseHelper = GuestDataBaseHelper(context) /** * Singleton */ companion object { private lateinit var repository: GuestRepository fun getInstance(context: Context): GuestRepository { if (!::repository.isInitialized) { repository = GuestRepository(context) } return repository } } /** * Carrega convidado */ fun get(id: Int): GuestModel? { var guest: GuestModel? = null return try { val db = mGuestDataBaseHelper.readableDatabase // Colunas que serão retornadas val projection = arrayOf( DataBaseConstants.GUEST.COLUMNS.NAME, DataBaseConstants.GUEST.COLUMNS.PRESENCE ) // Filtro val selection = DataBaseConstants.GUEST.COLUMNS.ID + \" = ?\" val args = arrayOf(id.toString()) val cursor = db.query( DataBaseConstants.GUEST.TABLE_NAME, projection, selection, args, null, null, null ) // Verifica se existem dados no cursor if (cursor != null &amp;&amp; cursor.count &gt; 0) { cursor.moveToFirst() val name = cursor.getString(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.NAME)) val presence = (cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.PRESENCE)) == 1) guest = GuestModel(id, name, presence) } cursor?.close() guest } catch (e: Exception) { guest } } /** * Insere convidado */ fun save(guest: GuestModel): Boolean { return try { // writableDatabase - Para fazer escrita de dados val db = mGuestDataBaseHelper.writableDatabase val contentValues = ContentValues() contentValues.put(DataBaseConstants.GUEST.COLUMNS.NAME, guest.name) contentValues.put(DataBaseConstants.GUEST.COLUMNS.PRESENCE, guest.presence) db.insert(DataBaseConstants.GUEST.TABLE_NAME, null, contentValues) true } catch (e: Exception) { false } } /** * Faz a listagem de todos os convidados */ fun getAll(): List&lt;GuestModel&gt; { val list: MutableList&lt;GuestModel&gt; = ArrayList() return try { val db = mGuestDataBaseHelper.readableDatabase // Colunas que serão retornadas val projection = arrayOf( DataBaseConstants.GUEST.COLUMNS.ID, DataBaseConstants.GUEST.COLUMNS.NAME, DataBaseConstants.GUEST.COLUMNS.PRESENCE ) // Linha única // Cursor cursor = db.rawQuery(\"select * from Guest\", null); // Faz a seleção val cursor = db.query( DataBaseConstants.GUEST.TABLE_NAME, projection, null, null, null, null, null ) if (cursor != null &amp;&amp; cursor.count &gt; 0) { while (cursor.moveToNext()) { val id = cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.ID)) val name = cursor.getString(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.NAME)) val presence = (cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.PRESENCE)) == 1) val guest = GuestModel(id, name, presence) list.add(guest) } // Como verificar se um valor é nulo // cursor.isNull(cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.PRESENCE)) } cursor?.close() list } catch (e: Exception) { list } } /** * Faz a listagem de todos os convidados presentes */ fun getPresent(): List&lt;GuestModel&gt; { val list: MutableList&lt;GuestModel&gt; = ArrayList() return try { val db = mGuestDataBaseHelper.readableDatabase val cursor = db.rawQuery(\"SELECT id, name, presence FROM Guest WHERE presence = 1\", null) if (cursor != null &amp;&amp; cursor.count &gt; 0) { while (cursor.moveToNext()) { val id = cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.ID)) val name = cursor.getString(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.NAME)) val presence = (cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.PRESENCE)) == 1) val guest = GuestModel(id, name, presence) list.add(guest) } } cursor?.close() list } catch (e: Exception) { list } } /** * Faz a listagem de todos os convidados presentes */ fun getAbsent(): List&lt;GuestModel&gt; { val list: MutableList&lt;GuestModel&gt; = ArrayList() return try { val db = mGuestDataBaseHelper.readableDatabase val cursor = db.rawQuery(\"SELECT id, name, presence FROM Guest WHERE presence = 0\", null) if (cursor != null &amp;&amp; cursor.count &gt; 0) { while (cursor.moveToNext()) { val id = cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.ID)) val name = cursor.getString(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.NAME)) val presence = (cursor.getInt(cursor.getColumnIndex(DataBaseConstants.GUEST.COLUMNS.PRESENCE)) == 1) val guest = GuestModel(id, name, presence) list.add(guest) } } cursor?.close() list } catch (e: Exception) { list } } /** * Atualiza convidado */ fun update(guest: GuestModel): Boolean { return try { val db = mGuestDataBaseHelper.writableDatabase val contentValues = ContentValues() contentValues.put(DataBaseConstants.GUEST.COLUMNS.NAME, guest.name) contentValues.put(DataBaseConstants.GUEST.COLUMNS.PRESENCE, guest.presence) // Critério de seleção val selection = DataBaseConstants.GUEST.COLUMNS.ID + \" = ?\" val args = arrayOf(guest.id.toString()) db.update(DataBaseConstants.GUEST.TABLE_NAME, contentValues, selection, args) true } catch (e: Exception) { false } } /** * Remove convidado */ fun delete(id: Int): Boolean { return try { val db = mGuestDataBaseHelper.writableDatabase val selection = DataBaseConstants.GUEST.COLUMNS.ID + \" = ?\" val args = arrayOf(id.toString()) db.delete(DataBaseConstants.GUEST.TABLE_NAME, selection, args) true } catch (e: Exception) { false } }}Explorar banco de dados físico da aplicação: programa DB Browser for SQLiteNo Device File Explorer do emulador que estiver rodando a aplicação, você encontra o DB em data\\data\\pasta do app\\databasespackage com.example.convidados.service.repositoryimport android.content.Contextimport android.database.sqlite.SQLiteDatabaseimport android.database.sqlite.SQLiteOpenHelperimport com.example.convidados.service.constants.DataBaseConstantsclass GuestDataBaseHelper(context: Context) : SQLiteOpenHelper(context, NAME, null, VERSION) { /** * Método executado somente uma vez quando o acesso ao banco de dados é feito pela primeira vez */ override fun onCreate(db: SQLiteDatabase) { db.execSQL(CREATE_TABLE_GUEST) } /** * Método executado quando a versão do DATABASE_VERSION é alterada * Dessa maneira, a aplicação sabe que o banco de dados foi alterado e é necessário rodar o script de update */ override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {} companion object { private const val VERSION = 1 private const val NAME = \"Convidados.db\" private const val CREATE_TABLE_GUEST = (\"create table \" + DataBaseConstants.GUEST.TABLE_NAME + \" (\" + DataBaseConstants.GUEST.COLUMNS.ID + \" integer primary key autoincrement, \" + DataBaseConstants.GUEST.COLUMNS.NAME + \" text, \" + DataBaseConstants.GUEST.COLUMNS.PRESENCE + \" integer);\") }}AdaptersUm adaptador é um objeto que cria uma ponte entre uma AdapterView e os dados para aquela View. O adaptador provê acesso aos dados e também é responsável por criar uma View para cada registro presente no conjunto de dados.Layout e NavegaçãoInterfaces são criadas em XMLView: Geralmente representam elementos na interface que o usuário possa interagir. Ex: Button, EditText, Switch, ImageView, CheckBox.ViewGroup: Elementos de layout que definem o comportamento de outros elementos. Um agrupador de elementos de interface. Ex: LinearLayout, RelativeLayout, ConstraintLayout, RecyclerView.A quantidade de elementos influencia no processamento e tempo de carregamento.Quanto mais elementos e mais níveis, mais custo para processamento.Usar as medidas recomendadas para largura e altura dos elementos.Tamanho de fonte deve usar a medida “sp” (scale independent pixels)Tamanho de elementos, margins, paddings, etc devem usar “dp” (Density Independent pixels)Largura e altura também podem ser definidas relativas ao elemento pai ou ao próprio elementomatch_parent - Quando um elemento possui este valor no atributo largura ou altura (width ou height), seu tamanho será igual o tamanho do elemento pai (elemento exterior, nível acima)wrap_content - Quando um elemento possui este valor no atributo largura ou altura (width ou height), seu tamanho será o suficiente para acomodar seu conteúdoAtributos de LayoutPadding e Margin&lt;TextViewandroid:layout_marginStart= \"8dp\"android:layout_marginEnd= \"8dp\"android:padding=\"8dp\"android:paddingBottom= \"8dp\"android:paddingTop=\"8dp\"android:paddingLeft=\"8dp\"android:paddingRight= \"8dp\"android:layout_margin= \"8dp\"android:layout_marginLeft= \"8dp\"android:layout_marginRight= \"8dp\"android:layout_marginTop= \"16dp\"android:layout_marginBottom= \"16dp\" /&gt;Gravity e LayoutGravityGravity: Alinhamento dentro do elemento.android:gravity=”center”Opções: Center, right, left, bottom, top, center_horizontal, center_verticalLayoutGravity: Alinhamento do elemento com relação ao pai.android:layout_gravity= “center”Opções: Center, right, left, bottom, top, center_horizontal, center_verticalBackground e textColorBackgroundandroid:background=”#fff”Aplicável para View e ViewGrouptextColorandroid:textColor=”#0AA37D”Estrutura de um projeto AndroidManifests: Configurações globais do app (icone do app, nome, tema, tela inicial activity main, permissões).Java: classes e recursos Java.res: Resources. Drawable para recursos gráficos; Layout; Mipmap para imagens e icones; Values (cores, strings e estilos).Constraint layoutLayouts ajustáveis a diferentes telas.ScroolView permite criar um componente que cria uma barra de scrool se o componente ocupe uma região maior que a tela.ScrollView e HorizontalScrollViewVocê pode criar guidelines para ajustar os elementos no layout.Chain: você pode selecionar vários elementos e criar uma corrente entre eles (create … chain).Primeira versão liberada juntamente com Android Studio 2.3 (meio 2018)Criado com a intenção de deixar a hierarquia plana e melhorar a performance da aplicaçãoMelhorias significativas para que pudesse ser construído usando o Design do Android Studio além do XMLDisponível a partir da API 9Melhores práticasAo criar um novo elemento somente com width e height, o Android Studio notifica sobre as “constraints” do elementoThis view is not constrained, it only has designtime positions, so it will jump to (0,0) unless you add constraints.Significa que o elemento não sabe como se comportar na tela. Assim, ao criar um elemento, é necessário dizer quais suas “constraints” que também pode ser chamada de “restrições” ou “constantes”match_parent não é uma boa práticaMesmo que muitas vezes tenha o funcionamento esperado, deve-se usar constraints left e right e atribuir 0dpEquivalência RelativeLayout e ConstraintLayout RelativeLayout ConstraintLayout android:layout_alignParentLeft=”true” app:layout_constraintLeft_toLeftOf=”parent” android:layout_alignParentStart=”true” app:layout_constraintStart_toStartOf=”parent” android:layout_alignParentRight=”true” app:layout_constraintRight_toRightOf=”parent” android:layout_alignParentEnd=”true” app:layout_constraintEnd_toEndOf=”parent” android:layout_alignParentTop=”true” app:layout_constraintTop_toTopOf=”parent” android:layout_alignParentBottom=”true” app:layout_constraintBottom_toBottomOf=”parent” android:layout_alignStart=”@id/view” app:layout_constraintStart_toStartOf=”@id/view” android:layout_alignLeft=”@id/view” app:layout_constraintLeft_toLeftOf=”@id/view” android:layout_alignEnd=”@id/view” app:layout_constraintEnd_toEndOf=”@id/view” android:layout_alignRight=”@id/view” app:layout_constraintRight_toRightOf=”@id/view” android:layout_alignTop=”@id/view” app:layout_constraintTop_toTopOf=”@id/view” android:layout_alignBottom=”@id/view” app:layout_constraintBottom_toBottomOf=”@id/view” android:layout_toStartOf=”@id/view” app:layout_constraintEnd_toStartOf=”@id/view” android:layout_toLeftOf=”@id/view” app:layout_constraintRight_toLeftOf=”@id/view” android:layout_toEndOf=”@id/view” app:layout_constraintStart_toEndOf=”@id/view” android:layout_toRightOf=”@id/view” app:layout_constraintLeft_toRightOf=”@id/view” android:layout_above=”@id/view” app:layout_constraintBottom_toTopOf=”@id/view” android:layout_below=”@id/view” app:layout_constraintTop_toBottomOf=”@id/view” Layout Relativo e Layout LinearPara substituir o constraint layout (padrão atual), editar o xml.RelativeLayoutPosições das Views relativas à elas ou relativas ao pai (VIewGroup)Criado com a intenção de deixar a hierarquia mais simples e melhorar a performance da aplicaçãoOrientação da esquerda/topo para direita/inferiorlayout_alignParentTopSe marcado como “true”, o topo da View será alinhado ao topo do elemento pailayout_alignParentBottomSe marcado como “true”, o inferior da View será alinhado ao inferior do elemento pailayout_alignParentLeftSe marcado como “true”, a esquerda da View será alinhada à esquerda do elemento pailayout_alignParentRightSe marcado como “true”, a direita da View será alinhada à direita do elemento pailayout_centerInParentSe marcado como “true”, a View será horizontalmente alinhada com o pailayout_centerVerticalSe marcado como “true”, a View será verticalmente alinhada com o pailayout_aboveColoca o elemento acima de outra Viewlayout_belowColoca o elemento abaixo de outra Viewlayout_toLeftOfColoca o elemento à esquerda de outro elemento referenciado pelo IDlayout_toRightOfColoca o elemento à direita de outro elemento referenciado pelo IDlayout_toStartOfColoca o elemento à esquerda de outro elemento referenciado pelo IDlayout_toEndOfColoca o elemento à direita de outro elemento referenciado pelo IDLinearLayoutOrganiza os elementos de forma linear - Horizontal ou vertical.Ambas orientações não adequam os elementos para que caibam na tela.Caso sejam adicionados mais elementos do que a tela comporta, eles ficarão sobrepostos.É possível dividir a tela em partes atribuindo peso aos elementos: android:layout_weightNão é obrigatório que os pesos sejam os mesmo. É possível dividir a tela em partes com valores diferentes.Itent: transição para novas telas (activity)Como criar uma nova Activity a partir de uma já existente? Realizamos essa operação criando um objeto de mensagem que será utilizado para solicitar uma ação a outro componente de aplicativo. Este objeto de mensagem é conhecido como Intent, e trabalha com três dos componentes de aplicativo.graph LR A[Activity A] --&gt;|\"startActivity()\"| B(Intent) B --&gt; C{Android System} C --&gt;D(Intent) D --&gt;|\"onCreate()\"| E[Activity B]Iniciamos uma nova Activity passando sua referência a uma Intent e então passando esta Intent ao método startActivity(). Nesse caso a Intent descreverá a atividade a iniciar e carregará todos os dados necessários. Caso você necessite obter um resultado quando a nova Activity finalizar, basta passar a Intent ao método startActivityForResult(). Assim, sua Activity estará apta a receber o resultado como um objeto Intent separado no retorno de chamada onActivityResult().button_contato.setOnClickListener {\tval intent = Intent(this, DetalheContatoActivity::class.java)\tstartActivity(intent)}Passando dados entre Activitiesbutton_passar_dados.setOnClickListener {\tval intent = Intent(applicationContext, SegundaActivity::class.java)\t//Passar dados\tintent.putExtra(name:\"nome\", value:\"João\")\tintent.putExtra(name:\"idade\", value:\"28\")\tstartActivity(intent)}//no activity que vai receberval dados: Bundle = intent.extrasval nome = dados.getString(key:\"nome\")val idade = dados.getInt(key:\"idade\")text_nome.text = nometext_idade.text = idade.toString()Destruir uma Activity que não será mais utilizadafinish()SharedPreferencesUsado para dados pequenos de uso rápido, não usar como banco de dados.SharedPreferences e permite que tipos primitivos sejam salvos no formato “chave,valor”. Uma vez salvos, estes dados podem ser acessados de qualquer lugar de dentro de seu aplicativo, tanto para leitura quanto para escrita. No entanto, estes dados não poderão ser acessados a partir de outros aplicativos.Seu uso é comum em situações onde você deve guardar alguma informação primitiva (ou seja, tipos simples) entre sessões de utilização de seu aplicativo. Por exemplo, você poderia guardar o nome do usuário, suas configurações desejadas ou até mesmo a maior pontuação atingida em um jogo.Suas preferências podem ser salvas em um ou mais arquivos, dependendo de sua necessidade. Para preferências em nível de Activity, utiliza-se a chamada getPreferences(). Para preferências em nível de aplicação (ou seja, que podem ser acessadas de qualquer parte da aplicação utiliza-se a chamada getSharedPreferences().O acesso aos dados armazenados é feito através da instância de um objeto SharedPreferences, e a partir daí utilizamos métodos get para recuperação do valor.val shared = this.getSharedPreferences(name\"motivation\", Context.MODE_PRIVATE)shared.edit().putString(\"key\", \"value\").apply()InternacionalizaçãoNa pasta res, criar um xml values-** com o código relativo a língua. ISO 639-1Se o sistema estiver nessa língua, o idioma será setado automaticamente.Para mudar o idioma na aplicação:TextViewElemento de layout que possibilita mostrar um texto ao usuárioandroid:textTexto usado no elementoandroid:textColorCor do texto usado no elemento - Pode ser usado em hexadecimalandroid:textSizeTamanho do texto - Medida recomendada em “sp” (Scale independent pixels - Escala independente de pixels)Medida usada em “sp” permite o recurso de acessibilidade do celular alterar o tamanho da fonteandroid:textStylebold / italic / normalandroid:fontFamilyFonte usada no textoandroid:textAllCapsDefine todo o texto maiúsculo ou nãoEditTextElemento de layout que possibilita o usuário fornecer informações à aplicaçãoandroid:inputType=”OPÇÃO”text: Texto livrephone: Faz a troca do teclado para númerostextPassword: Esconde o texto informado pelo usuáriotextAutoCorrect: Faz sugestões de texto ao usuáriotextCapSentences: Torna o texto informado maiúsculonumber: Faz a troca do teclado para númerostextEmailAddress: Faz a troca do teclado com @ e caracteres usados no emailtextMultiLine: Permite que usuário digite diversas linhasandroid:imeOptions=”OPÇÃO”actionSearch: Troca o botão inferior direito para uma lupaactionNext: Troca o botão inferior direito para navegar para o próximo campoandroid:hint=”SEU TEXTO”Deixa um texto que funciona como sugestão para o usuárioÉ possível combinar opções. Não é necessário escolher somente uma entre as diversas disponíveisandroid:inputType=”textAutoCorrect|textCapSentencesImageViewCheckboxArquitetura MVVM (Model-View-ViewModel)Padrão arquitetural focado em separação de responsabilidades● Padrão adotado pela Google○ Recomendação de arquitetura para desenvolvimento de aplicação● Uso do Android Architecture Components○ Componentes desenvolvidos pela Google para ajudar a construir aplicações robustas○ LiveData e ViewModel■ Respeitam o ciclo de vida da aplicaçãograph TD A(Activity/Fragment) --&gt;B subgraph ViewModel B[[LiveData 3]] end B --&gt; C(Repository) subgraph Model D(Room) end subgraph Remote Data Source E(Retrofit) end C --&gt;D--&gt;F[(SQLite)] C --&gt;E--&gt;GActivity (View+ViewModel)graph LR subgraph B--&gt;A A[View]--&gt;B[ViewModel] end C--&gt;B B --&gt; C[Model]Ciclo de vida de uma activityUma Activity representa uma tela com interface gráfica capaz de promover algum tipo de interação com o usuário. Uma aplicação Android pode ser composta de diversas activities para fornecer um conjunto de funcionalidades para o usuário.Compreender o funcionamento e as transições é importante para o desenvolvimento e implementação da lógica da aplicação. Por exemplo, ao trabalhar com um aplicativo de vídeo, pode ser um requisito pausar o vídeo se o dispositivo receber uma ligação ou se outro aplicativo for aberto simultaneamente. Dentro do ciclo de vida da Activity, é possível declarar o comportamento quando o usuário deixa ou retorna a activity, de maneira a atingir esses requisitos.A activity possui um ciclo de vida específico. Quando um usuário abre o aplicativo, troca de tela ou deixa o aplicativo em segundo plano, existe uma transição entre estados descritos abaixo. Em outras palavras, as transições no ciclo de vida permitem a execução de códigos e funcionalidades apropriados para cada estado da activitygraph TD A([Activity launched]):::azul--&gt;B[\"onCreate()\"]--&gt;C[\"onStart()\"]--&gt;D[\"onResume()\"]--&gt;E([Activity running]):::verde G &amp; F--&gt;|Apps with higher priority need memory|J([App process killed]):::laranja--&gt;|User navigates to the activity|B E --&gt;|Another activity comes into the foreground| F[\"onPause()\"]--&gt;|The activity is no longer visible|G[\"onStop()\"]--&gt;|The activity is finishing or being destroyed by the system|H[\"onDestroy()\"]--&gt;I([Activity shut down]):::laranja F--&gt;|User returns to the activity|D G--&gt;|User navigates to the activity|K[\"onRestart()\"]--&gt;C classDef azul fill:#0E4357, color: #EDF4F5; classDef verde fill:#ADEEE3, color:#000; classDef laranja fill:#F5B841, color:#0E4357;Callbacks no ciclo de vidaSempre que uma activity muda de estado, o Android faz a chamada de um método (callback) correspondente.onCreate()Quando um aplicativo é aberto, o Android sabe qual a página inicial que deve ser criada, uma vez que está definida no AndroidManifest.xml. Com isso, o método onCreate() da activity é invocado. O método onCreate, embora não seja obrigatório, é sempre implementado por padrão na criação do projeto ou na criação de outras Activities. É criado por padrão por ser o melhor local para definição do layout, identificação dos elementos e inicialização de variáveis que serão usadas durante para implementação. Além disso, popular uma lista, fazer uma chamada à API ou acesso ao banco de dados são exemplos do que pode ser feito dentro deste método.onStart()Esse método faz com que a activity seja visível para o usuário, enquanto o aplicativo prepara para a activity entrar em funcionamento e se tornar interativa. O método onStart() é executado rapidamente e não é recomendado para processamentos pesados. Assim que esse callback é terminado, a activity entra no modo resumido.onResume()Quando a activity entrar no estado resumido, ela entra em funcionamento e está pronta para interação com o usuário. Assim que o aplicativo entra nesse estado, permanecerá assim até que algo aconteça e tire o foco do aplicativo. Por exemplo, uma chamada telefônica, um alarme ou a tela do aplicativo sendo bloqueada ou desligada. Se a activity retorna ao estado Resumido, o sistema chama onResume() novamente e não onStart(), uma vez que ela já foi iniciada e já está em memória. Por esse motivo, é necessário implementar onResume() para reinicializar componentes descartados no onPause(). Este método é chamado todas as vezes que uma activity se torna visível para o usuário, inclusive a primeira vez após a chamada do método onCreate() e onStart()onPause()Quando qualquer um dos eventos descritos no método onResume ocorre, o Android faz a chamada do callback onPause(). Esse método é chamado como o primeiro indicativo de que o usuário está saindo da activity. Este método deve ser usado para pausar animações e músicas que não devem continuar quando a tela está pausada. Por exemplo, se o aplicativo utiliza a câmera, o método onPause() é um ótimo local para desalocar o recurso da câmera para ser alocada posteriormente no método onResume(). A execução desse método é muito breve e não necessariamente dispõe de muito tempo para performar ações de salvar dados. Por esse motivo, esse método não deve ser usado para salvar dados da aplicação, chamadas a APIs ou banco de dados. Tais ações devem ser feitas no método onStop() descrito abaixo.onStop()Quando a activity não está mais visível para o usuário, porém ainda permanece alocada na memória o sistema invoca o callback onStop(). É neste método que todos os recursos alocados na criação devem ser descartados. O método também é recomendado quando se deseja realizar alguma operação que use relativamente a CPU, como por exemplo, salvar dados no banco de dados ou uma chamada a uma API. A partir deste estado, a activity volta a interagir com o usuário ou é finalizada e removida da memória. Se a activity voltar, o sistema invoca onRestart(). Se a activity terminar de ser executada, o sistema chamará onDestroy().onDestroy()Método chamado antes da activity ser destruída. Esta é a chamada final que a Activity recebe. Este método libera todos os recursos alocados que não tenham sido descartados previamente durante os outros métodos.RoomCamada de abstração do banco de dados.Parte do Architecture Componentsgraph TD subgraph Room A[Entity] B[\"DAO (Data Access Objects)\"] C[Database] endAdicionar a dependência no gradle:apply plugin: 'kotlin-kapt'implementation 'androidx.room:room-runtime:2.2.5'kapt 'androidx.room:room-compiler:2.2.5'GuestModel.kt:package com.example.convidados.service.modelimport androidx.room.ColumnInfoimport androidx.room.Entityimport androidx.room.PrimaryKey@Entity(tableName = \"Guest\")class GuestModel { @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") var id: Int = 0 @ColumnInfo(name = \"name\") var name: String = \"\" @ColumnInfo(name = \"presence\") var presence: Boolean = false}GuestDAO:package com.example.convidados.service.repositoryimport androidx.room.*import com.example.convidados.service.model.GuestModel@Daointerface GuestDAO { @Insert fun save(guest: GuestModel): Long @Update fun update(guest: GuestModel): Int @Delete fun delete(guest: GuestModel) @Query(\"SELECT * FROM Guest WHERE id = :id\") fun load(id: Int): GuestModel @Query(\"SELECT * FROM Guest\") fun getInvited(): List&lt;GuestModel&gt; @Query(\"SELECT * FROM Guest WHERE presence = 1\") fun getPresent(): List&lt;GuestModel&gt; @Query(\"SELECT * FROM Guest WHERE presence = 0\") fun getAbsent(): List&lt;GuestModel&gt;}GuestDatabase:package com.example.convidados.service.repositoryimport android.content.Contextimport androidx.room.Databaseimport androidx.room.Roomimport androidx.room.RoomDatabaseimport androidx.room.migration.Migrationimport androidx.sqlite.db.SupportSQLiteDatabaseimport com.example.convidados.service.model.GuestModel@Database(entities = [GuestModel::class], version = 1)abstract class GuestDatabase : RoomDatabase() { abstract fun guestDAO(): GuestDAO companion object { private lateinit var INSTANCE: GuestDatabase fun getDatabase(context: Context): GuestDatabase { if (!::INSTANCE.isInitialized) { synchronized(GuestDatabase::class) { INSTANCE = Room.databaseBuilder(context, GuestDatabase::class.java, \"guestDB\") .addMigrations(MIGRATION_1_2) .allowMainThreadQueries() .build() } } return INSTANCE } /** * Atualização de versão de banco de dados */ private val MIGRATION_1_2: Migration = object : Migration(1, 2) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\"DELETE FROM Guest\") } } }}GuestRepository:package com.example.convidados.service.repositoryimport android.content.ContentValuesimport android.content.Contextimport android.text.Selectionimport com.example.convidados.service.constants.DataBaseConstantsimport com.example.convidados.service.model.GuestModelimport java.lang.Exceptionimport java.util.ArrayListclass GuestRepository(context: Context) { // Acesso ao banco de dados private val mDataBase = GuestDatabase.getDatabase(context).guestDAO() /** * Carrega convidado */ fun get(id: Int): GuestModel { return mDataBase.load(id) } /** * Insere convidado */ fun save(guest: GuestModel): Boolean { return mDataBase.save(guest) &gt; 0 } /** * Faz a listagem de todos os convidados */ fun getAll(): List&lt;GuestModel&gt; { return mDataBase.getInvited() } /** * Faz a listagem de todos os convidados presentes */ fun getPresent(): List&lt;GuestModel&gt; { return mDataBase.getPresent() } /** * Faz a listagem de todos os convidados presentes */ fun getAbsent(): List&lt;GuestModel&gt; { return mDataBase.getAbsent() } /** * Atualiza convidado */ fun update(guest: GuestModel): Boolean { return mDataBase.update(guest) &gt; 0 } /** * Remove convidado */ fun delete(guest: GuestModel) { mDataBase.delete(guest) }}API - Conceitos teóricos e teste usando PostmanApplication Programming InterfaceNão se refere a Interface tratada em orientação a objetosFronteira que define a forma de comunicação entre duas partesComputação\tFuncionalidades de um software expostas\t\tConfiabilidade\t\tPraticidade\t\tAgilidadeAPI Web\tFuncionalidades expostas através de conexões Web\t\tHTTP, HTTPS\t\tRespostas no formato XML ou JSONExemplos\tLogin com redes sociais - Facebook, Gmail, Instagram, Twitter\tUso para construção de aplicações mobile, desktop, webRESTful X RPCRequisiçõesUso do protocolo HTTP / HTTPsComposta por 4 partes\tURL\tMethod\tBody\tHeaderURLEndereço web acessível https://jsonplaceholder.typicode.com/postsÉ um endereço como um site comum, porém disponibiliza dados para consumo ao invés de páginas web de leitura.MethodTambem chamado de verbo. Diz qual a maneira de interação com a API.Quatro tipos mais utilizados● POST (create)● GET (read)● PUT (update)● DELETE (delete)HeaderContém detalhes a respeito da requisição. Geralmente configurações sobre a requisição. Por exemplo, cache, content-type, dispositivo. Em muitos casos, autenticação também é fornecida através do header.BodyParâmetros da requisição. Por exemplo, se for uma requisição de inserção, o body contém os valores que deverão ser inseridos. Pode-se se pensar como os parâmetros de um método na programação.RespostaCódigo HTTPDescrevem o status da requisição. Status são padronizados como exemplo abaixo:● 1xx: Informações gerais;● 2xx: Sucesso na requisição e na resposta;● 3xx: Redirecionamento para outra URL;● 4xx: Erro (por parte do cliente);● 5xx: Erro (por parte do servidor).HeaderDetalhes a respeito da requisição.BodyContém a resposta da requisição. Pode ser uma lista de valores, valores únicos, depende do tipo de requisição e da informação requisitada.RetrofitAbstração para chamadas a APIParte do Architecture Componentsgraph TD subgraph Retrofit A[Entity] B[Serviço] C[Retrofit] endFingerprint - autenticação biométricaGradle:implementation 'androidx.biometric:biometric:1.0.1'ComponentesToast notificationUma pequena pop-up que exibe uma mensagem de texto para o usuário.Toast.makeText(applicationContext, \"texto\", Toast.LENGTH_LONG).show()Permite formação de layout.SnackbarGradle:implementation 'com.google.android.meterial:material:1.1.0'Snackbar.make(linear_root, \"texto\", Snackbar.LENGTH_LONG).show()Permite receber ação de clique.SpinnerLista suspensa.SeekBarBarra deslizante para selecionar valores de um range.SwitchInterruptor, on ou off.CheckboxRadioButton e RadioGroupDatePickerPode soprepor como uma janela de diálogo, ou ter uma visão de tela toda.TimepickerSemelhante ao datepicker.ProgressBarAndroidXAtualmente quando novas aplicações são criadas usando o Android Studio, ao entrar no arquivo gradle, percebe-se a presença de uma biblioteca chamada androidx. Em aplicações antigas (mas não tanto, 2018, 2019), ao entrar no arquivo gradle do projeto, é muito comum ver a seguinte dependência:implementation ‘com.android.support:appcompat-v7:28.0.0’Atualmente, a biblioteca androidx aparece da seguinte maneira:implementation ‘androidx.appcompat:appcompat:1.1.0’Em resumo, androidx é a mais nova atualização de funcionalidades Android que substitui completamente a antiga Support Library. Assim, em novos projetos, não existe mais referência a Support Library.Por que houve a troca de nome?A motivação por trás da troca de nome é a melhor separação de funcionalidades entre bibliotecas do sistema operacional Android e bibliotecas de desenvolvimento. Bibliotecas de desenvolvimento ficarão no pacote androidx.Uma motivação com um peso maior do que simplesmente organização é que como as bibliotecas de sistema e funcionalidade não estão mais juntas, elas podem ser atualizadas separadamente. Ou seja, seu projeto Android pode receber melhorias através da androidx sem a necessidade de atualizar as bibliotecas de sistema operacional. O pacote androidx traz dentro dele todas as bibliotecas de funcionalidades Android que são mais comumente chamadas de Android Jetpack.Android JetpackAndroid Jetpack é o nome dado as funcionalidades que são usadas para o desenvolvimento de aplicações Android. Por exemplo, Navigation, Preferences, Fragment, Layout, Room, ViewModel, Lifecycles, Notifications, Permissions e mais. As funcionalidades acima são usadas para realizar tarefas e implementações de maneira mais fácil. Não é necessário, por exemplo, escrever o código completo dizendo como o sistema operacional trata uma notificação, é necessário usar a funcionalidade de notificação já disponível.Este é o conceito do Android Jetpack, disponibilizar implementações que facilitem a vida do desenvolvedor, de maneira que possa focar em criar as funcionalidades da aplicação quepossuem valor para o usuário.Androidx roda em sistemas operacionais antigos?Sim. A nova atualização, assim como de costume, oferece retrocompatibilidade. Ou seja, é seguro usar a última versão da biblioteca, pois usuários de versões antigas não serão esquecidos" }, { "title": "Anotações sobre HTML", "url": "/posts/html/", "categories": "Estudos-faculdade", "tags": "html, web", "date": "2020-08-28 08:00:00 -0300", "snippet": " Html não é linguagem de programação, é linguagem de marcação.Estrutura básica&lt;!DOCTYPE html&gt;&lt;html lang=\"pt-br\"&gt;\t&lt;head&gt;\t\t&lt;meta charset=\"utf-8\"&gt;\t\t&lt;meta name=\"author\" content=\"André Milani\"&gt;\t\t&lt;meta name=\"keywords\" content=\"Textos, Painéis, Links, HTML\"&gt;\t\t&lt;meta name=\"description\" content=\"Aprendendo HTML básico: textos, painéis e links\"&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"estilos.css\"&gt;\t\t&lt;!--para importar uma webfont, antes do elemento style no html--&gt;\t\t&lt;link href=\"https://fonts.googleapis.com/css?family=Lobster\" rel=\"stylesheet\" type=\"text/css\"&gt;\t&lt;/head&gt;\t&lt;body&gt;\t&lt;/body&gt;&lt;/html&gt;Marcações semânticas&lt;nav&gt;&lt;main&gt;&lt;section&gt;&lt;aside&gt;&lt;article&gt;&lt;header&gt;&lt;footer&gt;&lt;hgroup&gt; &lt;h1&gt; &lt;h2&gt; ...&lt;em&gt;&lt;strong&gt;&lt;address&gt;&lt;cite&gt;&lt;blockquote&gt;&lt;address&gt;&lt;code&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;abbr title=\"\"&gt; abreviações&lt;time datetime\"ano-mês-diaThh:mm:ss-03:00\"&gt;&lt;del&gt; texto deletado/riscado&lt;ins&gt; texto inserido&lt;kbd&gt; keyboardMarcações - revisar&lt;!-- comentários em bloco --&gt;&lt;div&gt; */ painéis ou containers*/ &lt;spam&gt; marcar conteúdo dentro de um container &lt;ul&gt; &lt;li&gt; &lt;/li&gt; &lt;/ul&gt; //listas &lt;ol&gt; &lt;li&gt; &lt;/li&gt; &lt;/ol&gt; //listas &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; // Listas de definição &lt;a href=\"\" target=\"_blank // _self\"&gt;&lt;/a&gt; &lt;br&gt; e &lt;hr&gt; &lt;p&gt; &lt;b&gt; &lt;i&gt; &lt;u&gt; &lt;s&gt; &lt;iframe src=\"\" name=\"\" id=\"\"&gt;&lt;/iframe&gt; &lt;audio controls autoplay loop&gt; &lt;source src=\"\" type=\"audio/mp3\"&gt; &lt;/audio&gt; &lt;video controls poster=\"\" muted&gt; &lt;source src=\"\" type=\"video/mp4\"&gt; &lt;/video&gt; &lt;figure&gt; para imagens, gráficos ou mesmo trechos de códigos que podem ser independentes de posição no conteúdo. &lt;a href=\"http://www.youtube.com/user/softbluecursos\"&gt; &lt;img src=\"sbv2_brasilMap.png\" alt=\"\"&gt; &lt;/a&gt; &lt;figcaption&gt;Softblue: de Curitiba para todo o Brasil (mapa).&lt;/figcaption&gt; &lt;/figure&gt; &lt;video width=\"320\" height=\"180\" controls&gt; &lt;source src=\"seuVideo.mp4\" type=\"video/mp4\"&gt; Seu navegador não suporta esse vídeo. &lt;/video&gt; &lt;iframe width=\"320\" height=\"180\" src=\"https://www.youtube.com/embed/iTlKN1HJkb0\" frameborder=\"0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;style&gt;formatação css no html&lt;/style&gt; &lt;button acesskey=\"b\"&gt;botão com atalho na tecla b&lt;/button&gt; &lt;div tabindex=\"0\"&gt;para permitir colocar o elemento em foco por meio do teclado&lt;/div&gt; O valor define a ordemLinks para elementos internos e dead links&lt;a href=\"#links-header\"&gt;links para elemento interno&lt;/a&gt; &lt;!--criar links internos com #--&gt;&lt;h2 id=\"links-header\"&gt;&lt;a href=\"#\"&gt;dead link&lt;/a&gt; &lt;!--dead links podem ter seu comportamento alterado por Java Script--&gt;&lt;!--é possível aplicar mais de uma classe a um elemento, separando os nomes apenas com espaços--&gt;Tabelas&lt;table&gt; &lt;caption&gt; &lt;/caption&gt; &lt;thead&gt;//adicionar semântica &lt;tr&gt; &lt;th&gt;Table Head&lt;/th&gt; &lt;th&gt;Table Head&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt;&lt;/tfoot&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;tr&gt; &lt;td&gt;Table Row&lt;/td&gt; &lt;td&gt;Table Data&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; //colspan=\"\" //rowspan=\"\"Imagens//Mapas de imagem&lt;img src=\"\" usemap=\"#nomedomapa\"&gt;&lt;map name=\"nomedomapa\"&gt;&lt;area shape=\"rect//circle//poly\" coords=\"1,1,1,1\" href=\"\"&gt;&lt;/map&gt;//Imagens responsivas&lt;img src=\"\"(para navegadores antigos) srcset=\"link 400w, link 800w(largura da imagem)\" sizes=\"(min-width: 480px) 33.33vw, tamanhopararenderizar em viewports vw\"&gt;&lt;picture&gt; &lt;source media=\"(min-width: 480px)\" sizes=\"33vw\" srcset=\"rwd-images/1280.jpg 1280w, rwd-images/960.jpg 960w, rwd-images/480.jpg 480w\"&gt;&lt;source sizes=\"100vw\" srcset=\"rwd-images/822_mob.jpg 822w, rwd-images/640_mob.jpg 640w, rwd-images/320_mob.jpg 320w\"&gt;&lt;source srcset=\"\" type=\"\"&gt;&lt;img src=\"rwd-images/1280.jpg\" alt=\"texto alternativo\"&gt; &lt;/picture&gt;Formulários&lt;form method=\"get\" action=\"?\" enctype=\"multipart/form-data\"&gt;  diferentes metodos para envio dos dados para o servidor. action aponta o endereço de envio--&gt; usar get e action ? retorna os valores no endereço do próprio arquivo, e não envia arquivos anexos. prefira metodo post para mais segurança &lt;label&gt;Nome: &lt;/label&gt; &lt;input type=\"text\" name=\"campoNome\" placeholder=\"Insira aqui o seu nome...\" required&gt;  o atributo required torna o campo obrigatório &lt;input type=\"number\" name=\"campoIdade\" min=\"0\" max=\"115\" maxlength=\"30\"&gt;  o name não aparece na pagina, mas identifica os dados para o servidor &lt;fieldset&gt; agrupa campos &lt;legend&gt;outras informações&lt;/legend&gt; &lt;label for=\"sexo\"&gt;Sexo: &lt;/label&gt;  é considerada a melhor prática incluir um \"for\" com a mesma id dos imputs para que outras tecnologias possam reconhecer o relacionamento da label com os elementos filhos &lt;input id=\"sexo\" type=\"radio\" name=\"campoSexo\" value=\"M\"&gt; Masculino ////a marcação input não possui fechamento &lt;input id=\"sexo\" type=\"radio\" name=\"campoSexo\" value=\"F\"&gt; Feminino ///é preciso criar um radio para cada opção, com o mesmo name para limitar a marcação a uma unica opção é preciso incluir o value para informar o valor que será enviado para o servidor &lt;label for=\"likes\"&gt;Interesses: &lt;/label&gt; &lt;!--mesmo uso do for do caso radio--&gt; &lt;br&gt; &lt;input id=\"likes\" type=\"checkbox\" name=\"campoAutomovel\"&gt; Automóveis &lt;!--não utilize no name caracteres especiais--&gt; &lt;br&gt; &lt;input id=\"likes\" type=\"checkbox\" name=\"campoBarco\"&gt; Barcos    /////campos checkbox não enviam o valor do name, enviam \"on\" somente o quando o campo foi marcado, a menos que você inclua um value &lt;br&gt; &lt;input id=\"likes\" type=\"checkbox\" name=\"campoAviao\" checked&gt; Aviões&lt;!--incluir checked no radio ou checkbox torna o campo marcado por padrão--&gt; &lt;label&gt;Estado civil: &lt;/label&gt; &lt;select name=\"campoEstadoCivil\"&gt; &lt;option value=\"S\"&gt;Solteiro(a)&lt;/option&gt; &lt;option value=\"C\"&gt;Casado(a)&lt;/option&gt; &lt;option value=\"D\"&gt;Divorciado(a)&lt;/option&gt; &lt;option value=\"V\"&gt;Viúvo&lt;/option&gt; &lt;/select&gt; &lt;!--outra forma de campo similar a anterior--&gt; &lt;label&gt;Estado civil: &lt;/label&gt; &lt;input list=\"campoEstadoCivil\" name=\"campoEstadoCivil\"&gt; &lt;datalist id=\"campoEstadoCivil\" name=\"campoEstadoCivil\"&gt; &lt;option value=\"Solteiro(a)\"&gt;&lt;/option&gt; &lt;option value=\"Casado(a)\"&gt;&lt;/option&gt; &lt;option value=\"Divorciado(a)\"&gt;&lt;/option&gt; &lt;option value=\"Viúvo\"&gt;&lt;/option&gt; &lt;/datalist&gt; &lt;br&gt; &lt;/fieldset&gt; &lt;input type=\"email\" name=\"email\"&gt; &lt;input type=\"date\" name=\"data\"&gt; &lt;input type=\"range\" name=\"faixa\"&gt; &lt;input type=\"color\" name=\"cor\"&gt; &lt;textarea&gt;  &lt;/textarea&gt; &lt;input type=\"hidden\" name=\"campooculto\" value=\"oculto\"&gt;&lt;!--o campo oculto não é exibido na página, mas seu valor é enviado juntamente com o formulário--&gt; &lt;input type=\"file\" name=\"arquivo\"&gt; &lt;!--necessário incluir no form o parametro enctype=\"multipart/form-data\"--&gt; &lt;br&gt; &lt;input type=\"reset\" value=\"Limpar os dados\"&gt; &lt;input type=\"submit\" value=\"Enviar os dados\"&gt; &lt;!--botão para enviar--&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;Bootstrap Framework para desenvolvimento de sites responsivos; Possui uma vasta biblioteca de componentes. Bootstrap · The most popular HTML, CSS, and JS library in the world. (getbootstrap.com) A classe “container” possui largura fixa para cada tamanho de tela, enquanto que “container-fluid” expande por toda a largura disponível. " }, { "title": "Anotações sobre Sistemas de Gerenciamento de Banco de Dados", "url": "/posts/sistemas-gerenciamento-banco-dados/", "categories": "Estudos-faculdade", "tags": "banco-de-dados", "date": "2020-08-21 08:00:00 -0300", "snippet": "Baseado no livro: Sistemas de Gerenciamento de Banco de Dados (Ramakrishnan; Gehrke)1 Visão Geral sobre Sistemas de Banco de DadosUm banco de dados é uma coleção de dados que, tipicamente, descreve as atividades de uma ou mais organizações relacionadas.Um sistema de gerenciamento de banco de dados, ou SGBD, é um software projetado para auxiliar a manutenção e utilização de vastos conjuntos de dados.A emergência de diversos pacotes de planejamento de recurso empresarial (ERP — enterprise resource planning) e de planejamento de recurso de gerenciamento (MRP — management resource planning) acrescentaram uma camada substancial de recursos orientados a aplicativos acima de um SGBD.Vantagens de um SGBDIndependência de Dados, Acesso Eficiente aos Dados, Integridade e Segurança dos Dados, Administração de Dados, Acesso Concorrente e Recuperação de Falha, Tempo Reduzido de Desenvolvimento de Aplicativo.Uma vantagem muito importante de usar um SGBD é a independência de dados que ele oferece. Ou seja, os programas de aplicativos são isolados das alterações no modo como o dado é estruturado e armazenado.Descrevendo e armazenando dados em um SGBDUm modelo de dados é uma coleção de construtores de alto nível para descrição dos dados que ocultam vários detalhes de baixo nível do armazenamento. A maioria dos sistemas de gerenciamento de banco de dados atuais baseia-se no modelo de dados relacional.Um modelo de dados semântico é um modelo de dados de alto nível, mais abstrato, que facilita a um usuário alcançar uma boa descrição inicial dos dados de uma empresa.Um Exemplo de Projeto Ineficiente: O esquema relacional para Alunos ilustra uma escolha de projeto ineficiente; nunca se deve criar um campo tal como idade, cujo valor está constantemente sendo alterado. Uma escolha melhor seria DDN (Data Do Nascimento); a idade pode ser calculada com base nesse dado.O modelo relacional: O construtor central para descrição de dados deste modelo é uma relação, que pode ser considerada um conjunto de registros.Uma descrição de dados em termos de modelo de dados é chamada esquema (schema). No modelo relacional, o esquema de uma relação especifica seu nome, o nome de cada campo (ou atributo ou coluna), e o tipo de cada campo.Ex: Alunos (id-aluno: string, nome: string, login: string, idade: integer, média: real)Podemos tornar a descrição de um conjunto mais precisa especificando as restrições de integridade.Esquema conceitual: O esquema conceitual (chamado também de esquema lógico) descreve os dados armazenados em termos do modelo de dados do SGBD. Em um SGBD relacional, o esquema conceitual descreve todas as relações que estão armazenadas no banco de dados.O esquema físico especifica os detalhes adicionais de armazenamento. Essencialmente, o esquema físico resume como as relações descritas no esquema conceitual são realmente armazenadas em dispositivos de armazenamento secundário como discos e fitas.Esquemas externos, que normalmente também são representados em termos do modelo de dado do SGBD, permitem que o acesso aos dados seja customizado (e autorizado) no nível dos usuários individuais ou em grupos. Qualquer banco de dados tem exatamente um esquema conceitual e um esquema físico porque ele tem apenas um conjunto de relações armazenadas, mas pode ter diversos esquemas externos, cada um adaptado a um grupo particular de usuários.Cada esquema externo consiste em uma coleção de uma ou mais visões e relações do esquema conceitual.Consultas em um SGBDUm recurso muito atrativo do modelo relacional é o suporte a linguagens de consulta poderosas. O cálculo relacional é uma linguagem de consulta formal baseada na lógica matemática, e as consultas nesta linguagem têm um significado intuitivo e preciso. A álgebra relacional é outra linguagem de consulta formal, baseada em uma coleção de operadores para manipular relações, que é equivalente em poder ao cálculo.Gerenciamento de transaçõesUma transação é uma execução qualquer de um programa de usuário em um SGBD. Uma importante tarefa de um SGBD é planejar os acessos concorrentes aos dados de forma que cada usuário possa seguramente ignorar o fato de que há outros usuários acessando os dados concorrentemente.Um protocolo de bloqueio é um conjunto de regras que devem ser seguidas por cada transação (e forçadas pelo SGBD) para assegurar que, mesmo que ações de diversas transações possam ser intercaladas, o efeito geral seja idêntico à execução de todas as transações em alguma ordem serial. Um bloqueio é um mecanismo utilizado para controlar o acesso aos objetos do banco de dados. Dois tipos de bloqueios são normalmente suportados por um SGBD: bloqueios compartilhados em um objeto podem ser mantidos por duas transações diferentes ao mesmo tempo, mas um bloqueio exclusivo em um objeto assegura que nenhuma outra transação mantenha nenhum bloqueio nesse objeto.Um SGBD deve assegurar que as alterações realizadas por transações incompletas ou falhas do sistema sejam removidas do banco de dados. Para fazer isso, o SGBD mantém um log de todas as escritas no banco de dados. Uma propriedade crucial do log é a de que cada ação de escrita deve ser registrada no log (em disco) antes que a alteração correspondente seja refletida no banco de dados propriamente dito. Essa propriedade é chamada Write-Ahead Log (Gravação Antecipada do Log) ou WAL.O tempo necessário para a recuperação de uma falha pode ser reduzido forçando periodicamente o registro de alguma informação no disco; esta operação periódica é chamada ponto de verificação (checkpoint).Estrutura de um SGBDAdministrador de banco de dados (DBA — database administrator).2 Introdução ao Projeto de Banco de DadosModelo de entidade-relacionamento (ER)O processo de projeto de banco de dados pode ser dividido em seis etapas. O modelo ER é o mais relevante nas três primeiras etapas: Análise de requisitos; Projeto Conceitual do Banco de Dados (semântica); Projeto Lógico de Banco de Dados; Refinamento do Esquema; Projeto Físico de Banco de Dados; Projetos de Aplicativos e Segurança Uma entidade é um objeto do mundo real distinguível de outros objetos. Normalmente, é útil identificar uma coleção de entidades semelhantes. Tal coleção é chamada conjunto de entidades. Observe que os conjuntos de entidades não precisam ser disjuntos. Uma entidade é descrita utilizando-se um conjunto de atributos. Todas as entidades em um determinado conjunto de entidades têm os mesmos atributos. Para cada atributo associado a um conjunto de entidades, devemos identificar um domínio de possíveis valores. Além disso, para cada conjunto de entidades, escolhemos uma chave, que consiste em um conjunto mínimo de atributos cujos valores identificam unicamente uma entidade do conjunto. Pode haver mais de uma chave candidata; se houver, designamos uma delas como a chave primária.Um relacionamento é uma associação entre duas ou mais entidades. Como com as entidades, podemos desejar reunir um conjunto de relacionamentos semelhantes em um conjunto de relacionamentos. Um relacionamento também pode ter atributos descritivos.graph BT A((CPF)) --- H[Funcionários] B((nome)) --- H C((vaga)) --- H H ---I D((desde)) --- I{Trabalha_em} E((id-dpto)) --- J[Departamentos] F((nome-depto)) --- J G((orçamento)) --- J I --- JUma instância de um conjunto de relacionamentos é um conjunto de seus relacionamentos. Intuitivamente, uma instância pode ser considerada o ‘retrato’ do conjunto de relacionamentos em determinado momento.Recursos Adicionais do Modelo ERRestrições de chave: um para um; muitos para muitos; um para muitos.Restrição de participação: a participação do conjunto de entidades Departamentos no conjunto de relacionamentos Gerencia é considerada total. Uma participação que não é total é dita parcial. Como um exemplo, a participação do conjunto de entidades Funcionários em Gerencia é parcial, uma vez que nem todo funcionário gerencia um departamento.Conjunto de entidades fracas: Uma entidade fraca pode ser univocamente identificada apenas se considerarmos alguns dos seus atributos em conjunto com a chave primária de uma outra entidade, que é chamada proprietária identificadora.Hierarquia de Classe: A especialização é o processo de identificar subconjuntos de um conjunto de entidades (a superclasse) que compartilham algumas características distinguíveis. A generalização consiste em identificar algumas características comuns de uma coleção de conjuntos de entidades e criar um novo conjunto de entidades que contenha as entidades possuindo essas características comuns. As restrições de sobreposição determinam se duas subclasses podem conter a mesma entidade. As restrições de cobertura determinam se as entidades das subclasses incluem coletivamente todas as entidades da superclasse.Agregação nos permite indicar que um conjunto de relacionamentos (identificado através de um quadro tracejado) participa de outro conjunto de relacionamentos.graph TD\tsubgraph agregador\tK((cpf)) --- L[Funcionários] \tM((nome)) --- L \tN((vaga)) --- L \tL --- O{Monitora} \tO --- P((até)) \tO --- Q[agregado] \tstyle Q stroke-dasharray: 5 5 \tend \tsubgraph agregado \tI --- J \tH ---I \tH[Funcionários] --- A((CPF)) \tH --- B((nome)) \tH --- C((vaga)) \tI{Trabalha_em} --- D((desde)) \tJ[Departamentos] --- E((id-dpto)) \tJ --- F((nome-depto)) \tJ --- G((orçamento)) \tstyle agregado stroke-dasharray: 5 5 \tendProjeto Conceitual com o Modelo EREntidade versus AtributoEntidade versus RelacionamentoRelacionamentos Binários versus Relacionamentos TernáriosAgregação versus Relacionamentos TernáriosAbordagem da linguagem de modelagem unificada (UML — Unified Modeling Language)3 O Modelo RelacionalO modelo relacional é muito simples e elegante: um banco de dados é uma coleção de uma ou mais relações, em que cada relação é uma tabela com linhas e colunas. Essa representação tabular simples permite que até usuários iniciantes entendam o conteúdo de um banco de dados e possibilita o uso de linguagens de alto nível simples para consultar os dados. As principais vantagens do modelo relacional em relação aos modelos de dados mais antigos são sua representação de dados simples e a facilidade com que mesmo consultas complexas podem ser expressas.O principal construtor para representar dados no modelo relacional é a relação. Uma relação consiste em um esquema de relação e em uma instância de relação. A instância de relação é uma tabela, e o esquema de relação descreve os cabeçalhos de coluna da tabela. Primeiro, descreveremos o esquema de relação e depois a instância de relação. O esquema especifica o nome da relação, o nome de cada campo (ou coluna ou atributo) e o domínio de cada campo. Um domínio é descrito em um esquema de relação pelo nome de domínio e tem um conjunto de valores associados.Uma instância de uma relação é um conjunto de tuplas, também chamadas registros, no qual cada tupla tem o mesmo número de campos que o esquema de relação. Uma instância de relação pode ser considerada uma tabela na qual cada tupla é uma linha e todas as linhas têm o mesmo número de campos. Essas restrições de domínio no esquema especificam uma condição importante que queremos que cada instância da relação satisfaça: os valores que aparecem em uma coluna devem ser extraídos do domínio associado a essa coluna. Assim, em termos de linguagem de programação, o domínio de um campo é basicamente o tipo desse campo e restringe os valores que podem aparecer no campo. O grau, também chamado aridade, de uma relação é o número de campos. A cardinalidade de uma instância de relação é o número de tuplas que ela contém. Na Figura 3.1, o grau da relação (o número de colunas) é cinco e a cardinalidade dessa instância é seis. Um banco de dados relacional é uma coleção de relações com nomes distintos. O esquema de banco de dados relacional é a coleção de esquemas das relações presentes no banco de dados. Um banco de dados é tão bom quanto as informações nele armazenadas e, portanto, um SGBD deve ajudar a evitar a entrada de informações incorretas. Uma restrição de integridade (RI) é uma condição especificada sobre um esquema de banco de dados e limita os dados que podem ser armazenados em uma instância do banco de dados. Se uma instância do banco de dados satisfaz todas as restrições de integridade especificadas em seu esquema, então ela é uma instância válida. Um SGBD impõe restrições de integridade, no sentido de que ele permite o armazenamento apenas de instâncias válidas no banco de dados. Uma restrição de chave é uma declaração de que certo subconjunto mínimo dos campos de uma relação é um identificador único para uma tupla. Um conjunto de campos que identifica uma tupla de acordo com uma restrição de chave é chamado chave candidata da relação; freqüentemente, abreviamos isso apenas como chave. Além de todas as chaves candidatas disponíveis, um projetista de banco de dados pode identificar uma chave primária. Intuitivamente, uma tupla pode ser referenciada em qualquer outra parte do banco de dados armazenando-se os valores de seus campos de chave primária. Às vezes, as informações armazenadas em uma relação estão ligadas às informações armazenadas em outra relação. Se uma das relações for modificada, a outra deverá ser verificada e, talvez, modificada, para manter os dados consistentes. Uma RI envolvendo as duas relações deverá ser especificada, caso um SGBD precise fazer tais verificações. A RI mais comum envolvendo duas relações é uma restrição de chave estrangeira. CREATE TABLE Matriculado ( id-aluno CHAR (20), id-curso CHAR (20), nota CHAR (10), PRIMARY KEY (id-aluno, id-curso), FOREIGN KEY (id-aluno) REFERENCES Alunos ) As restrições de domínio, de chave primária e de chave estrangeira são consideradas parte fundamental do modelo de dados relacional e recebem atenção especial na maioria dos sistemas comerciais. Às vezes, entretanto, é necessário especificar restrições mais gerais. Os sistemas de banco de dados relacionais atuais suportam essas restrições gerais na forma de restrições de tabela e assertivas. As restrições de tabela são associadas a uma única tabela e verificadas quando essa tabela é modificada. Em contraste, as assertivas envolvem várias tabelas e são verificadas quando qualquer uma dessas tabelas é modificada.CREATE TABLE Matriculado ( id-aluno CHAR (20), id-curso CHAR (20), nota CHAR (10), PRIMARY KEY (id-aluno, id-curso), FOREIGN KEY (id-aluno) REFERENCES Alunos \tON DELETE CASCADE \tON UPDATE NO ACTION ) A SQL permite que uma restrição esteja no modo DEFERRED ou IMMEDIATESET CONSTRAINT nome-restrição DEFERREDUm conjunto de entidades é mapeado em uma relação de maneira direta: cada atributo do conjunto de entidades torna-se um atributo da tabela. Note que conhecemos os domínios de cada atributo e a chave (primária) de um conjunto de entidades.Uma visão é uma tabela cujas linhas não são armazenadas explicitamente no banco de dados, mas são calculadas conforme for necessário, com base em uma definição de visão. O mecanismo de visão fornece o suporte para independência lógica de dados no modelo relacional. Ou seja, visões podem ser usadas para definir relações no esquema externo que mascaram para os aplicativos as alterações feitas no esquema conceitual do banco de dados. Por exemplo, se o esquema de uma relação armazenada é alterado, podemos definir uma visão com o esquema antigo e os aplicativos que esperam ver o esquema antigo podem agora usar essa visão. As visões também são valiosas no contexto da segurança: podemos definir visões que dêem a um grupo de usuários acesso apenas às informações que eles podem ver." }, { "title": "Anotações sobre SQL", "url": "/posts/sql/", "categories": "Estudos-faculdade", "tags": "banco-de-dados, sql", "date": "2020-08-14 08:00:00 -0300", "snippet": "1 Introdução a Bancos de DadosLinguagem SQL ANSI - pequena diferença com MySQLMecanismos de armazenamento de dados. Conjunto de informação com estrutura regular.• Bancos de dados não relacionais– Arquivos estruturados• Bancos de dados relacionais– Dados organizados em tabelas– Tabelas podem se relacionar com outras tabelas– Menor espaço de armazenamento– Maior velocidade de acesso aos dados– Padrão mundialmente utilizadoLinhas=registros=tuplasVisões - consultas SQL e dados das tabelas do banco sem armazená-los.Índices - Estruturas que gerenciam a ordenação de valores dos campos informados para melhorar a performance de processamento destes campos.SGBD– Sistema Gerenciador de Banco de Dados - controlador de acesso– DBMS: Database Management System– SGBD não é um banco de dados, mas sim um complemento– SGBD é um grupo de programas para interação com os dadosSQL (Structured Query Language)– Linguagem Estruturada de Consulta• Formada pelo conjunto das linguagens:– DDL (Data Definition Language): Linguagem de Definição de Dados– DML (Data Manipulation Language): Linguagem de Manipulação de Dados– DQL (Data Query Language): Linguagem de Consulta de Dados– DCL (Data Control Language): Linguagem de Controle de Dados - Gerenciar o acesso aos dados.– DTL (Data Transaction Language): Linguagem de Transação de Dados - Gerenciar conjuntos de operações sobre os dados.DDL• CREATE: Cria uma estrutura• ALTER: Altera uma estrutura• DROP: Exclui uma estruturaDML• INSERT: Insere dados• UPDATE: Altera dados• DELETE: Exclui dadosDQL• SELECT: Retorna dados: Ordenação de dados, Agrupamento de dados, Funções aritméticas, Filtros de seleçãoDCL• GRANT: Habilita acesso a dados e operações• REVOKE: Revoga acesso a dados e operaçõesDTL• START TRANSACTION: Inicia a transação• COMMIT: Concretiza a transação• ROLLBACK: Anula a transaçãoPrincipais bancos de dados   MySQL PostgreSQL Firebird Oracle SQL Server SGBD Sim Sim Sim Sim Sim ACID Sim Sim Sim Sim Sim Licença Comercial Não Sim Sim Não Não Licença Estudante Sim Sim Sim Oracle Express SQL Server Express 2 Normalização de DadosRelacionamentos e chaves• Relacionamentos: Ligações entre tabelas.• Chave Primária (Primary Key, PK): Coluna com valores únicos• Chave Composta: Composição de duas ou mais colunas para gerar uma combinação única• Chave Estrangeira (Foreign Key, FK): Coluna que armazena a chave primária de outra tabela• Relacionamento 1 para 1 (1:1): Para cada registro da primeira tabela existe no máximo um correspondente na segunda tabela, e vice-versa.• Relacionamento 1 para muitos (1:*): Para cada registro da primeira tabela pode existir um ou mais correspondentes na segunda tabela, e para cada registro na segunda tabela existe apenas um registro correspondente na primeira tabela.• Relacionamento muitos para muitos (*:*): Para cada registro da primeira tabela pode existir um ou mais correspondentes na segunda tabela, e vice-versa.Quanto menores as chaves (menos digitos), melhor. Maior transparência para o usuário.Melhor usar códigos internos do sistema como chaves, e não dados exteriores ao sistema.A normalização serve para: evitar anomalias; Facilitar a manutenção; Maximizar a performance; Manter a integridade dos dados;Diagrama de modelo de dadosAnomalias dos dados• Tabelas “fazem tudo” geram anomalias• Anomalia de inserção: Impede a inclusão de registros devido à falta de dados• Anomalia de exclusão: Impede a exclusão de registros devido ao relacionamento com outra tabela• Anomalia de alteração: Impede a alteração de registros devido ao relacionamento com outra tabelaNormalização de dados– 5 Formas Normais (FNs)– Na prática a normalização é feita por intuição– Resulta em um número maior de tabelas no banco– Mais tabelas podem aumentar a manutenção e diminuir a performance– Deve ser utilizado com bom sensoPrimeira Forma Normal (1FN)• Cada linha de tabela deve representar um registro• Cada célula de tabela deve conter um único valorSegunda Forma Normal (2FN)• Obrigatoriamente estar na 1FN• Atributos não chave da tabela devem depender de alguma das chaves da tabelaTerceira Forma Normal (3FN)• Obrigatoriamente estar na 2FN• Atributos não chave da tabela devem depender exclusivamente da chave primária da tabela4FN e 5FN• Separam em novas tabelas valores que ainda estejam redundantes em uma mesma coluna3 Criando um Banco de DadosSQL ANSI, ISO e outros• SQL (Structured Query Language): Linguagem declarativa, detalha a forma do resultado Criado no início dos anos 70, em laboratórios da IBM novos dialetos surgiram, derivando e evoluindo o SQL• Necessidade de padronização: American National Standards Institute (ANSI) em 1986; International Organization for Standardization (ISO) em 1987; Revisto pela primeira vez em 1992 originando o padrão SQL-92; Outras revisões: SQL:1999 incorporou características de expressões regulares, queries recursivas e triggers; SQL:2003 incorporou características de XML, sequências SQL:2008, SQL:2011.Bancos de dados criam e evoluem suas próprias derivações do SQL. Curso aborda SQL padrão, com menções a outras derivaçõesTipos de dadosBooleano e Numérico; String (char, onde o dado ocupará todo o espaço reservado, mesmo com espaços em branco, se necessário; e varchar, armazenando dados de tamanho variado sem espaços em branco desnecessários); Data e hora; Listas customizáveis (ENUM, não disponível em SQL Server ou Firebird).BLOB: Permite o armazenamento de informações binárias, arquivos e imagens;TEXT: Permite o armazenamento de grandes informações de strings;Redes: Permite o armazenamento de endereços IP, MAC-ADDRESS e outros;Monetários: Permite o armazenamento de valores monetários com formatação;Geométricos: Permite o armazenamento de informações de formas geométricas;AtributosNULL / Not NULL: Permite ou não valores nulos;Unsigned / Signed: Permite ou não números negativos;Auto-increment: Sequências, contadores;Zerofill: Preenche o valor numérico completando com zeros a esquerda;Boas práticas de armazenamentoEspaço em disco: Quanto menor o tipo de dado, menos espaço ele ocupará;Processamento e busca: Quanto menor o tipo de dado, mais rápido é o processamento;Maus usos dos tipos de dados: Armazenar dados numéricos em colunas string; Armazenar dados numéricos em campos maiores que o necessário; Criar campos de string maiores do que o necessário;Bom usos dos tipos de dados: Escolher o menor tipo de dados possível para armazenar suas informações; Pergunta: Qual o menor e maior valor que o campo poderá receber?Criando um banco de dadosCREATE DATABASE NomeNomes sem espaços e sem caracteres especiaisOs conjuntos de caracteres mais utilizados são Latin1 e UTF-8 no BrasilALTER DATABASE Nome PropriedadeDROP DATABASE NomeExclusão é definitiva e irreversívelTabela-Campos-AtributosCriando uma tabelaCREATE TABLE Nome (Campos)Sintaxe de descrição de campo: Nome TipoDeDado AtributosMais de um campo, separam-se com vírgulasAtributos: Null, Zerofill, Unsigned, Auto-increment, ChaveALTER TABLE Nome PropriedadeDROP TABLE NomeExclusão é definitiva e irreversívelCriando um índiceÍndice: estrutura que armazena de forma isolada os registros de cada campo de forma ordenada.• CREATE INDEX Nome ON TabelaEColuna• ALTER INDEX Nome Propriedade• DROP INDEX NomeCriando uma sequênciaSequência: um campo de auto incremento.• CREATE SEQUENCE Nome• ALTER SEQUENCE Nome Propriedade• DROP SEQUENCE NomeExclusão é definitiva e irreversívelScript de criação de banco de dados.sqlcreate database curso_sql;use curso_sql;CREATE TABLE funcionarios ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, nome VARCHAR(45) NOT NULL, salario DOUBLE NOT NULL DEFAULT '0', departamento VARCHAR(45) NOT NULL, PRIMARY KEY (id));CREATE TABLE veiculos ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, funcionario_id INT UNSIGNED DEFAULT NULL, veiculo VARCHAR(45) NOT NULL DEFAULT '', placa VARCHAR(10) NOT NULL DEFAULT '', PRIMARY KEY (id), CONSTRAINT fk_veiculos_funcionarios FOREIGN KEY (funcionario_id) REFERENCES funcionarios (id));CREATE TABLE salarios ( faixa VARCHAR(45) NOT NULL, inicio DOUBLE NOT NULL, fim DOUBLE NOT NULL, PRIMARY KEY (faixa));alter table funcionarios change column nome nome_func varchar(50) not null;drop table salarios;create index departamentos on funcionarios (departamento);create index nomes on funcionarios (nome_func(6));4 Manipulando DadosGerenciando dadosINSERT INTO Tabela VALUES (Valores)SELECT Campos FROM TabelaUPDATE Tabela SET Campo = ValorDELETE FROM Tabela· Filtros de seleçãoWHERENão pode ser utilizado com o comando INSERTSe o WHERE não for definido, o DELETE será aplicado a toda a tabela• Operadores relacionais– Igual (=), Diferente (!=)– Maior (&gt;), Maior ou igual (&gt;=)– Menor (&lt;), Menor ou igual (&lt;=)– Nulo (IS NULL), ou não-nulo (IS NOT NULL)– Entre intervalo (BETWEEN)– Valor parcial (LIKE)• Operadores lógicos– AND– OR– NOTset sql_safe_updates = 0; // desativa o safe updates, que impede alterações na tabela toda// valor 1 reativa.Consultando dados com filtrosSELECT Campos FROM Tabela WHERE CondiçãoUPDATE Tabela SET Campo = Valor ROUND(valor/operação, número de casas) WHERE CondiçãoDELETE FROM Tabela WHERE CondiçãoAtributos especiais• Apelido de tabelaSELECT Campos FROM Tabela Apelido …• Apelido de campos (AS)SELECT Campo AS Apelido FROM …• Unindo seleções (UNION [ALL])SELECT … UNION SELECT …Manipulando dados.sqluse curso_sql;insert into funcionarios (id, nome_func, salario, departamento) values (1, 'Fernando', 1400, 'TI');insert into funcionarios (nome_func, salario, departamento) values ('José', 1800, 'Marketing');insert into funcionarios (nome_func, salario, departamento) values ('Isabela', 2200, 'Jurídico');select * from funcionarios;select * from funcionarios where salario &gt; 2000;update funcionarios set salario = salario * 1.1 where id = 1;set sql_safe_updates = 0;update funcionarios set salario = round(salario * 1.1, 2);set sql_safe_updates = 1;delete from funcionarios where id = 4;select nome_func, salario from funcionarios f where f.salario &gt; 2000;select nome_func as 'nome do funcionario', salario from funcionarios f where f.salario &gt; 2000;select nome_func, salario from funcionarios f where f.salario &gt; 2000 unionselect nome_func as 'nome do funcionario', salario from funcionarios f where f.salario &gt; 2000;5 Relacionamentos e VisõesRelacionamentos no SQL• Informações relacionadas entre si• Em geral entre diferentes tabelas• Geralmente possuem campos em comum• Parâmetro JOIN e suas variações• SELECT … FROM T1 JOIN T2 ON T1.FK = T2.PK• SELECT … FROM T1 JOIN T2 USING Chave (Equi join)• Compatibilidade com bancos de dadosInner join• Join padrão• Produto cartesiano entre as tabelas• Combina todas as linhas da primeira tabela com todas as linhas da segunda, que satisfaçam as condições das chavesEqui join• Similar ao Inner join• Chaves de mesmo nome entre as tabelas - Não irão se repetir na tabela de resultadosNon equi join• Relacionamento sem um campo em comum• SELECT P.NOME, P.SALARIO, S.FAIXA FROM PESSOAS P INNER JOIN SALARIOS S ON P.SALARIO BETWEEN S.INICIO AND S.FIMOuter join, Left join, Left outer join• Linhas que não satisfazem a condição de união• Left: Linhas da primeira tabela cujo campo de condição não satisfaçam a união de tabelas• SELECT * FROM PESSOAS LEFT JOIN VEICULOS ON PESSOAS.CPF = VEICULOS.CPFRight join, Right outer join• Similar ao Left join• Right: Linhas da segunda tabela cujo campo de condição não satisfaçam a união de tabelas• SELECT * FROM PESSOAS RIGHT JOIN VEICULOS ON PESSOAS.CPF = VEICULOS.CPFFull outer join• Combinação de Left join e Right join• Linhas da primeira e segunda tabela cujos campos de condição não satisfaçam a união de tabelas• SELECT * FROM PESSOAS FULL JOIN VEICULOS ON PESSOAS.CPF =VEICULOS.CPFNo MySQL utiliza o UNION com LEFT e RIGHTSelf join• União da tabela com ela mesma• SELECT A.NOME, B.NOME AS INDICADO_POR FROM PESSOAS A JOIN PESSOAS B ON A.INDICADO = B.CPFVisõesSão comandos SELECT pré-programados para ficarem disponíveis no banco de dados.É possível construir visões de relacionamento entre tabelas (JOINS).Não armazenam dados.• Relação que não faz parte do modelo lógico• Acessível ao usuário como uma relação virtual• Otimização de espaço em disco• Centralização de código• Facilidade de manutenção de expressões SQLCriando uma visão• CREATE VIEW Nome AS ExpressãoSQL• ALTER VIEW Nome Propriedade Exclusão e nova criação (substituição)• DROP VIEW Nome // Apenas a estrutura da visão é removido. Os dados permanecem intactos em suas respectivas tabelasRelacionamentos e visões.sqlUSE curso_sql;SELECT * FROM funcionarios;SELECT * FROM veiculos;SELECT * FROM funcionarios INNER JOIN veiculos ON veiculos.funcionario_id = funcionarios.id;SELECT * FROM funcionarios f INNER JOIN veiculos v ON v.funcionario_id = f.id;SELECT * FROM funcionarios f LEFT JOIN veiculos v ON v.funcionario_id = f.id;SELECT * FROM funcionarios f RIGHT JOIN veiculos v ON v.funcionario_id = f.id;SELECT * FROM funcionarios f LEFT JOIN veiculos v ON v.funcionario_id = f.idUNIONSELECT * FROM funcionarios f RIGHT JOIN veiculos v ON v.funcionario_id = f.id;INSERT INTO veiculos (funcionario_id, veiculo, placa) VALUES (null, \"Moto\", \"SB-0003\");CREATE TABLE cpfs( id int unsigned not null, cpf varchar(14) not null, PRIMARY KEY (id), CONSTRAINT fk_cpf FOREIGN KEY (id) REFERENCES funcionarios (id));INSERT INTO cpfs (id, cpf) VALUES (1, '111.111.111-11');INSERT INTO cpfs (id, cpf) VALUES (2, '222.222.222-22');INSERT INTO cpfs (id, cpf) VALUES (3, '333.333.333-33');INSERT INTO cpfs (id, cpf) VALUES (5, '555.555.555-55');SELECT * FROM cpfs;SELECT * FROM funcionarios INNER JOIN cpfs ON funcionarios.id = cpfs.id;SELECT * FROM funcionarios INNER JOIN cpfs USING(id);CREATE TABLE clientes( id int unsigned not null auto_increment, nome varchar(45) not null, quem_indicou int unsigned, PRIMARY KEY (id), CONSTRAINT fk_quem_indicou FOREIGN KEY (quem_indicou) REFERENCES clientes (id));INSERT INTO clientes (id, nome, quem_indicou) VALUES (1, 'André', NULL);INSERT INTO clientes (id, nome, quem_indicou) VALUES (2, 'Samuel', 1);INSERT INTO clientes (id, nome, quem_indicou) VALUES (3, 'Carlos', 2);INSERT INTO clientes (id, nome, quem_indicou) VALUES (4, 'Rafael', 1);SELECT * FROM clientes;SELECT a.nome AS CLIENTE, b.nome AS \"QUEM INDICOU\" FROM clientes a join clientes b ON a.quem_indicou = b.id;SELECT * FROM funcionarios INNER JOIN veiculos ON veiculos.funcionario_id = funcionarios.id INNER JOIN cpfs ON cpfs.id = funcionarios.id;CREATE VIEW funcionarios_a AS SELECT * FROM funcionarios WHERE salario &gt;= 1700;SELECT * FROM funcionarios_a;UPDATE funcionarios SET salario = 1500 WHERE id = 3;DROP VIEW funcionarios_a;CREATE VIEW funcionarios_a AS SELECT * FROM funcionarios WHERE salario &gt;= 2000;6 Funções Especiais e SubqueriesFunções de agregação– COUNT: Contagem de registros de uma consulta SELECT COUNT() FROM– SUM: Soma de valores SELECT SUM() FROM– AVG: Média de valores SELECT AVG() FROM– MAX: Valor máximo retornado pela consulta SELECT MAX() FROM– MIN: Valor mínimo retornado pela consulta SELECT MIN() FROMÉ possível integrar com WHERE com uma condiçãoFunções de paginação– DISTINCT: Seleciona os valores únicos, sem repetição– ORDER BY: Ordena o resultado baseado nas colunas informadas – DESC / ASC– LIMIT: Limita o número de resultados retornados– OFFSET: Indica quantos registros devem ser avançados• Combinações são permitidasFunções de agrupamento– GROUP BY: Agrupamento de registros por categoria– HAVING: Seleção de agrupamentoSubqueries• Realização de consultas com filtro de seleção baseado em uma lista ou outra seleção• IN / NOT INSELECT NOME FROM FUNCIONARIOS WHERE DEPARTAMENTO IN (‘Marketing’, ‘TI’)Funções Especiais e Subqueries.sqlUSE curso_sql;SELECT * FROM funcionarios;SELECT COUNT(*) FROM funcionarios;SELECT COUNT(*) FROM funcionarios WHERE salario &gt; 1600;SELECT COUNT(*) FROM funcionarios WHERE salario &gt; 1600 AND departamento = 'Jurídico';SELECT * FROM funcionarios WHERE salario &gt; 1600 AND departamento = 'Jurídico';SELECT SUM(salario) FROM funcionarios;SELECT SUM(salario) FROM funcionarios WHERE departamento = 'TI';SELECT AVG(salario) FROM funcionarios;SELECT AVG(salario) FROM funcionarios WHERE departamento = 'TI';SELECT MAX(salario) FROM funcionarios;SELECT MAX(salario) FROM funcionarios WHERE departamento = 'TI';SELECT MIN(salario) FROM funcionarios;SELECT MIN(salario) FROM funcionarios WHERE departamento = 'TI';SELECT departamento FROM funcionarios;SELECT DISTINCT(departamento) FROM funcionarios;SELECT * FROM funcionarios;SELECT * FROM funcionarios ORDER BY nome;SELECT * FROM funcionarios ORDER BY nome DESC;SELECT * FROM funcionarios ORDER BY salario;SELECT * FROM funcionarios ORDER BY departamento;SELECT * FROM funcionarios ORDER BY departamento DESC, salario DESC;SELECT * FROM funcionarios;SELECT * FROM funcionarios LIMIT 2 OFFSET 1;SELECT * FROM funcionarios LIMIT 1, 2;SELECT AVG(salario) FROM funcionarios;SELECT AVG(salario) FROM funcionarios WHERE departamento = 'TI';SELECT AVG(salario) FROM funcionarios WHERE departamento = 'Jurídico';SELECT departamento, AVG(salario) FROM funcionarios GROUP BY departamento;SELECT departamento, AVG(salario) FROM funcionarios GROUP BY departamento HAVING AVG(salario) &gt; 2000;SELECT departamento, COUNT(*) FROM funcionarios GROUP BY departamento;SELECT departamento, AVG(salario) FROM funcionarios GROUP BY departamento;SELECT nome FROM funcionarios WHERE departamento = 'Jurídico';SELECT nome FROM funcionarios WHERE departamento IN ( SELECT departamento FROM funcionarios GROUP BY departamento HAVING AVG(salario) &gt; 2000 );SELECT departamento, AVG(salario) FROM funcionarios GROUP BY departamento HAVING AVG(salario) &gt; 2000;7 Controle de AcessoDCL - Controle de acesso• Forma de garantir que somente pessoas autorizadas possam realizar ações com os dados• Níveis de acesso– Banco de dados– Tabelas– Colunas– Registros• Níveis de ações– Gerenciar estruturas– Gerenciar dados– Ler dados• Linguagem de Controle de Dados– CREATE USER ‘Nome’@’local/ip/localhost/% qualquer endereço’ IDENTIFIED BY ‘senha’: Cria um usuário– DROP USER Nome: Exclui um usuário– GRANT: Habilita acessos– REVOKE: Revoga acessos• Habilitando acessoGRANT Ação ON Estrutura TO ‘Usuário’• Revogando acessoREVOKE Ação ON Estrutura FROM Usuário• AçõesALL, SELECT, INSERT, UPDATE, DELETE• EstruturasTABLE, VIEW, SEQUENCEControle de Acesso.sql/* CREATE USER 'andre'@'200.200.190.190' IDENTIFIED BY 'milani123456'; *//* CREATE USER 'andre'@'%' IDENTIFIED BY 'milani123456'; */CREATE USER 'andre'@'localhost' IDENTIFIED BY 'milani123456';GRANT ALL ON curso_sql.* TO 'andre'@'localhost';CREATE USER 'andre'@'%' IDENTIFIED BY 'andreviagem';GRANT SELECT ON curso_sql.* TO 'andre'@'%';/* GRANT INSERT ON curso_sql.* TO 'andre'@'%'; */GRANT INSERT ON curso_sql.funcionarios TO 'andre'@'%';REVOKE INSERT ON curso_sql.funcionarios FROM 'andre'@'%';REVOKE SELECT ON curso_sql.* FROM 'andre'@'%';GRANT SELECT ON curso_sql.funcionarios TO 'andre'@'%';GRANT SELECT ON curso_sql.veiculos TO 'andre'@'%';REVOKE SELECT ON curso_sql.funcionarios FROM 'andre'@'%';REVOKE SELECT ON curso_sql.veiculos FROM 'andre'@'%';REVOKE ALL ON curso_sql.* FROM 'andre'@'localhost';DROP USER 'andre'@'%';DROP USER 'andre'@'localhost';SELECT User FROM mysql.user;SHOW GRANTS FOR 'andre'@'%';8 Transações (ACID)Transações (ACID)• Conjunto de operações• ACID– Atomicidade: ou transação é realizada por completo ou nada é realizado;– Consistência: regras não podem ser quebradas;– Isolamento: os dados são travados até o fim da transação;– Durabilidade: após o sucesso da transação os dados, as operações ficam novamente disponíveis.Data Transaction Language (DTL)• Linguagem de Transação de Dados– START TRANSACTION: Inicia a transação– COMMIT: Concretiza a transação– ROLLBACK: Anula a transaçãoTransações.sqlUSE curso_sql;SHOW ENGINES;CREATE TABLE contas_bancarias( id int unsigned not null auto_increment, titular varchar(45) not null, saldo double not null, PRIMARY KEY (id)) engine = InnoDB;INSERT INTO contas_bancarias (titular, saldo) VALUES ('André', 1000);INSERT INTO contas_bancarias (titular, saldo) VALUES ('Carlos', 2000);SELECT * FROM contas_bancarias;start transaction;UPDATE contas_bancarias SET saldo = saldo - 100 WHERE id = 1;UPDATE contas_bancarias SET saldo = saldo + 100 WHERE id = 2;rollback;start transaction;UPDATE contas_bancarias SET saldo = saldo - 100 WHERE id = 1;UPDATE contas_bancarias SET saldo = saldo + 100 WHERE id = 2;commit;9 Stored Procedures e TriggersStored Procedures• Blocos de código SQL armazenados no banco• Vantagens– Centralização– Segurança– Performance / velocidade– Suporte a transações• Criando uma Stored Procedure:CREATE PROCEDURE Nome• Invocando uma Stored Procedure:CALL NomeEXECUTE Nome• Excluindo uma Stored Procedure:DROP PROCEDURE NomeTriggers (Gatilhos)• Eventos que disparam códigos SQL• Vantagens– As mesmas das Stored Procedures– Execução de código SQL baseado em eventos• Tipos– BEFORE INSERT– BEFORE UPDATE– BEFORE DELETE– AFTER INSERT– AFTER UPDATE– AFTER DELETE– TEMPORAIS• Criando um Trigger:CREATE TRIGGER Nome Tipo ON tabela• Excluindo uma Trigger:DROP TRIGGER NomeStored Procedures e Triggers.sqlUSE curso_sql;CREATE TABLE pedidos( id int unsigned not null auto_increment, descricao varchar(100) not null, valor double not null default '0', pago varchar(3) not null default 'Não', PRIMARY KEY (id));INSERT INTO pedidos (descricao, valor) VALUES ('TV', 3000);INSERT INTO pedidos (descricao, valor) VALUES ('Geladeira', 1400);INSERT INTO pedidos (descricao, valor) VALUES ('DVD Player', 300);/* Criar Stored Procedures pelo menu lateral, com este SQL:SET SQL_SAFE_UPDATES = 0;DELETE FROM pedidos WHERE pago = 'Não';*/SELECT * FROM pedidos;CALL limpa_pedidos();CREATE TABLE estoque( id int unsigned not null auto_increment, descricao varchar(50) not null, quantidade int not null, PRIMARY KEY (id));CREATE TRIGGER gatilho_limpa_pedidosBEFORE INSERTON estoqueFOR EACH ROWCALL limpa_pedidos();SELECT * FROM pedidos;INSERT INTO pedidos (descricao, valor) VALUES ('TV', 3000);INSERT INTO pedidos (descricao, valor) VALUES ('Geladeira', 1400);INSERT INTO pedidos (descricao, valor) VALUES ('DVD Player', 300);SELECT * FROM pedidos;UPDATE pedidos SET pago = 'Sim' WHERE id = 8;SELECT * FROM pedidos;INSERT INTO estoque (descricao, quantidade) VALUES ('Fogão', 5);SELECT * FROM pedidos;SELECT * FROM estoque;INSERT INTO estoque (descricao, quantidade) VALUES ('Forno', 3);SELECT * FROM pedidos;SELECT * FROM estoque;" }, { "title": "Anotações sobre Banco de Dados", "url": "/posts/banco-dados/", "categories": "Estudos-faculdade", "tags": "banco-de-dados", "date": "2020-08-07 08:00:00 -0300", "snippet": "1 Conceitos Base de Banco de DadosMedeiros (2013, p. 15) define “banco de dados (ou, abreviadamente, BD) como sendo um conjunto de dados com certa organização característica, com o objetivo de armazenamento persistente dos dados e dotado de mecanismos de manipulação para obtenção de informações e recuperação posterior, dentro de um sistema de informação”.SGBD - Sistema Gerenciador de Banco de DadosClassificação dos Bancos de Dados Modelo hierárquico: a busca de um registro deve sempre iniciar pela raiz; Modelo relacional: dados organizados em tabelas, ou relações; Modelo orientado a objetos: o modelo de dados de objeto define um banco de dados em termos de objetos, suas propriedades e operações. Os objetos com a mesma estrutura e comportamento pertencem a uma classe, e as classes são organizadas em hierarquias (ou grafos acíclicos). As operações de cada classe são especificadas com procedimentos predefinidos, chamados métodos; Modelo em rede: semelhante ao hierárquico, mas permite um acesso mais direto aos dados. Dados à são fatos brutos, em sua forma primária. E muitas vezes os dados podem não fazer sentido sozinhos; Informações à consistem no agrupamento de dados de forma organizada para fazer sentido, gerar conhecimento. Sistema Gerenciador de Banco de Dados (SGBD)Nos SGBDs é definida a estrutura de armazenamento e o mecanismo de manipulação dos dados, garantindo a segurança das informações. Os SGBDs controlam os dados que são armazenados nos bancos de dados.Figura 10 – Níveis de abstração em um modelo de dadosgraph TD A[Esquema Externo 1] B[Esquema Externo 2] C[Esquema Externo 3] A &amp; B &amp; C &lt;--&gt; D[Esquema Conceitual] D &lt;--&gt; E[Esquema Físico] E &lt;--&gt; F[(Disco)]Esquema conceitual: Descreve a estrutura do banco de dados. Concentra-se na descrição de entidades, tipos de dados, relacionamentos, operações do usuário e restrições. Ex: Alunos(cod_aluno: string, nome: string, login: string, idade: integer)O processo de produzir um esquema conceitual é chamado de projeto conceitual de banco de dados.Esquema físico: são detalhados os componentes da estrutura física do banco de dados, como Tabelas, Colunas, Tipos e tamanho dos dados e Índices.Esquema externo: É a customização do acesso aos dados, no nível dos usuários individuais ou em grupos. Todos os bancos de dados têm apenas um esquema conceitual e um esquema físico, pois há apenas um conjunto de relações armazenadas, mas pode haver diversos esquemas externos, adaptados a grupos de usuários distintos.Aspectos de Modelagem de DadosAnálise de requisito - Modelo conceitual - Diagrama de entidade-relacionamento (DER)graph BT A[Cliente] B{Compra} C[Produtos] A --- D(código) A --- E(nome) A --- F(dt_nasc) A --- G(idade) A --- H(telefone) A &amp; C ---|N|B C --- I(código) C --- J(descrição) C --- K(preço)2 Modelagem de Banco de DadosModelo Entidade e RelacionamentoUma entidade é o objeto básico representado no modelo ER.Os atributos descrevem as características de uma entidade.O relacionamento estabelece uma relação ou associação entre as entidades, com um significado específico do mundo real. Cardinalidade Descrição 1:1 Um elemento de uma entidade se relaciona com um elemento de outra entidade 1:N ou N:1 Um elemento de uma entidade pode se relacionar com mais de um elemento de outra entidade N:N Vários elementos de uma entidade podem se relacionar com vários elementos de outra entidade e vice-versa 0:1 Um elemento de uma entidade pode se relacionar a nenhuma ou uma ocorrência de outra entidade 0:N Um elemento de uma entidade pode se relacionar a nenhuma ou muitas ocorrências de outra entidade Modelos: Lógico, Físico e RelacionalO modelo lógico de dados reflete as propriedades necessárias para a tradução do modelo conceitual, de maneira que seja possível a descrição dos elementos capazes de serem interpretados por um Sistema Gerenciador de Banco de Dados (SGBD), tais como o detalhamento dos atributos, chaves de acesso, integridade referencial e normalização.O modelo físico é a etapa final do projeto de banco de dados, estando relacionado diretamente com o profissional do SGBD, podendo variar conforme o SGBD que está sendo utilizado. Já com a definição do SGBD, o modelo físico é criado e cada atributo é devidamente especificado, conforme os tipos de dados do SGBD escolhido.O modelo ER é conveniente para representar um projeto de banco de dados inicial de alto nível. No modelo relacional, as entidades passam a ser tabelas e os atributos passam a ser colunas. Modelo ER Modelo relacional ENTIDADE TABELA ATRIBUTO SIMPLES COLUNA ATRIBUTO DERIVADO COLUNA ATRIBUTO IDENTIFICADOR CHAVE PRIMÁRIA (OU SECUNDÁRIA) ATRIBUTO MULTIVALORADO NOVA TABELA E CHAVE ESTRANGEIRA RELACIONAMENTO 1:1 OU 1:N CHAVE ESTRANGEIRA RELACIONAMENTO N:N NOVA TABELA COM 2 CHAVES ESTRANGEIRAS CONJUNTO DE VALORES TIPO DE DADOS As 12 Regras de CoddAo definir o modelo relacional, Codd estabeleceu 12 regras para determinação de um banco de dados relacional.Estas regras são usadas, portanto para se verificar a fidelidade de um banco de dados ao modelo relacional. Na prática são poucos os gerenciadores de banco de dados que atendem a todas as 12 regras. Na maior parte dos casos são atendidas no máximo 10 regras. Toda informação num banco de dados relacional é apresentada a nível lógico na forma de tabelas; Todo dado em um banco de dados relacional tem a garantia de ser logicamente acessível, recorrendo-se a uma combinação do nome da tabela, um valor de chave e o nome da coluna; Tratamento sistemático de valores nulos; (ausência de informação) O dicionário de dados, catálogo, do banco de dados é baseado no modelo relacional; Há uma linguagem não procedural para a definição, manipulação e controle dos dados; Tratamento das atualizações de visões dos dados; Tratamento de alto nível para inserção, atualização e eliminação de dados; Independência física dos dados; (mudança na memória e no método de acesso, criação de um novo índice, criação de uma nova coluna) Independência lógica dos dados; (mudança no tamanho de uma coluna) Restrição de Integridade; (Identidade, Referencial e Domínio) Independência de Distribuição dos dados; Não subversão das regras de integridade ou restrições quando se usa uma linguagem hospedeira (Siqueira, S.d.). 3 Linguagem SQL e Comandos DDLStructured Query LanguageEm 1982 foi lançada a primeira versão padronizada da linguagem SQL, que veio ganhando melhorias de acordo com sua evolução.Em 1986 foi criado um padrão ANSI e, em 1987, foi criado um padrão ISO.DDL à Data Definition LanguageFinalidadeDefinição e manutenção das estruturas do banco de dados, tais como a criação do próprio banco de dados e das tabelas que o compõem, além das relações entre as tabelas e os objetos do banco de dados. CREATECriação de estruturas de objetos do banco de dados.CREATE DATABASE nome_bancoCREATE TABLE nome_tabela nome_coluna tipoDeDados, nome_coluna tipoDeDadosApós o tipo pode adicionar NOT NULL, tornando o preenchimento daquela coluna obrigatório. O comando PRIMARY KEY(nome_coluna) ao final define qual coluna será a chave primária. Também é possível usar AUTO_INCREMENT. ALTERAlteração da estrutura de objetos do banco de dados.ALTER TABLE nome_tabela // RENAME novo_nome // MODIFY novo_nome novo_tipoALTER TABLE nome_tabela ADD COLUMN novo_nome novo_tipo DROPEliminação das estruturas de objetos do banco de dados.ALTER TABLE nome_tabela DROP COLUMN novo_nome novo_tipoDROP TABLE nome_tabelaDROP DATABASE nome_banco TRUNCATEExclusão física de linhas de tabelas. RENAMERenomeação de objetos do banco de dados. COMMENTInclusão de comentários aos objetos do banco de dados. SHOWExibe os objetos criados.SHOW DATABASES USEMarca um banco de dados para que todas as alterações subsequentes sejam feitas apenas nele.USE nome_banco DESCRIBEExibe a estrutura da tabela, com nomes, tipos de dados e tamanhos.DESCRIBE nome_tabela A coluna que recebe a chave primária não pode ser NULL; Cada tabela tem apenas uma chave primária; Tipos de dados mais utilizados para as chaves são INT e VARCHAR; O valor da chave primária é atribuído no momento que o registro é criado. 4 Comandos DMLDML à Data Manipulation LanguageFinalidadeConsultas, inserções, exclusões e alterações em um ou mais registros, de uma ou mais tabelas, de maneira simultânea. INSERTInserção de dados.INSERT INTO nome_tabela (coluna1, coluna2) values (valor1, valor2); UPDATEAlteração de dados.UPDATE tabela SET coluna='' WHERE condição; DELETEExclusão de dados.DELETE FROM tabela;DELETE FROM tabela WHERE condição; SELECTConsulta de dados.SELECT * FROM nome_tabela;SELECT coluna1, coluna2 FROM nome_tabela;SELECT coluna1, coluna2 FROM nome_tabela WHERE condição;SELECT coluna1, coluna2 FROM nome_tabela WHERE coluna BETWEEN valor1 AND valor2 ;SELECT coluna1, coluna2 FROM nome_tabela WHERE coluna LIKE '%a'; (% caractere coringa) 'a%'SELECT coluna1, coluna2 FROM nome_tabela WHERE coluna LIKE '___'; (número de caracteres)SELECT coluna1, coluna2 FROM nome_tabela WHERE coluna NOT LIKE '_a%';SELECT * FROM nome_tabela ORDER BY coluna ASC; (ascendente)SELECT * FROM nome_tabela ORDER BY coluna DESC; (descendente) // *todas as colunasSELECT tabela1.coluna1, tabela2.coluna2 FROM tabela1 JOIN tabela2 ON tabela1.coluna3=tabela2.coluna1; // JOIN pode incluir RIGHT JOIN, LEFT JOIN, LEFTOUTER JOINSELECT tabela1.coluna1 AS 'apelido' //apelidar colunas, alias MERGECombinação das instruções INSERT, UPDATE e DELETE. A ordem de escrita das colunas no comando INSERT não precisa ser na ordem que eles aparecem na estrutura da tabela; Os dados que vão ser inseridos que forem do tipo texto são obrigados a usar aspas simples; Não é preciso informar todas as colunas da tabela no comando INSERT (somente os definidos como NOT NULL). Outra prática para a execução do comando INSERT é omitir o nome das colunas.Com a omissão das colunas no comando INSERT, deve-se prestar atenção a dois pontos importantes: A ordem dos dados é exatamente a ordem em que as colunas estão definidas na tabela; Todas as colunas da tabela devem estar informadas, ainda que o valor seja nulo. O comando INSERT também permite que sejam inseridos vários registros, ao mesmo tempo (aproveitando o mesmo comando INSERT), em uma mesma tabela.Operadores condicionais &gt; maior &gt;= Maior ou igual &lt; menor &lt;= Menor ou igual = igual &lt;&gt; diferente A cláusula WHERE pode conter mais de uma condição, e para isso utilizam-se os conectores lógicos (AND e/ou OR).O UPDATE pode atualizar uma ou várias colunas no mesmo comando, desde que as colunas sejam separadas por vírgulas.Também é possível executar um comando UPDATE sem colocar a condição WHERE. O DELETE não pode ser utilizado para apagar um dado em uma coluna específica. É utilizado para apagar um ou mais registros, dependendo da cláusula WHERE. Pode ser utilizado para apagar todos os dados da tabela, bastando para isso não informar condição. Algumas outras funções podem ser utilizadas com a instrução SELECT permitindo enxergar os dados de maneiras mais específicas, ajudando na tomada de decisão:AVG(coluna) médiaSUM(coluna) somaMAX(coluna) máximoMIN(coluna) mínimoGROUP BY valorSELECT COUNT(*) as ‘apelido’ FROM colunaLIMIT 3 à retorna os 3 primeiros registros (número máximo);LIMIT 10, 3 à retorna 3 registros após o 10º registro (11, 12 e 13 registros).5 Comandos DCL e TCL - Join de TabelasDCL à Data Control LanguageFinalidadeControle de privilégios de usuários, de forma que o administrador do banco de dados possa determinar o nível de acesso de um usuário aos objetos do banco de dados, concedendo privilégios ou retirando esse acesso e revogando os privilégios. CREATE USERCriar usuário.CREATE USER 'novo_usuario' IDENTIFIED BY 'senha'; GRANTAtribuição de privilégios aos usuários do banco de dados.GRANT *direitos ON *destino TO usuário// *direitos: ALL PRIVILEGES, SELECT, INSERT, UPDATE, DELETE, CREATE, DROP.// *destinos: nomeDaTabela, *.* global, db.* qualquer tabela, db.tb apenas a tabela tb do banco db REVOKERevogação de privilégios aos usuários do banco de dados.REVOKE *direitos ON *destino FROM usuário DROP USERRemove usuário.DROP USER 'novo_usuario'TCL à Transact Control LanguageUma transação primeiramente é realizada primeira em memória e só são transmitidas fisicamente para o banco de dados após a confirmação de que todas as instruções foram efetuadas com sucesso.FinalidadeControle de transações, consideradas o conjunto de uma ou mais operações DML realizadas no banco de dados. BEGINIndica o início de uma transação e todos os comandos da transação devem vir abaixo de Begin; COMMITConfirmação das manipulações.BEGIN TRANSACTION; \tUPDATE CONTA CORRENTE set saldoConta= saldoConta - @VaIor where numConta = @contaDe; \tUPDATE CONTA CORRENTE set saldoConta= saldoConta + @Valor where numConta = @contaPara; COMMIT; ROLLBACKDesistência das manipulações.BEGIN TRANSACTION 'transferencia';\tINSERT INTO uf VALUES('pr'),('sc');ROLLBACK TRANSACTION 'transferencia'; SAVEPOINTCriação de pontos para o controle das transações.ÍndicesOs índices são criados para facilitar e agilizar as consultas dos registros no banco de dados. Exame nas tabelas à a consulta percorre todos os registros de todas as páginas e seleciona apenas os que são verdadeiros segundo a cláusula WHERE; Usando índices à percorre a estrutura da árvore do índice, comparando e extraindo somente os registros que são verdadeiros segundo a cláusula WHERE. Como foi visto, os índices são utilizados para melhorar as consultas nos registros, mas é preciso levar em conta que a criação da árvore de índice consome um grande espaço em disco, podendo se tornar um problema se o banco está armazenado em um storage. Não utilizar colunas que tenham uma grande quantidade de dados duplicados ou que tenham pouca variação, como a coluna sexo. O SGBD gasta recursos mantendo os índices sempre atualizados e associados. CREATE INDEX ‘nome do indice’ ON tabela(coluna, coluna);Para um melhor desempenho da criação dos índices, é sugerido criá-los nas seguintes colunas: Chaves primárias; Chaves estrangeiras; Colunas acessadas por intervalos (BETWEEN); Campos utilizados em GROUP BY ou ORDER BY. 6 Procedimentos ArmazenadosStored ProceduresMuitas aplicações que acessam um banco de dados executam rotinas de manipulação de dados a partir da linguagem ou ferramenta utilizada para criar as aplicações. Essas rotinas podem utilizar várias instruções SQLs em sequência. Se essa rotina executada possuir muitas consultas e atualizações no banco de dados, ela vai gerar um consumo maior dos recursos da aplicação. Caso a aplicação for web, o problema se torna um pouco maior, pois vai gerar maior tráfego de informações na rede e maiores requisições para o servidor.Para tentar amenizar o consumo de recursos pela aplicação, é transferida parte do processamento (programação) para o banco de dados. Essas sub-rotinas que são programadas no banco de dados recebem o nome de stored procedure.Pontos positivos: Simplificação da execução de instruções SQL pela aplicação; Transferência de parte da responsabilidade de processamento para o servidor. Facilidade na manutenção, reduzindo a quantidade de alterações na aplicação. Pontos negativos: Necessidade de maior conhecimento da sintaxe do banco de dados para escrita de rotinas em SQL; As rotinas ficam mais facilmente acessíveis. Alguém que tenha acesso ao banco poderá visualizar e alterar o código. Um comando que pode ser utilizado em stored procedures, functions e triggers é o DELIMITER. Ele é utilizado para trocar o caractere de finalização. O mysql tem como delimitador o ; (ponto e vírgula), ou seja, o mysql entende que ali o comando está encerrado e não há necessidade de continuidade.CREATE PROCEDURE nome_procedure (parametros)\tdeclaracoes;CALL nome_procedure (parametros);DROP PROCEDURE nome_procedure;Os parâmetros são classificados em três modos diferentes: IN, OUT ou INOUT. IN à é utilizado apenas para recebimento (entrada) de dados e não é utilizado para dar retorno; OUT à é um parâmetro de saída, não sendo informado um valor fixo (direto), apenas uma variável para o retorno; INOUT à esse modo de parâmetro pode ser utilizado como entrada ou saída, não podendo ser informado um valor fixo. Os procedimentos armazenados não precisam ser escritos em SQL; eles podem ser escritos em qualquer linguagem hospedeira.FunctionsAs funções são muito semelhantes aos procedimentos, o que os difere, do ponto de vista estrutural, é a inclusão da cláusula RETURN. Nas funções, existe a obrigatoriedade de um retorno à rotina chamadora, que é feito por meio da cláusula RETURN.CREATE FUNCTION nome_funcao (parametros)RETURNS tipo_dadoscodigo_da_funcaoRETURN retornoSELECT nome_funcao (parametros)DROP FUNCTION nome_funcao;TriggersAlgumas ações podem ser disparadas (executadas) em consequência ou resposta de uma ação. Esses disparos podem ser programados na aplicação ou diretamente no banco de dados. A utilização direta no banco de dados chama-se triggers.Podem-se definir vários triggers em um banco de dados, mas cada comando pode disparar apenas um trigger.Pontos positivos: Parte do processamento que seria executado na aplicação passa para o banco, poupando recursos da máquina cliente; Facilita a manutenção, sem que seja necessário alterar o código fonte da aplicação. Pontos negativos: Alguém que tenha acesso não autorizado ao banco de dados poderá visualizar e alterar o processamento realizado pelos gatilhos; Requer maior conhecimento de manipulação do banco de dados (SQL) para realizar as operações internamente. CREATE TRIGGER nome AFTER/BEFORE INSERT/UPDATE/DELETE \tON tabela \tFOR EACH ROW \tBEGIN \tInstruções SQL \tENDDROP TRIGGER nome; Não se pode chamar diretamente um TRIGGER com CALL, como se faz com um stored procedures; Não é permitido iniciar ou finalizar transações em meio à TRIGGERS; Não se pode criar um TRIGGERS para uma tabela temporária – TEMPORARY TABLE; TRIGGERS ainda não podem ser implementadas com a intenção de devolver para o usuário ou para uma aplicação mensagens de erros. Registros NEW e OLDAs palavras NEW e OLD são utilizadas para acessar os registros antes ou depois da execução. Como exemplo pode-se acessar os registros que serão enviados para uma tabela antes (BEFORE) ou depois (AFTER) de um UPDATE. INSERT: o operador NEW.nome_coluna, nos permite verificar o valor enviado para ser inserido em uma coluna de uma tabela. OLD.nome_coluna não está disponível. DELETE: o operador OLD.nome_coluna nos permite verificar o valor excluído ou a ser excluído. NEW.nome_coluna não está disponível. UPDATE: tanto OLD.nome_coluna quanto NEW.nome_coluna estão disponíveis, antes (BEFORE) ou depois (AFTER) da atualização de uma linha. Estruturas de programaçãoÉ possível que as stored procedures tenham incorporado dentro dos seus procedimentos algumas estruturas de programação como condicionais, laços de repetição, funções etc.IF &lt;condicao&gt; THEN comandos sql caso verdadeiro ELSE comandos sql caso falso END IFWHILE &lt;condicao&gt; DO comandos sql caso verdadeiro END WHILE" }, { "title": "Anotações sobre Ajax", "url": "/posts/ajax/", "categories": "Estudos-faculdade", "tags": "ajax, web", "date": "2020-07-31 08:00:00 -0300", "snippet": "Instalar servidor Wamp para testes com AJAXAsynchronous Javascript And XmlUma metodologia de programação que possibilita a comunicação assíncrona entre front-end e back-end de aplicações Web.Obter informação do servidor sem precisar recarregar a página toda.Objeto AJAXXMLHttpRequest Objeto que disponibiliza o acesso assíncrono ActiveXObject(‘Microsoft.XMLHTTP’) Mesmo objeto em navegadores antigos / MS Métodos open: configura a transação send: dispara a transação/inicia execuçãoEstados do processo* Propriedades * onreadystatechange //método* Função de tratamento de retorno * readyState* 0 (unsent): objeto criado mas não configurado* 1 (opened): objeto configurado mas não enviado* 2 (headers_received): objeto enviado/aguardando resposta* 3 (loading): retorno sendo recebido* 4 (done): transação concluídaEstados da resposta* Propriedades * status* 200 (ok): sucesso* 400 (bad request): requisição inválida* 401 (unauthorized): falta de autorização* 403 (forbidden): acesso proibido* 408 (request timeout): tempo hábil esgotado* Basicamente o sucesso é: * readyState = 4 * status = 200Acessando o conteúdo* responseText * Acessa o conteúdo em formato texto* responseXML * Acessa o conteúdo em formato XMLExemplosTexto&lt;!DOCTYPE html&gt;&lt;html lang=\"pt-br\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AJAX (Conteúdo texto)&lt;/title&gt; &lt;script&gt; /* * AJAX só funciona com um servidor web. * Não funciona pelo protocolo file:// * Funciona apenas pelos protocolos http://, https:// */ var req; function ajaxStart() { var imagem = document.getElementById(\"imagemStatus\"); imagem.src = \"imageLoading.gif\"; var url = \"conteudoTexto.txt\"; if(window.XMLHttpRequest) { req = new XMLHttpRequest(); req.onreadystatechange = ajaxProcessarRecebimento; req.open(\"GET\", url); req.send(null); } else if(window.ActiveXObject) { req = new ActiveXObject(\"Microsoft.XMLHTTP\"); req.onreadystatechange = ajaxProcessarRecebimento; req.open(\"GET\", url); req.send(); } } function ajaxProcessarRecebimento() { if(req.readyState == 4) { if(req.status == 200) { var imagem = document.getElementById(\"imagemStatus\"); imagem.src = \"imageEmpty.gif\"; document.getElementById(\"meuDiv\").innerHTML = req.responseText; } else { alert(req.status + \": Possível erro.\"); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Exemplo de captura de texto via AJAX&lt;/h1&gt; &lt;input type=\"button\" onClick=\"ajaxStart();\" value=\"Obter informação de texto via AJAX\"&gt; &lt;br&gt;&lt;br&gt; &lt;div id=\"meuDiv\"&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;img src=\"imageEmpty.gif\" id=\"imagemStatus\"&gt; &lt;/body&gt;&lt;/html&gt;XML&lt;!DOCTYPE html&gt;&lt;html lang=\"pt-br\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AJAX (Conteúdo XML)&lt;/title&gt; &lt;script&gt; /* * AJAX só funciona com um servidor web. * Não funciona pelo protocolo file:// * Funciona apenas pelos protocolos http://, https:// */ var req; function ajaxStart() { var imagem = document.getElementById(\"imagemStatus\"); imagem.src = \"imageLoading.gif\"; var url = \"conteudoXml.xml\"; if(window.XMLHttpRequest) { req = new XMLHttpRequest(); req.onreadystatechange = ajaxProcessarRecebimento; req.open(\"GET\", url); req.send(null); } else if(window.ActiveXObject) { req = new ActiveXObject(\"Microsoft.XMLHTTP\"); req.onreadystatechange = ajaxProcessarRecebimento; req.open(\"GET\", url); req.send(); } } function ajaxProcessarRecebimento() { if(req.readyState == 4) { if(req.status == 200) { var imagem = document.getElementById(\"imagemStatus\"); imagem.src = \"imageEmpty.gif\"; var buffer = \"\"; buffer += \"&lt;table&gt;\"; buffer += \" &lt;tr&gt;\"; buffer += \" &lt;th&gt;Curso&lt;/th&gt;\"; buffer += \" &lt;th&gt;Código&lt;/th&gt;\"; buffer += \" &lt;th&gt;Instrutor&lt;/th&gt;\"; buffer += \" &lt;th&gt;Tipo&lt;/th&gt;\"; buffer += \" &lt;/tr&gt;\"; var xmlDoc = req.responseXML; var eSoftblue = xmlDoc.getElementsByTagName(\"SOFTBLUE\")[0]; var eCourses = eSoftblue.getElementsByTagName(\"COURSE\"); for(var i=0; i&lt;eCourses.length; i++) { buffer += \"&lt;tr&gt;\"; buffer += \"&lt;td&gt;\" + eCourses[i] .getElementsByTagName(\"TITLE\")[0] .firstChild .nodeValue + \"&lt;/td&gt;\"; buffer += \"&lt;td&gt;\" + eCourses[i] .getElementsByTagName(\"TITLE\")[0] .getAttribute(\"id\") + \"&lt;/td&gt;\"; buffer += \"&lt;td&gt;\" + eCourses[i] .getElementsByTagName(\"INSTRUCTOR\")[0] .firstChild .nodeValue + \"&lt;/td&gt;\"; buffer += \"&lt;td&gt;\" + eCourses[i] .getElementsByTagName(\"TYPE\")[0] .firstChild .nodeValue + \"&lt;/td&gt;\"; buffer += \"&lt;/tr&gt;\"; } buffer += \"&lt;/table&gt;\"; document.getElementById(\"meuDiv\").innerHTML = buffer; } else { alert(req.status + \": Possível erro.\"); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Exemplo de captura de XML via AJAX&lt;/h1&gt; &lt;input type=\"button\" onClick=\"ajaxStart();\" value=\"Obter informação de XML via AJAX\"&gt; &lt;br&gt;&lt;br&gt; &lt;div id=\"meuDiv\"&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;img src=\"imageEmpty.gif\" id=\"imagemStatus\"&gt; &lt;/body&gt;&lt;/html&gt;" }, { "title": "Anotações sobre C", "url": "/posts/c/", "categories": "Estudos-faculdade", "tags": "c", "date": "2020-07-24 08:00:00 -0300", "snippet": "Baseado no curso da SoftblueIntroduçãoO que é o C?– Linguagem de programação– Criada por Dennis Ritchie (meados de 1970)– Padronizada pelo ANSI em 1983 (portabilidade)– Atualmente a mais utilizada no mundo– Diferença do C para o C++(novos recursos - orientação a objetos) Linguagem de programação C– Nível médio– Estruturada– Compilada– PortávelPróxima do baixo nível Vantagens– Linguagem com comandos e tipos de dados simples– Acesso livre à memória– Velocidade Codificar– Arquivos com extensão .c– Não utilizar processadores de texto (Word) Compilar– Processo de transformar código-fonte emcódigo-objeto (de máquina) Linkeditar– Unificação de programas e bibliotecas diversas Distribuir Desvantagens – Não possui classes e objetos– Não possui um gerenciador de memória– Outros (multi-thread, web)Arquitetura da memória 4 regiões de memória– Código do programa (instruções compiladas)– Variáveis globais– Pilha (ordem das chamadas e retornos)– Heap (memória livre)Tipos de dados e operadoresTipos de dados Tipo Intervalo Bits (padrão ANSI) char / signed char -127 a 127 8 unsigned char 0 a 255 8 int / signed int / short int / signed short int -32.767 a 32.767 16 unsigned int 0 a 65.535 16 long int / signed long int -2.147.483.647 a 2.147.483.647 32 unsigned long int 0 a 4.294.967.295 32 float 6 casas decimais 32 double 10 casas decimais 64 long double 10 casas decimais 80 Modificador short/longapenas com int e doubleModificador signed/unsignedVariáveisEspaços de memória alocados para armazenar valores.Nomenclatura: não utilizar caracteres especiais, nem espaços em branco ou pontuações. Pode utilizar números, mas não no início. Case sensitive.Escopo local - criadas dentro do bloco de código e excluídas ao final do bloco. As variáveis devem sempre ser criadas no início do bloco (C++ é mais flexível).Variáveis globais - ocupam memória durante toda a execução. Declaradas no início do arquivo, fora de qualquer bloco de código.Operador de atribuição =Atribuição múltipla: x = y = z = 3Hexadecimais: int x = 0x145; // número 325 em decimalOctais: int y = 0505; // número 325 em decimalModificadores de armazenamentoextern - resolve o conflito de variáveis e constantes globais entre diferentes programas em C. Defina a variável no primeiro programa, sem extern, e nos demais com extern.static - variáveis que mantém seus valores entre diferentes chamadas de uma mesma função.register - armazena a variável no mecanismo de acesso mais rápido disponível (no registrador do processador, e não na memória, por exemplo).Constantesconst - valores constantes que não podem ser alterados durante a execução. Não podem ser inicializadas em separado.volatile - Constantes que podem sofrer alterações por vias externas ao seu programa.EnumeraçõesGrupos de valores que uma variável pode ter. Para limitar o valor de uma variável em um subconjunto conhecido de valores.Sintaxe: enum nome {valores,}Operadores Matemáticos Operador Operação   + soma   ++ soma 1 x++ utiliza o valor atual de x na expressão e depois incrementa-o, enquanto ++x primeiro incrementa x e depois utiliza o valor atualizado na expressão - subtração   – subtrai 1 X– utiliza o valor atual de x na expressão e depois decrementa-o, enquanto –x primeiro decrementa x e depois utiliza o valor atualizado na expressão * multiplicação   / divisão   % resto da divisão inteira   Podem ser associados ao sinal de atribuição (+=, por exemplo).Operações matemáticas entre diferentes tipos de dados podem ocasionar imprecisão. Conversão automática de tipos de dados. Promoção de tipo.Conversão implícita (cast):int x = 10;int y = 3;(double) x / y;Operadores bit a bitOperações de baixo nível. Representados pelos tipos int e char.Operadores bit a bit Operador Operação   &amp; AND (“e” lógico)       OR (“ou” lógico) ^ XOR (“ou” exclusivo)   ~ Complemento de um   » Deslocamento para a direita   « Deslocamento para a esquerda   Diretivas (#)Instruções pré-processadas pelo compilador.Tempo de compilação vs Uso de variáveis.Cada uso de uma diretiva deve ser realizado em uma linha própria.#define - permite atrelar um valor por meio de um identificador #define PI 3.14 . Pode ser utilizada para definir uma breve função.#undef - remove a definição de uma chave.#if - condição em tempo de compilação, inicia um bloco de código sem necessidade de chaves.#else - encerra o bloco anterior e inicia o negativo.#elif - encerra o bloco anterior e abre outro condicional.#endif - Encerra o bloco como um todo.#if PI &gt; 5//se verdadeiro#elif PI &lt; 5//se verdadeiro#else//se falso#endif //encerra o bloco if#ifdef - verifica se uma chave foi definida. Termina com #endif. Permite o use de #else.#ifndef - verifica se uma chave não foi definida. Termina com #endif. Permite o use de #else.#line - Gerencia o número da linha. Identificadores __line__ e __file__#error - interrompe a compilação.#include - orienta o compilador para ler outro arquivo. Comando de importação de bibliotecas.Operadores Relacionais== mesmo valor mesmo que tipos diferentes!= diferentes em valor&lt; menor que&gt; maior que&lt;= menor igual&gt;= maior igualOperadores Lógicos! negação&amp; e| ou&amp;&amp; e verificando a primeira condição e já resultando falso se for o caso|| ou verificando a primeira condição e já resultando verdadeiro se for o casoPrecedência: aritméticos&gt;relacionais&gt;!&gt;&amp;&amp;&gt;||Controle de fluxo e repetiçãoComandos de decisãoQualquer valor diferente de false e de 0 é considerado verdadeiro (true). Quando um comando if não apresenta suas chaves para definição de suas ações, apenas um comando é atrelado a ele.if(condição) {}else if(condição) {}else{}short ifcondição ? verdadeiro : falso;valor apenas intswitch(valor){ case 0: ... break; default:}Comandos de repetição - laços - iteraçõesfor(inicialização; condição; incremento) {}while(condição) {}do {} while(condição)Comandos de controlebreak interrompe repetiçãocontinue interrompe a execução atual da repetição mas permite a continuação do laçoreturn encerra a execução da função, pode retornar valores à chamada da funçãoexit encerra a aplicação retornando se o encerramento foi intencional (exit 0) ou por erro (exit 1). Disponibilizado pela biblioteca stdlib.hExemplo:#include \"stdio.h\"int main(){ char *c; int x = 5, y = 0; // Comandos IF, ELSE IF e ELSE x = 1; if(x &gt;= 5) { printf(\"x vale 5 ou mais n\"); } else if(x &gt;= 3) { printf(\"x vale 3 ou mais n\"); } else { printf(\"x nao vale mais que 3\"); } x = -50; y = x &gt;= 0 ? 1 : -1; printf(\"n y vale %d n\", y); // Comandos SWITCH, CASE, BREAK e DEFAULT x = 3; switch(x) { case 1: printf(\"n x vale 1 n\"); break; case 2: printf(\"n x vale 2 n\"); break; case 3: printf(\"n x vale 3 n\"); break; default: printf(\"n x nao foi identificado n\"); break; } // Comandos FOR, BREAK e CONTINUE printf(\"n\"); for(x=0; x&lt;10; x++) { if(x == 8) { break; } if(x == 3) { continue; } printf(\"%d \", x); } printf(\"n\"); x = 5; if(x == 10) { x = 15; x++; } printf(\"n %d n\", x); // Comando WHILE printf(\"n Comando While n\"); x = 0; while(x &lt; 10) { printf(\"%d \", x); x = x + 1; } printf(\"n\"); // Comando DO WHILE printf(\"n Comando Do While n\"); x = 0; do { printf(\"%d \", x); x = x + 1; } while(x &lt; 10); printf(\"n\"); x = 2; y = 11; if(y == 11 &amp;&amp; x++ == 5) { printf(\"n Sucesso n\"); } else { printf(\"n Falha n\"); } printf(\"X vale neste momento: %d n\", x); scanf(\"%c\", &amp;c); return 0;}Leitura e exibição de valores#stdio.hprintf(\"string de formatação\", variáveis);//caracteres especiais não são suportadosCaracteres de formatação Símbolo Descrição %c Caractere %d, %i Número inteiro (com sinal) %u Número inteiro (sem sinal) %e, %E Notação científica %f Ponto flutuante %lf Ponto flutuante longo %o Octal %s String %x, %X Hexadecimal %p Ponteiro %% Símbolo de percentual sprintf(variável destino, “caractere de formatação”, variável origem); idêntico ao printf, mas não exibe na tela, e sim aloca em uma variável de texto. Utilizada para converter números em texto.Formatando valores numéricos: %a.b símbolo do tipo de dado a: quantidade de que casas serão exibidas; b: quantidade máxima de caracteres ou de casas de ponto flutuante.Lendo informações:#stdio.hscanf(\"caractere de formatação de string\", &amp;endereços de memória-variável);//não suporta espaço em branco entre palavras//caracteres especiais não são suportadosGerando números randômicos:#stdlib.hrand();//retorna um flutuante randômico entre 0 e 1//baseado em uma sementesrand(semente);//define uma nova semente para a função rand//o tempo atual pode ser utilizando como semente#time.htime();//retorna a quantidade de segundos desde 00:00 de 01/01/1970Manipulando datas:#time.h//tipo de dado time_t instante (data e hora) quantidade de segundos desde 00:00 de 01/01/1970//estrutura struct tm organiza o time_ttime(); //retorna o time_t atuallocaltime(); //time com fuso localstrftime(); //formata data e horaCaracteres de formatação de data e hora com strftime Símbolo Descrição %a Dia da semana abreviado %A Dia da semana %b Mês abreviado %B Mês %c Data e hora completa %d Dia do mês (1-31) %H Hora (24) %l Hora (12) %j Dia do ano (1-366) %m Mês (1-12) %M Minuto (0-59) %p AM, PM %S Segundos (0-59) %U Número da semana (a partir de domingo) %w Dia da semana (0-6) (a partir de domingo) %W Número da semana (a partir de segunda) %x Data completa %X Horário completo %y Ano (yy) %Y Ano (yyyy) %Z Fuso horário Exemplos:#include \"stdio.h\"#include \"time.h\"int main(){ char *c; int varInt = 70; double varDouble = 150.15; float varFloat; char varChar; int y = 50, z = 100; char buffer[100]; // Manipulando datas time_t agora; struct tm *tm_agora; char texto[100]; // Caracteres de formatacao printf(\"n Valor de varInt (inteiro): %d\", varInt); printf(\"n Valor de varInt (hexadecimal): %x\", varInt); printf(\"n Valor de varInt (octal): %o\", varInt); printf(\"n Valor de varInt (flutuante): %f\", varInt); printf(\"n Valor de varInt (caractere): %c\", varInt); printf(\"n Valor de varDouble (flutuante): %f\", varDouble); printf(\"n A soma de %d com %d resulta em %d\", y, z, y+z); printf(\"n %5.5f\", 123.456789); printf(\"n %15.5f\", 123.456789); printf(\"n %15.2f\", 123.456789); printf(\"n %3.5d\", 123); printf(\"n %3.3d\", 123); printf(\"n %10.3d\", 123); printf(\"n %10.5d\", 123); printf(\"n %20.25s\", \"Minha string\"); printf(\"n %5.10s\", \"Minha string\"); // Capturando valores printf(\"n Insira um valor inteiro: \"); scanf(\"%d\", &amp;varInt); scanf(\"%c\", &amp;c); printf(\"n O valor digitado foi: %d\", varInt); printf(\"n Insira um valor float: \"); scanf(\"%f\", &amp;varFloat); scanf(\"%c\", &amp;c); printf(\"n O valor digitado foi: %f\", varFloat); printf(\"n Insira um valor double: \"); scanf(\"%lf\", &amp;varDouble); scanf(\"%c\", &amp;c); printf(\"n O valor digitado foi: %f\", varDouble); printf(\"n Insira um valor char: \"); scanf(\"%c\", &amp;varChar); scanf(\"%c\", &amp;c); printf(\"n O valor digitado foi: %c\", varChar); // Manipulando datas agora = time(NULL); tm_agora = localtime(&amp;agora); strftime(texto, sizeof(texto), \"%d/%m/%y\", tm_agora); printf(\"n A data de hoje e: %s\", texto); sprintf(buffer, \"A data de hoje e: %s\", texto); printf(\"n A variavel buffer contem: %s\", buffer); scanf(\"%c\", &amp;c); return 0;}#include \"stdio.h\"#include \"stdlib.h\"#include \"time.h\"int main(){ char *c; int numeroSecreto, tentativa; // Randomiza o numero a ser adivinhado srand(time(NULL)); numeroSecreto = rand() % 20 + 1; do { // Captura as tentativas do usuario printf(\"n Adivinhe o numero (entre 1 e 20): \"); scanf(\"%d\", &amp;tentativa); scanf(\"%c\", &amp;c); // Limpa o buffer // Avalia se o usuario digitou algo menor ou maior if(numeroSecreto &lt; tentativa) { printf(\"n O numero e menor.\"); } else if(numeroSecreto &gt; tentativa) { printf(\"n O numero e maior.\"); } } while(numeroSecreto != tentativa); printf(\"n Acertou, o numero era: %d\", numeroSecreto); printf(\"n Pressione &lt;ENTER&gt; para sair...\"); scanf(\"%c\", &amp;c); return 0;}PonteirosOperadores “E” comercial (&amp;) – Permite acessar o endereço de memória de seu operando Asterisco (*) – Permite acessar o valor armazenado em um endereço de memória fornecido Ponteiro - Apontadores de endereços de memória. Um endereço de memória z armazena/aponta para outro endereço de memória x. Printf(\"%d\", z); //imprime o endereço de memória que foi atribuídoPrintf(\"%d\", *z); //imprime o valor que está armazenado no endereço de memória ao qual aponta zPonteiros em funções: Facilitam a atualização de variáveis enviadas para funções externasPois em C a passagem de parâmetros ocorre por cópia, por padrão, e não por referência. scanf usa ponteiro para atualizar as variáveisA função scanf precisa receber o endereço de memória da variável que receberá o valor lido no formato inteiro (%d). Se ela receber um ponteiro como parâmetro, o código executa sem a necessidade de utilizar o &amp;.Apontamento múltiplo: Ponteiro que aponta para outro ponteiro*** quantidade de asteriscos determina a multiplicidade do apontamentoCaracterísticas de ponteiros Iniciam com valores sujos– Podem apontar para áreas inválidas Utilização de valor nulo na inicialização– int *p = NULL; Podem ser comparados em expressões condicionais– Comparações numéricas– Apontam para mesma área (==) Uma string (vetor de char) por si só já é um endereço de memóriaAritmética de ponteiros Operações de adição e subtração Ocorrem deslocando os endereços dos ponteiros para o próximo ou anterior de mesma base (tipo de dado) A criação de matrizes na memória garante que os espaços alocados sejam vizinhos, o que permite as operações com ponteiros de maneira satisfatória.Alocação dinâmica de memória Biblioteca stdlib.h Instrução malloc – void* malloc(bytes)Esse comando pode retornar um ponteiro nulo, então é importante criar um if para verificar se a alocação foi criada com sucesso antes de utilizar o ponteiro.#include stdlib.hchar *minhaStr;minhaStr = malloc(100);if (!minhaStr) { printf(\"Erro\");} Instrução free – free(void*)// é importante liberar a memória para evitar leaks e travamento do sistemaExemplo#include \"stdio.h\"#include \"stdlib.h\"void somaUmNormal(int i){ i = i + 1;}void somaUmPonteiro(int *i){ *i = *i + 1;}int main(){ char *c; int a, b; int *pi = NULL; int **ppi = NULL; int *matrizInteiro; int matrizSemPonteiro[5] = {2, 4, 6, 8, 10}; // Uso tradicional a = 5; b = a; printf(\"n a = %d, b = %d\", a, b); a = 5; b = a; a = 8; printf(\"n a = %d, b = %d\", a, b); a = b = 5; a = 8; printf(\"n a = %d, b = %d\", a, b); printf(\"n a = %d (%d), b = %d (%d)\", a, &amp;a, b, &amp;b); // Ponteiro a = 5; pi = &amp;a; a = 8; printf(\"n a = %d, pi = %d\", a, pi); printf(\"n a = %d, pi = %d\", a, *pi); // Ponteiro para ponteiro a = 5; pi = &amp;a; ppi = π printf(\"n a = %d, pi = %d, ppi = %d\", a, *pi, ppi); printf(\"n a = %d, pi = %d, ppi = %d\", a, *pi, *ppi); printf(\"n a = %d, pi = %d, ppi = %d\", a, *pi, **ppi); // Passagem por valor a = 5; somaUmNormal(a); printf(\"n Soma normal: a = %d\", a); // Passagem por referencia a = 5; somaUmPonteiro(&amp;a); printf(\"n Soma normal: a = %d\", a); // Alocacao dinamica de memoria matrizInteiro = (int *) malloc(5 * sizeof(int)); if(!matrizInteiro) { printf(\"Erro\"); } matrizInteiro[0] = 5; matrizInteiro[1] = 10; printf(\"n Posicao [0] = %d, posicao [1] = %d\", matrizInteiro[0], matrizInteiro[1]); // Liberacao de memoria alocada dinamicamente free(matrizInteiro); // Aritmetica de ponteiro pi = &amp;matrizSemPonteiro[0]; printf(\"n pi vale agora: %d\", *pi); pi++; printf(\"n pi vale agora: %d\", *pi); pi = pi + 2; printf(\"n pi vale agora: %d\", *pi); pi--; printf(\"n pi vale agora: %d\", *pi); scanf(\"%c\", &amp;c); return 0;}Matrizes Também conhecidos como arrays, vetores Conjunto de informações do mesmo tipo Variável com mais de uma posição (slot) Índice numérico sempre no zero Matrizes unidimensionais (uma dimensão) Sintaxe: tipo nome[tamanho]; Int numeros[7] = {33, 34, 35, 36, 37, 44}Tamanhos de matriz Instrução sizeof() //nome da variável ou tipo de dado– Obtém o tamanho em bytes– Sabendo o tamanho total, e o tamanho do tipo de dado, pode-se calcular sua quantidade de posiçõesMatrizes multidimensionais Matrizes com mais de uma dimensão Matrizes dentro de matrizes (unidimensionais) Todas as dimensões do mesmo tipo Dimensões de tamanhos diferentes Sintaxe: – tipo nome[tamanho][tamanho]; – tipo nome[tamanho][tamanho][tamanho];Alocação dinâmica de memória#include \"stdio.h\"#include \"stdlib.h\"int main( ){int *matriz, x;matriz = (int *) malloc(5 * sizeof(int)); //casting para ponteiro, pois o retorno padrão de malloc é void *matriz[0] = 10;matriz[1] = 15;matriz[2] = 20;matriz[3] = 25;matriz[4] = 30;for(x=0; x&lt;5; x++){printf(\"%d \", matriz[x]);}// 10 15 20 25 30free(matriz);return 0;}Exemplos#include \"stdio.h\"#include \"stdlib.h\"int main(){ char *c; // Declaracoes variadas int x, y, z; int matrizA[5] = {2, 2, 3, 3, 4}; int matrizB[5]; int *matrizC = NULL; int *matrizD[5]; int matrizBD[2][3] = { {1, 2, 3}, {4, 5, 6} }; int matrizTD[2][2][2]; // Inserindo valores em uma matriz matrizB[0] = 1; matrizB[1] = 3; matrizB[2] = 5; matrizB[3] = 7; matrizB[4] = 9; // Exibindo valores for(x=0; x&lt;5; x++) { printf(\"n matrizA[%d] = %d, matrizB[%d] = %d\", x, matrizA[x], x, matrizB[x]); } for(x=0; x &lt; sizeof(matrizA) / sizeof(int); x++) { printf(\"n matrizA[%d] = %d, matrizB[%d] = %d\", x, matrizA[x], x, matrizB[x]); } // Alocando dinamicamente uma matriz de 5 posicoes matrizC = (int *) malloc(5 * sizeof(int)); matrizC[0] = 10; matrizC[1] = 20; matrizC[2] = 30; matrizC[3] = 40; matrizC[4] = 50; for(x=0; x&lt;5; x++) { printf(\"n matrizC[%d] = %d\", x, matrizC[x]); } // Liberando da memoria uma matriz alocada dinamicamente free(matrizC); // Matriz de ponteiros matrizD[0] = &amp;matrizA[0]; matrizD[1] = &amp;matrizA[1]; matrizD[2] = &amp;matrizB[0]; matrizD[3] = &amp;matrizB[1]; y = 3; matrizD[4] = &amp;y; for(x=0; x&lt;5; x++) { printf(\"n matrizD[%d] = %d\", x, *matrizD[x]); } // Matriz bidimensional matrizBD[0][0] = 55; matrizBD[1][2] = 111; for(x=0; x&lt;2; x++) { for(y=0; y&lt;3; y++) { printf(\"n matrizBD[%d][%d] = %d\", x, y, matrizBD[x][y]); } } // Matriz tridimensional matrizTD[0][0][0] = 1; matrizTD[0][0][1] = 2; matrizTD[0][1][0] = 3; matrizTD[0][1][1] = 4; matrizTD[1][0][0] = 5; matrizTD[1][0][1] = 6; matrizTD[1][1][0] = 7; matrizTD[1][1][1] = 8; for(x=0; x&lt;2; x++) { for(y=0; y&lt;2; y++) { for(z=0; z&lt;2; z++) { printf(\"n matrizTD[%d][%d][%d] = %d\", x, y, z, matrizTD[x][y][z]); } } } scanf(\"%c\", &amp;c); return 0;}#include \"stdio.h\"#include \"stdlib.h\"int main(){ char *c; // Ponteiro para matriz de uma dimensao int *matrizUnidimensional; // Ponteiro para ponteiro (matriz de duas posicoes) int **matrizBidimensional; int x, y; // Alocacao de uma dimensao matrizUnidimensional = (int *) malloc(5 * sizeof(int)); matrizUnidimensional[0] = 15; matrizUnidimensional[1] = 25; matrizUnidimensional[2] = 35; matrizUnidimensional[3] = 45; matrizUnidimensional[4] = 55; for(x=0; x&lt;5; x++) { printf(\"n Matriz unidimensional [%d] = %d\", x, matrizUnidimensional[x]); } // Liberacao de uma dimensao free(matrizUnidimensional); // Alocacao de duas dimensoes (passo 1/2: dimensao 1) matrizBidimensional = (int **) malloc(5 * sizeof(int *)); // Alocacao de duas dimensoes (passo 2/2: dimensao 2 para cada item da dimensao 1) matrizBidimensional[0] = (int *) malloc(2 * sizeof(int)); matrizBidimensional[1] = (int *) malloc(2 * sizeof(int)); matrizBidimensional[2] = (int *) malloc(2 * sizeof(int)); matrizBidimensional[3] = (int *) malloc(2 * sizeof(int)); matrizBidimensional[4] = (int *) malloc(2 * sizeof(int)); matrizBidimensional[0][0] = 1; matrizBidimensional[0][1] = 2; matrizBidimensional[1][0] = 3; matrizBidimensional[1][1] = 4; matrizBidimensional[2][0] = 5; matrizBidimensional[2][1] = 6; matrizBidimensional[3][0] = 7; matrizBidimensional[3][1] = 8; matrizBidimensional[4][0] = 9; matrizBidimensional[4][1] = 10; for(x=0; x&lt;5; x++) { for(y=0; y&lt;2; y++) { printf(\"n Matriz bidimensional [%d][%d]: %d\", x, y, matrizBidimensional[x][y]); } } // Liberando matriz de duas dimensoes: primeiro libera todas as posicoes da segunda dimensao for(x=0; x&lt;5; x++) { free(matrizBidimensional[x]); } // Por ultimo, libera a primeira dimensao free(matrizBidimensional); scanf(\"%c\", &amp;c); return 0;}Strings Conjunto de caracteres (char) Armazenados em formato de matrizes unidimensionais (arrays, vetores) Toda string encerra com um valor nulo (0) em seu final, incluído automaticamente pelo compilador Seu tamanho deve ser declarado levando em conta o caractere de encerramento Declarando Strings Especificando o tamanho Não especificando o tamanho char minhaStr[4] = \"ola\";printf(\"%s\", minhaStr); // olachar minhaStr[3] = \"ola\";printf(\"%s\", minhaStr); // olaa#(##char minhaStr[4] = {'o', 'l', 'a', '0'};printf(\"%s\", minhaStr); // olachar minhaStr[] = \"ola\";printf(\"%s\", minhaStr); // olachar minhaStr[]; // ErrominhaStr = \"ola\";printf(\"%s\", minhaStr);char *minhaStr;minhaStr = \"ola\";printf(\"%s\", minhaStr); // olaInteragindo com o usuário Biblioteca stdio.h Capturando valores – gets– gets vs. scanfGets realiza tratamento de nova linha (remove n), mas é perigoso de ser utilizado, pois permite que uma string de muitas posições seja forçada em uma variável menor. Deve ser evitado. Utilizar fgets(variável destino, limite de posições, local de origem da leitura/ stdin). Requer atenção com a limpeza do buffer de entrada.· Limpeza do bufferStrtok(variável destino, caractere a ser apagado);strtok (x, “/n”); //caractere de escape que pode ficar no bufferTratar exceções no tamanho da entrada - limpar o bufferif (strlen(x) == 6-1) { //tamanho da variável -1 while ((ch = getchar()) != 'n' &amp;&amp; ch != EOF); //End Of File} if (strlen(x) == 6-1) { //tamanho da variável -1 while ((ch = getchar()) != ‘n’ &amp;&amp; ch != EOF); //End Of File } Imprimindo valores– putsExibe string na tela, preparado para concatenar strings com quebras de linha– puts vs. printfPrintf não quebra linhas automaticamente.-sprintf associa e concatena mensagens a uma variável, sem imprimir.sprintf(variável de destino, “mensagem impressa %s”, variavel substituida no texto);puts(variável de destino);Matriz de strings Matriz dentro de matriz Matriz bidimensional Funções interessantes Biblioteca string.hEm algumas funções não é necessário utilizar o caractere &amp; para indicar endereço de ponteiros, pois em C a passagem de parâmetros nesses casos já é feita por referência.//– strcpy: Copia uma string em outra; Altera o valor de uma string.(char *) strcpy(char *destino, char *origem ou nova string);//– strcat: Concatena duas strings; Concatena a segunda string na primeira.(char *) strcat(char *destino, const char *conteudo);//– strlen: Retorna o tamanho da string, sem considerar o caractere de finalização.(int) strlen(char *string);//– strcmp: Compara se duas strings são iguais; Operador == não funciona.(short) strcmp(char *string1, char *string2);//– strchr: Retorna o ponteiro para a primeira ocorrência de um caractere; substring(char *) strchr(char *string, char caractere);//– strrchr: Retorna o ponteiro para a última ocorrência de um caractere; substring(char *) strrchr(char *string, char caractere);//– strstr: Retorna o ponteiro para a primeira ocorrência de uma string(char *) strstr(char *string, char *substring);Tabela ASCII Utilizando caracteres ASCIIchar caractereAscii = 65;printf(\"%c\", caractereAscii); // ACódigos de escape Caracteres especiais utilizados em stringsOcupam apenas um slot na string Código Descrição a Beep (som) b Backspace (BS) f Alimentação de formulário (FF) n Nova linha (LF) r Retorno (CR) t Tabulação horizontal v Tabulação vertical ’ Aspas simples ” Aspas duplas 0 Nulo \\ Barra invertida Conversão entre textos e números Funções para conversão– Biblioteca stdlib.h– atoi: string para inteiro– atof: string para ponto flutuanteFunções O que são– Blocos de códigos independentes– Permitem organizar e centralizar rotinas Sintaxe– Cabeçalhotipo_de_retorno nome(parâmetros); – Definiçãotipo_de_retorno nome(parâmetros) { // Bloco de código } Escopo local– Variáveis locais são excluídas no final do bloco– Sem acesso a variáveis locais de outras funções– Acesso livre a variáveis globais– Variáveis do tipo static são compartilhadas entre diferentes chamadas da mesma funçãoParâmetros e retorno Parâmetros– Variáveis locais– Excluídas no final do bloco Retorno– Tipos de retornos Tipos de dados disponíveis no C Ponteiro Nada (void) – Instrução returnChamadas Por valor– Uma cópia do valor é criada na memória– Alterações são perdidas no final do bloco Por referência– Utilização de ponteiros– Uma cópia do endereço de memória é criado– Alterações são realizadas no mesmo endereço de memória informado, sendo mantidas– Exemplo: scanf// Por valorvoid soma(int p1){p1 = p1 + p1;}// Por referênciavoid somaPonteiro(int *p1){*p1 = *p1 + *p1;}int x = 4;soma(x);printf(\"%d\", x); // 4somaPonteiro(&amp;x);printf(\"%d\", x); // 8O método main Parâmetros– argc: número de parâmetros, tipo int– argv: parâmetros, array de string– Parâmetro ZERO é sempre o nome/caminho do programa· A definição de outros parâmetros na chamada do programa pode ser utilizada· Como esses parâmetros são opcionais, é importante tratar as exceções.– Padrão ANSI Retorno– Pelo padrão ANSI deve retornar intint main (int argc, char *argv[]){// Códigoreturn 0;}Interagindo com arrays / matrizes Passando como parâmetrovoid imprima(int *matriz){int x;for(x=0; x&lt;4; x++){printf(\"%d \", matriz[x]);}}void imprima(int matriz[4]){int x;for(x=0; x&lt;4; x++){printf(\"%d \", matriz[x]);}}void imprima(int matriz[]){int x;for(x=0; x&lt;4; x++){printf(\"%d \", matriz[x]);}}Retornando um array / matriz Envia-se um parâmetro adicionalvoid imprima(int *matriz){int x;for(x=0; x&lt;4; x++){printf(\"%d \", matriz[x]);}}void inverte(int *original, int *invertido){int x;for(x=0; x&lt;4; x++){invertido[4-1-x] = original[x];}}Parâmetro desconhecido Quando o parâmetro pode ser de diferentes tipos de dados dependendo da ocasião Parâmetro do tipo void* Pode ser utilizado como parâmetro da função e como seu retorno void grave(void* buffer){FILE* arquivo;arquivo = fopen(\"dados.txt\", \"wb\");fwrite(&amp;buffer, sizeof(buffer), 1, arquivo);fclose(arquivo);}Parâmetros variáveis Funções com número e tipos de parâmetros indefinidos Exemplo: printf(“%d %d %d”, 35, 42, 66); Instrução reticências (…) Pelo menos um parâmetro deve ser fixo Biblioteca stdarg.h – va_list: matriz de argumentos– va_start(matriz, primeiro parâmetro): inicializa a matriz– va_arg(matriz, tipo de dado): acessa a matriz– va_end(matriz): encerra o usoPonteiro para função Cada função possui seu ponto de entrada-Utilizado para facilitar alternância entre bibliotecas de SO diferentes - basta alterar o ponteiro que aponta para a função, sem a necessidade de alterar todas as ocorrências da função no código.– Endereço de memória no código-objeto Sabendo o ponto de entrada, pode-se apontar para eleint (*pf) (const char *);puts(\"texto\");pf = puts;pf(\"texto\");00003443(\"texto\");Recursão Função que invoca ela mesma Looping infinito Exemplo: cálculo de fatorial de um número int fatorial(int n){if(n != 1){return n * fatorial(n-1);}else{return 1;}}int x = fatorial(4);printf(\"%d\", x); // 24Exemplo#include \"stdio.h\"#include \"stdarg.h\"int somaValores(int valorA, int valorB){ int resultado; resultado = valorA + valorB; return resultado; // return valorA + valorB;}void strBomdia(char *str, char *nome){ sprintf(str, \"Bom dia sr(a) %s\", nome);}//void imprime(int *matriz)//void imprime(int matriz[50])void imprime(int matriz[], int tamanho){ int x; printf(\"n \"); for(x=0; x&lt;tamanho; x++) { printf(\"%d \", matriz[x]); }}int somaParametrosVariaveis(int p1, ...){ int total = 0; int contadorDeParametros = 0; va_list args; int temp; va_start(args, numeroDeParametros); while (contadorDeParametros++ &lt; numeroDeParametros) { temp = va_arg(args, int); total += temp; } return total;}int somaRecursao(int v){ if(v == 1) { return 1; } else { return v + somaRecursao(v-1); }}int main(int argc, char *argv[]){ char *c; int i; char buffer[50]; int valores[10] = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}; int (*ponteiroFuncao) (int a, ...); // Funcao simples i = somaValores(20, 30); printf(\"n Resultado: %d\", i); // Funcao por referencia strBomdia(buffer, \"Andre\"); printf(\"n %s\", buffer); // Argumentos do metodo main for(i=0; i&lt;argc; i++) { printf(\"n Parametro %d: %s\", i, argv[i]); } if(argc &gt; 1) { strBomdia(buffer, argv[1]); printf(\"n %s\", buffer); } // Funcoes com matrizes imprime(valores, 10); // Parametros variaveis i = somaParametrosVariaveis(3, 3, 4, 5); printf(\"n A soma e: %d\", i); i = somaParametrosVariaveis(4, 3, 4, 5, 6); printf(\"n A soma e: %d\", i); i = somaParametrosVariaveis(5, 3, 4, 5, 6, 7); printf(\"n A soma e: %d\", i); // Ponteiro de funcao ponteiroFuncao = somaParametrosVariaveis; i = ponteiroFuncao(3, 4, 2, 3); printf(\"n A soma e: %d\", i); // Recursividade i = somaRecursao(5); printf(\"n A soma recursao de 5 e: %d\", i); scanf(\"%c\", &amp;c); return 0;} Estruturas e uniõesEstrutura (struct) Conjunto de variáveis, de mesmos ou diferentes tipos Dados variados, porém relacionados entre si com um mesmo propósito Estrutura vs. OO Não comportam métodos Instrução structSintaxe struct nome { tipo nome; ... tipo nome; } [variáveis];//Exemplostruct pessoa {char nome[30];unsigned int idade;double peso;} p1; Tipo de dado: struct nome_structstruct pessoa p2, p3; Acesso (.)p1.idade = 30;Matrizes de estruturas struct com [ ]struct pessoa {char nome[30];unsigned int idade;double peso;} turma[5];strcpy(turma[0].nome, \"Andre\");turma[0].idade = 30;turma[0].peso = 68.5;Estruturas em funções Utilizar como um tipo de dado simples Declarar o parâmetro da função como o tipo de dado: struct nome_struct nome_parâmetroPonteiros de estruturas Similar aos demais usos de ponteirostruct pessoa p1;struct pessoa *p2;p2 = &amp;p1; Acesso via operador seta (-&gt;)printf(“Nome: %s”, p2-&gt;nome);Estruturas dentro de estruturas Estrutura comporta qualquer tipo de dado Se uma estrutura é um tipo de dado, então comporta uma estrutura Comporta ponteiros, matrizes struct geral {int x;int *y;int z[15];struct pessoa p1;struct pessoa galera[30];struct pessoa *p2;};Uniões Instrução union Compartilhamento de memória entre variáveis Tipos definidos pelo usuário Instrução typedef Permite criar apelidos para tipos de dados ArquivosArquivos e streams O que são streams?– Sequência de informações– YouTube: streaming de áudio e vídeo– Streams binárias Bytes– Streams de texto Caracteres O que são arquivos? – Destino das streams– Exemplos: arquivo, navegador, impressora– Palavra chave FILEMecanismo de ponteiro Posicionamento de ponteiro Instrução fseek: posiciona o ponteiro – Biblioteca stdio.h– SEEK_SET: início do arquivo– SEEK_CUR: posição atual– SEEK_END: final do arquivo– EOF: atingiu o final do arquivo (End Of File)Modos de interação Modos para arquivos textor Somente para leitura, colocando o ponteiro no começo do arquivo.r+ Leitura e escrita, colocando o ponteiro no começo do arquivo.w Somente para escrita, colocando o ponteiro no começo do arquivo, criando o arquivo caso ele não exista.w+ Leitura e escrita, colocando o ponteiro no começo do arquivo, criando o arquivo caso ele não exista.a Somente para escrita, colocando o ponteiro do arquivo no final deste, criando o arquivo caso ele não exista.a+ Leitura e escrita, colocando o ponteiro do arquivo no final deste, criando o arquivo caso o mesmo não exista. Modos para arquivos bináriosrb Somente para leitura, colocando o ponteiro no começo do arquivo.r+b Leitura e escrita, colocando o ponteiro no começo do arquivo.wb Somente para escrita, colocando o ponteiro no começo do arquivo, criando o arquivo caso ele não exista.w+b Leitura e escrita, colocando o ponteiro no começo do arquivo, criando o arquivo caso ele não exista.ab Somente para escrita, colocando o ponteiro do arquivo no final deste, criando o arquivo caso ele não exista.a+b Leitura e escrita, colocando o ponteiro do arquivo no final deste, criando o arquivo caso o mesmo não exista.Permissão de acesso Exemplos de problemas comuns– Criar arquivo sem acesso de gravação– Realizar leitura sem acesso no arquivo– Realizar leitura sem acesso no diretório Permissões de acesso– Acesso r/w nos diretórios em questão– Acesso r/w nos arquivos em questão– Geralmente problemas são falta de permissõesPrincipais comandos Biblioteca stdio.h Abertura e fechamento – fopen(nome_arquivo, modo_abertura)– fclose(FILE*) Escrita e leitura de caracteres– fputc(caractere, FILE*)– fgetc(FILE*) Escrita e leitura de strings– fputs(string, FILE*)– fgets(string, tamanho, FILE*) Escrita e leitura maiores que um byte– fwrite(buffer, bytes, contador, FILE)– fread(buffer, bytes, contador, FILE) Buffer– Região temporária de dados– Geralmente de tamanho pequeno– Geralmente uma matriz unidimensional– Exemplo: char meuBuffer[10] Verificação se chegou ao final do arquivo– feof(FILE*) Verificação de erro– ferror(FILE*) Descarregamento do stream no arquivo– fflush(FILE*) Retroceder o indicador de posição ao início– rewind(FILE*) Deletar o arquivo– remove(nome do arquivo)Ordenações e buscasOrdenações Quando utilizar– Buscas com frequência Produzem melhores resultados se utilizados com mecanismos de buscas inteligentes Tipos de ordenações – Bubble sort– Shell sort– Quick sortOrdenações mais conhecidas Bubble sort– Ordenação como bolhas de sabão– Não eficiente: trocas em excesso Shell sort– Ordenação em nível: 3 em 3, 2 em 2, 1 em 1– Eficiente: relativamente rápida e otimizada Quick sort– Ordenação em blocos– Eficiente: considerada a melhor ordenaçãoBuscas Utilizadas em parceria com ordenação Diferentes tipos de busca – Busca sequencial Posição por posição (força bruta) Similar a busca sequencial em dados não ordenados – Busca binária Divide ao meio e decide para que lado prosseguir Dados devem estar ordenados Número de operações diminui Estruturas de dados Principais estruturas de dados– Organizados em arrays Fila Fila circular Pilha – Organizados por ponteiros Lista encadeada Lista duplamente encadeada Árvore binária Fila Primeiro que entra é o primeiro a ser atendido FIFO: First In First Out Operações – Enqueue: insere um elemento na fila– Dequeue: remove um elemento da fila Exemplo: fila de banco, fila de pagar contaFila circular Mesma lógica da fila tradicional (FIFO) Reaproveitamento de posições Utilização: – Fila tradicional: filas de tamanho previsto– Fica circular: filas de tamanho imprevisívelPilha Último que entra é o primeiro a ser atendido LIFO: Last In First Out Operações – Push: insere um elemento– Pop: remove um elemento Exemplo: pilha de chamadas de métodosLista encadeada Acesso randômico na memória Não destrói os elementos removidos Cada elemento aponta para um próximo Lista duplamente encadeada Similar a uma lista encadeada tradicional Adiciona um ponteiro para o anterior Árvore binária Cada elemento aponta para dois outros, que não podem apontar para ele novamente Cada elemento é um nó – Raíz– Nó terminal" }, { "title": "Anotações sobre CSS", "url": "/posts/css/", "categories": "Estudos-faculdade", "tags": "css, web", "date": "2020-07-10 08:00:00 -0300", "snippet": "Introdução Para saber a compatibilidade dos browsers aos elementos www.caniuse.com Formas de vincular propriedades CSS com páginas e/ou elementos HTML Atributo style de marcações HTML que permita escrever as propriedades CSS dentro dela; Marcação link do HTML que importe um arquivo CSS; Marcação style do HTML que permita escrever as propriedades CSS dentro dela. Associação com os elementos do html - Seletores :root raiz do documento todo, para variáveis globais .{} documento todo .nomedaclasse{} #nomedoid [attr=value] //// [type=’radio’] [atributo^=”valor de início”] // [href^=”http”] [atributo$=”valor de fim”] // [src$=”.png”] :not(seletor) Seletores compostos utilizar um + entre os seletores indica o próximo elemento imediato (irmão) utilizar um ~ entre os seletores indica todos os próximos elementos imediatos (irmãos) utilizar um &gt; entre os seletores indica o próximo elemento filho direto Para indicar n elementos filhos: :nth-child(numero do filho ou expressão matemática) /// article:nth-child(3n) múltiplos de 3 // funciona diferente em seletores de elementos html, não em classes ou ids :first-child // :last-child // Unidades absolutas in - inches mm - millimeters Unidades relativas em - baseado no tamanho da fonte do elemento rem Prioridade dos estilos estilos marcados com !important no css &gt; declarações de style no próprio elemento html &gt; Ids &gt; classes na ordem que aparecem(últimas sobrescrevem as primeiras) &gt; body Declarando variáveis no CSS –variavel: valor; para chamar a variável: var(nomedavariável, valor caso a variável seja inválida) para compatibilidade com browser antigos, declare uma propriedade padrão antes daquela que usa uma variável. color: red; color: var(–variavel); As variáveis são herdadas dentro de um mesmo seletor pai, para que sejam globais devem ser declaradas no :root Algumas Propriedades {background-color: rgba(%,%,%,0-1) // hsl(deg,%,%);background: url();background-clip: border-box // content-box // inherit // padding-box (comportamento do background em relação a borda);background-image: repeating-// linear gradient (direção, cores separadas por vírgula) // radial-gradient (forma[circle/ellipse] ou posição, cores e porcentagens separadas por vírgula);margin: top right bottom left aceita valores negativos;padding:;top:;left:;bottom:;right:;width:;height:;cursor: pointer;opacity:;box-shadow: recuo eixo x e y esfumaçamento tamanho e cor, múltiplas sombras separadas por vírgula;box-sizing: border-box (o tamanho final é o definido em width e height, não soma os valores de paddinge border)//content-box;position: static//relative // absolute (referencia a outro elemento pai posicionado)//fixed; z-index: valor numérico que determina a ordem de visibilidade de elementos empilhados/sobrepostos;float: right//left//none (menos usado hoje);clear: right//left//none//both(limpar float de elemento anterior);display: block(ocupa 100% da área disponível e gera quebra de linha)//inline(ocupa apenas o espaço necessário na linha)//inline-block//none;visibility: hidden (oculta mas mantem o espaço// não remove do fluxo da página);overflow:(tratar conteúdo que excede elemento) visible//hidden//scrool//auto;resize: none;}Propriedades de texto{ color: #0000000 // #000 // rgb(255, 255, 255) //cor do texto; font-size:; font-family: mais de uma opção, separada por vírgula; font-weight:; font-style: italic; line-height:; text-decoration: ; text-transform: lowercase // uppercase // capitalize // initial // inherit // none; text-shadow: recuo eixo x e y esfumaçamento tamanho e cor, múltiplas sombras separadas por vírgula; text-align: justify // center // right // left;}Borda{border-color: red;border-width: 5px;border-style: solid;border:;border-collapse: separate//collapse;border-radius: top right bottom left // medidas no eixo x / medidas no eixo y //para uma esfera perfeira utilizar 50% ou o tamanho de metade da div em px;}Importar fonte do Google//•No html&lt;style&gt;&lt;link href=\"https://fonts.googleapis.com/css?family=Lobster\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;/style&gt;//•Depois no CSSfont-family: FAMILY_NAME, GENERIC_NAME;@font-face{ font-family: src: url() format(''); }Pseudoclasses em links e outrasa:linka:visiteda:hovera:active:focus:empty:invalid:checked:disabled:read-onlyPseudo-classes :before e :afterdiv:before{content:\"\"} // div:after{content:\"\"}sempre precisa de um content. O texto inserido por css não é selecionado nem lido por motores de busca.Pseudo-elementos::after::before::placeholder::selection::first-letter::first-line::selectionPropriedade Transform{transform: translateX(50px) // translateY() // translate(x,y) // rotate(45deg) // skewX(10deg) // skewY() // skew(x,y) // scale(x,y);transform-origin: left top;}Listas{ list-style-type: none//; list-style-position:; list-style-image:;}ImagensUse uma imagem Retina para monitores de alta resolução. Ou configure imagens normais para que sejam exibidas com apenas metade do tamanho originalimg { max-width: 100%; height: auto; }Imagens de fundo{ background-image: url(); background-attachment: fixed; background-size: px/ contain/ cover; background-repeat: no-repeat; background-position: right bottom;}Tornando elementos visíveis apenas para leitores de tela - Acessibilidade.sr-only { position: absolute; left: -10000px; width: 1px; height: 1px; top: auto; overflow: hidden; }Display: none e visibility: hidden oculta o conteúdo de todos, incluindo do leitor de tela.ResponsividadeUm css para cada tipo de media:Grids fluídas - 12 colunas&lt;link href=\"tela.css\" rel=\"stylesheet\" media=\"screen\"&gt;&lt;link href=\"impressao.css\" rel=\"stylesheet\" media=\"print\"&gt;&lt;link href=\"mobile.css\" rel=\"stylesheet\" media=\"handheld\"&gt;Responsividade - Media queries@media (max-width:768px) { }@media (max-width:520px) { }Outras propriedades: min-width // min max-height // min max-device-width height // orientation // aspect-ratio // device-aspect-ratio // resolutionÉ mais fácil desenvolver primeiro para mobile, e depois adaptar para telas maiores.Responsividade - TipografiaUse viewport como unidade de medida, invés de em ou px:&lt;meta name=\"viewport\" content=\"width=device-width\"&gt;{width: } vw (viewport width): 10vw would be 10% of the viewport's width. vh (viewport height): 3vh would be 3% of the viewport's height. vmin (viewport minimum): 70vmin would be 70% of the viewport's smaller dimension (height or width). vmax (viewport maximum): 100vmax would be 100% of the viewport's bigger dimension (height or width).Contadores em CSS{ counter-reset: nomedocontador; counter-increment: nomedocontador; counter(nomedocontador) //para exibir os valores;}Animações{ transition: propriedade (pode usar all) duração timing delay, outras...; transition-property:; transition-duration:; transition-timing-function: linear // cubic-bezier(); transition-delay:; Somente valores numéricos e cores podem ser animados. Propriedades mais performáticas são transform e opacity. Se preciso, utilize will-change para tentar melhorar a performance da animação. animation: name duration timing-function delay iteration-count direction fill-mode play-state; animation-name:; animation-duration:; animation-delay:; animation-direction: alternate // alternate reverse; animation-play-state:; animation-iteration-count: numero // infinite; animation-fill-mode: forwards // backwards // both // none // propriedades antes ou depois da animação; animation-timing-function: ease // ease-out // ease-in // linear // ease-in-out // cubic-bezier(x1, y1, x2, y2); @keyframes nomedaanimacao { from {} to {} 0% {} 100 {} }}CSS Grid (estabelece áreas de layout){ display: grid; grid-template-columns: px px (um para cada coluna); pode usar repeat(número de repetições//auto-fill//auto-fit, tamanho px); pode nomear as lines [nome das lines] minmax(px, px,); grid-template-rows: % fr (uma fração do conteudo); pode usar repeat(número de repetições//auto-fill//auto-fit, tamanho px); pode nomear as lines [nome das lines] minmax(px, px,); grid-column-gap: 20px; grid-auto-rows: valores alternados para linhas alternadas.; grid-row-gap: 5px; grid-gap: [rows] [columns]; grid-column: [start line] / [end line]; (like colspan) grid-row: [start line] / [end line]; (like rowspan) justify-self: start // center // end // stretch; align-self: start // center // end // stretch; justify-items: start // center // end // stretch; (para todos os itens) align-items: start // center // end // stretch; (para todos os itens) grid-area: nomedaarea; para colocar um item naquela área grid-area: horizontal line start / vertical line start / horizontal line end / vertical line end; (quando não criou áreas nomeadas antes) grid-template-areas: \"nomedecadacélular .para célula vazia\" \"linhas entre aspas\" \"footer footer footer\";}Flexbox (alinhar ou distribuir em linha reta){display: flex; aplicado no elemento/container paiflex-direction: row // column // row-reverse // column-reverse;justify-content: center // flex-start // flex-end // space-between // space-around // space-evenly;align-items: flex-start // flex-end // center // stretch // baseline;align-content: flex-start // flex-end // center // stretch // baseline;flex-wrap: nowrap // wrap // wrap-reverse;flex-flow: direction wrap;flex-basis: 10px;flex-shrink: 1//2//3;flex-grow: 1//2//3;flex: [grow] [shrink] [basis];order: -1 // 0 // 1 // 2...;align-self: flex-start // flex-end // center // stretch // baseline;} float, clear, and vertical-align do not work on flex items." }, { "title": "Anotações sobre Legislação e Propriedade Intelectual", "url": "/posts/legislacao-propriedade-intelectual/", "categories": "Estudos-faculdade", "tags": "gestão, legislação", "date": "2020-07-03 08:00:00 -0300", "snippet": "Evolução históricaA propriedade surge junto com o indivíduo, portanto trata-se de um fenômeno social diretamente ligado ao fenômeno jurídico, já que o Direito, sendo um controle social, tem papel fundamental para manter a harmonia entre os indivíduos.Em 1789, a Revolução Francesa traz a Declaração dos Direitos do Homem e do Cidadão.Artigo 1º Os homens nascem e são livres e iguais em direitos. As distinções sociais só podem fundar-se na utilidade comum.Artigo 2º O fim de toda a associação política é a conservação dos direitos naturais e imprescritíveis do homem. Esses Direitos são a liberdade. a propriedade, a segurança e a resistência à opressão.O reconhecimento e a proteção da propriedade intelectual remontam ao século V, na Idade Média, quando artesãos, ceramistas e talhadores de pedra marcavam suas obras buscando o reconhecimento da criação.Somente em 1824, quando nasceu nossa primeira Constituição, logo após a Proclamação da Independência do Brasil em 7 de setembro de 1824, o direito à propriedade intelectual foi garantido, conforme o artigo 179, alínea 26.Em consequência ao previsto na Constituição de 1824, nasce a Lei de 28 de agosto de 1830, que veio proteger os inventores, conforme seu artigo 1º, no qual consta que “A Lei assegura ao descobridor, ou inventor de uma indústria útil a propriedade e o uso exclusivo da sua descoberta, ou invenção(BRASIL, 1830).Primeira legislação que regulou as marcas de fábrica no Brasil: o Decreto n. 2.682, de 1875.Em 1883, a Convenção de Paris organizou as normas de proteção às marcas, às patentes, aos desenhos industriais etc. O conteúdo do Decreto n. 2.682 de patentes estava alinhado à Convenção de Paris. Dessa forma, nossa legislação não precisou ser alterada.Lei n. 3.129, de 14 de outubro de 1982, que regula a concessão de patentes.Em 1967 nasce Organização Mundial da Propriedade Intelectual (OMPI), órgão autônomo dentro do sistema das Nações Unidas, o qual englobou as Uniões de Paris e de Berna.Em 1996 a Lei n. 9.279 é promulgada no Brasil para regular direitos e obrigações relativos à propriedade industrial.Em 1998 a Lei n. 9.610 de Direitos Autorais é sancionada com o objetivo de proteger as relações entre o criador e a utilização de obras literárias, artísticas ou científicas, programas, de computador, topografia de circuito integrado e domínios na internet.1623 – Inglaterra: Estatuto dos Monopólios.1790 – Estados Unidos: 1ª Lei Americana.1791 – França: Lei de Privilégio de Invenção.1809 – Brasil: Alvará – Ato oficial da corte Portuguesa recém-chegada ao Brasil (1808), que visava estimular os investimentos industriais em determinadores setores.1824 – Brasil: Direito de Propriedade concedido aos inventores sobre as suas descobertas ou produções (artigo 179, alínea 26 da Constituição).1830 – Brasil: Promulgada a 1ª Lei de Concessão dos Privilégios Industriais e Direitos Decorrentes (50 anos sem ser aplicada em virtude de não haver inventores e indústrias compatíveis).1882 – Brasil: Nova Lei de Patentes.1875 – Brasil: 1ª Lei de Marcas.1883 – França: Convenção da União de Paris (CUP), que estabeleceu os princípios jurídicos comuns de proteção à criação intelectual entre os países. Está em vigor no Brasil desde 1975 e já passou por sete revisões.1946 – Criação do General Agreement on Tariffs and Trade (GATT), em uma conferência do Conselho Econômico e Social da ONU.1986 – Uruguai: Reunião do GATT em Punta Del Este — Rodada do Uruguai — mais de 100 países reunidos visando solucionar problemas de ordem comercial. Desde então, assuntos relativos à propriedade intelectual passaram a ser tratados no âmbito do GATT.1994 – Criação do Trade Related Aspects of Intellectual Property Rights (TRIPS), um acordo sobre aspectos dos direitos de propriedade intelectual relacionados ao comércio. Novo acordo sobre o tema em vigor em todos os países da OMC. A partir de então, a propriedade intelectual é encarada como mercadoria.1996 – Brasil: Publicação da Lei n. 9.279/96, de 14 de maio de l996, que regula direitos e obrigações relativos à propriedade industrial.1998 – Brasil: Lei de Direitos Autorais (Lei n. 9.610/98)De acordo com Mizukami (2007), o surgimento do Direito Autoral se deve a quatro fatores:1.A invenção e disseminação da imprensa de tipos móveis (1450 –Gutenberg);2.O surgimento da concepção moderna da figura do autor, segundo a qual era importante aliar a obra ao seu autor;3.O crescimento do mercado de livros;4.O ambiente cultural no contexto de surgimento do direito autoral.Na China do século XIl, o mercado de livros era próspero, porém os autores chineses não tinham qualquer direito de propriedade intelectual sobre as obras vendidas, pois o valor do livro estava diretamente ligado ao material que fora produzido.Os teólogos medievais transformaram esse ensinamento em uma lei canônica com fulcro na doutrina Scientia Donum Dei Est, Unde Vendi Non Potest (o conhecimento é uma dádiva de Deus, consequentemente ele não pode ser vendido).O privilégio de impressão era o direito concedido pelos monarcas aos editores, o que garantia a exploração econômica de determinada obra por certo período. Para tanto, não eram levados em conta os interesses dos autores, mas tão somente as necessidades daqueles que exercitavam uma atividade econômica, isto é, os impressores.Em 1709, surgiu o Estatuto da Rainha Anne, considerado a primeira lei de Direitos Autorais. Este estatuto nasceu para por fim aos privilégios de impressão na Inglaterra, reconhecendo os direitos aos autores, os quais poderiam ser transferidos ao editor.Em 1886, dez nações europeias assinaram o primeiro acordo multilateral de direitos autorais, a Convenção de Berna, da qual o Brasil se tornou signatário em 1923. Após essa data, o Direito Autoral no Brasil seguiu evoluindo em consonância com os acordos internacionais.A Lei de Direito Autoral vigente atualmente no Brasil é de 1998, sendo que em 2003 uma lei introduziu alterações ao título III, capítulo I (“Dos crimes contra a propriedade intelectual”). Essa lei postula que a obra será protegida pelo prazo de setenta anos mais a vida do autor.No século XI as marcas individuais se tornaram obrigatórias sob o enfoque mercantil, a marca estabelecia a relação entre o fabricante e o comprador podendo ele ser cliente ou consumidor, gerando uma certa segurança na relação.No século XIX, uma grande variedade e a quantidade de produtos estavam à disposição no mercado e as marcas surgiram como meio de incentivo ao consumo usadas em campanhas publicitárias, nesse momento o Direito se manifesta buscando a proteção as essas marcas e nasce a Lei de Marcas de Mercadoria na Inglaterra (1862), a Lei Federal da Marca de Comércio nos EUA (1870) e a Lei para a Proteção de Marcas na Alemanha.Em 1421, em Florença, na Itália, Felippo Brunelleschi cria um dispositivo para transportar mármore, foi uma das primeiras patentes que se tem registro na história.Em 1474, nasce a primeira lei de patentes do mundo em Veneza, com o objetivo de proteger com exclusividade o invento e o inventor, reconhecendo os direitos autorais e sugerindo regras para a aplicação no âmbito industrial, pelo prazo de 10 anos.Em 28 de abril de 1809 ocorre a publicação do Alvará de Patentes no Brasil, assinado por Dom João VI.No final dos anos 70 a evolução constante da tecnologia trouxe o conceito de “softwares proprietários” que eram, e ainda são, uma modalidade de comercialização em que o comprador não tem direito sobre os códigos fontes. Essa prática aumentou a margem de lucro entre os fabricantes de softwares, aumentando a concorrência, o que motivou a busca pela proteção da propriedade intelectual. A partir de então o código-fonte passou a ser protegido, pois ele é o próprio conhecimento do software.Conceito de propriedadeA propriedade é um fenômeno espontâneo, decorrente da necessidade de subsistência do ser humano, sendo posteriormente regulado a fim de possibilitar a convivência social pacífica.O Direito conceitua propriedade como sendo o Direito Real sobre a coisa própria, este conceito vem da classificação dos Direitos Reais:a) jus in re propria – direito sobre a coisa própria, que se resume na propriedadeb) jus in re aliena – direito real sobre a coisa alheiaPropriedade e DireitoSistema de Sesmaria – 1530 no BrasilAo analisarmos as constituições brasileiras, percebemos que houve uma evolução quanto ao direito de propriedade. De um direito absoluto e inquestionável a um direito relativizado, ligado diretamente à ideia de bem-estar social, até chegarmos à função social da propriedade (1946). A Constituição de 1988 trata do direito de propriedade e é previsto, no artigo 5º, nos incisos XXII, XXVII e XXIX da Constituição Federal de 1988 como cláusula pétrea.Direito Objetivo e Direito SubjetivoO chamado direito objetivo pode ser entendido como o direito positivado, a norma a que os indivíduos estão submetidos;Direito subjetivo e dever jurídico figuram sempre em face de alguém e dentro de uma relação.Então, podemos dizer que direito objetivo é norma da organização social. É chamado Jus norma agendi.Direito subjetivo é a possibilidade de agir que a ordem jurídica garante a alguém. Direito subjetivos expatrimoniais: direitos de personalidade e os direitos de família Direitos subjetivos patrimonias: reais e pessoais Direito Subjetivo de propriedade: a maioria dos doutrinadores de direito civil considera o direito subjetivo de propriedade extremamente importante, pois ele centraliza o direito Real que pertence ao ramo do Direito Privado.Direito Público pode ser chamado como o Direito do Estado e o Direito Privado, o direito dos indivíduos.Alguns ramos do Direito Privado: Direito Civil; Direito Autoral e Propriedade Intelectual; Direito Comercial; Direito do Trabalho; Direito Internacional Privado; Direito do Consumidor; Direito Empresarial; Direito de Família; Direito das Sucessões; Direito Coletivo do Trabalho; Direito Processual do Trabalho; Direito Ambiental; Direito Imobiliário; Direito Previdenciário; Direito Tributário; Direito de Trânsito; Direito Eleitoral; Direito Contratual; Direitos Humanos, entre outros.Conceito de propriedade intelectualA propriedade intelectual é a consequência da criatividade e do intelecto humano.1967 - Organização Mundial da Propriedade Intelectual (OMPI): a soma dos direitos relativos às obras literárias, artísticas e científicas, às interpretações dos artistas intérpretes e às execuções dos artistas executantes, aos fonogramas e às emissões de radiodifusão, às invenções em todos os domínios da atividade humana, às descobertas científicas, aos desenhos e modelos industriais, às marcas industriais, comerciais e de serviço, bem como às firmas comerciais e denominações comerciais, à proteção contra a concorrência desleal e todos os outros direitos inerentes à atividade intelectual nos domínios industrial, científico, literário e artístico (OMPI, 1967).Bens imateriais: as práticas, representações, expressões, conhecimentos e técnicas — junto com os instrumentos, objetos, artefatos e lugares culturais que lhes são associados — que as comunidades, os grupos e, em alguns casos, os indivíduos reconhecem como parte integrante de seu patrimônio cultural (UNESCO, 2006).A expressão em latim sui generis é usada no direito para designar algum objeto ou situação que seja o(a) único(a) de seu tipo. A Proteção Sui generis envolve a topografia de circuito integrado, os conhecimentos tradicionais e o acesso ao patrimônio genético, sendo cada tipo de proteção regulamentada por legislação própria.Espécies de propriedade intelectual e suas diferenciações quanto à proteção jurídicaPropriedade industrialA propriedade industrial (PI) é o ramo da propriedade intelectual que trata da proteção dos direitos dados temporariamente aos autores de criações intelectuais de natureza inovadora, utilitária, industrial ou comercial, como os inventos, os modelos de utilidade, as marcas, os desenhos industriais, as novas variedades vegetais e as repressões às falsas indicações geográficas e à concorrência desleal.A propriedade industrial também possui como foco incentivar o desenvolvimento econômico, social e tecnológico do país. Os seguintes documentos são exigidos para outorga de proteção aos direitos: Patente de invenção; Patente de modelo de utilidade; Registro de desenho industrial; Registro de marca.Direitos autoraisOs direitos autorais é o ramo da propriedade intelectual que trata da proteção dos direitos das obras literárias, artísticas ou científicas, programas de computador, topografia de circuito integrado, domínios na internet e conexos.Considerando que todo criador tem direito sobre a sua obra intelectual e este direito lhe confere a exclusividade de utilizar, fruir e dispor de sua obra, o direito autoral constitui-se ao mesmo tempo em um direito moral decorrente do objeto da criação e um direito patrimonial, pelo fato de sua obra ser considerada como um bem móvel.O direito autoral é regulado pela Lei n. 9.610/98, de 19 de fevereiro de 1998.O artigo 8º determina o que não é objeto de proteção.I - as ideias, procedimentos normativos, sistemas, métodos, projetos ou conceitos matemáticos como tais;II - os esquemas, planos ou regras para realizar atos mentais, jogos ou negócios;III - os formulários em branco para serem preenchidos por qualquer tipo de informação, científica ou não, e suas instruções;IV - os textos de tratados ou convenções, leis, decretos, regulamentos, decisões judiciais e demais atos oficiais;V - as informações de uso comum tais como calendários, agendas, cadastros ou legendas;VI - os nomes e títulos isolados;VII - o aproveitamento industrial ou comercial das ideias contidas nas obras. (BRASIL, 1996)Relevância jurídica e econômica da propriedade intelectualSegundo Aranha (2002) “para os países em desenvolvimento, a segurança conferida pela proteção dos direitos de propriedade intelectual é fundamental para atrair novos investimentos e garantir empregos”.Para uma nação se desenvolver de forma sustentável social e econômica, ela depende da propriedade intelectual como um diferencial para competir de forma segura em um mercado globalizado.LegislaçãoA Constituição Federal de 1988 trata o Direito Autoral como um Direito Fundamental devido à relevância social do tema.Em 1998, nasceu a Lei n. 9.610, que regula os Direitos Autorais, entendendo-se sob este conceito os direitos de autor e os que lhes são conexos.A Lei n. 9.610, de 19 de fevereiro de 1998, protege as obras derivadas, que são as que tiveram origem em obras preexistentes, tais como; traduções de obras em outras línguas e adaptações de obras, como a realização de um filme com base em um romance.A lei protege dois tipos de direitos do autor: Os Direitos Morais, que permitem ao autor adotar medidas para preservar o vínculo pessoal existente entre ele e a obra; Os Direitos Patrimoniais, que permitem ao titular dos direitos extrair um benefício financeiro em virtude da utilização de sua obra por terceiros. Direito autoral é o que tem o autor de obra literária, científica ou artística de ligar seu nome às produções do seu espírito e de reproduzi-las. Na primeira relação é manifestação da personalidade, na segunda é de natureza real e econômica.O Direito Autoral muitas vezes é pensado como um trade off entre o interesse público do acesso às obras produzidas e o interesse privado de se obter lucro com a produção de conteúdo intelectual.O marco inicial para abordar a legislação de um tema sempre será a Constituição Federal, no tema da proteção das criações intelectuais, bem como marcas e as patentes, temos a previsão legal de proteção no artigo. 5º, XXIX.Em 1996 a Lei Nº 9.279 é promulgada no Brasil para regular direitos e obrigações relativos à Propriedade Industrial com 223 artigos.a) A lei expressa de forma clara o que pode ser considerado como marca;b) A lei determina o que não pode ser registrado como marca;c) A lei no artigo 130 lista a proteção conferida pelo registro;d) O artigo 133 nos traz a informação quanto ao tempo de validade do registro da marca;e) O artigo 189 nos apresenta a pena pela violação da lei;Em 1996, a Lei n. 9.279 é promulgada no Brasil para regular direitos e obrigações relativos à Propriedade Industrial com 223 artigos:a. A lei expressa de forma clara no artigo 8º o que é patenteável: “é patenteável a invenção que atenda aos requisitos de novidade, atividade inventiva e aplicação industrial” (BRASIL, 1996);b. A lei determina no artigo 10 o que não pode ser patenteável;c. Os artigos 41 e 42 tratam da proteção conferida pelo registro;d. O artigo 40 nos traz a informação quanto ao tempo de validade da Patentes e o modelo de utilidade, o artigo 108 trata do desenho industrial;e. O artigo 44 nos apresenta a pena pela violação da lei.Em 1998, a lei nº 9.609 foi promulgada no Brasil para regular a proteção da propriedade intelectual do programa de computador e sua comercialização.a. A lei expressa de forma clara o que é programa de computador;b. A lei determina a proteção dos direitos e do registro;c. A lei, nos artigos 7 e 8, lista a proteção conferida aos usuários dos programas de computador;d. Os artigos 12 e 13 nos trazem a informação quanto as infrações e as penalidades por não respeito a lei:Conceito de Marcas“Marca é um nome, termo, sinal símbolo ou combinação dos mesmos, que tem o propósito de identificar bens de um vendedor ou grupo de vendedores e de diferenciá-los de concorrentes”.É possível executar o processo de registro de marca respeitando três princípios:Princípio da Especialidade: inovação da marca em um determinado ramo;Princípio da não colidência com marca de alto renome: a marca não pode ser igual a uma marca conhecida além do seu próprio ramo atividade em território nacional;Princípio da não colidência com marca notoriamente conhecida: não pode ser igual a uma marca conhecida internacionalmente, ela é protegida pela convenção de Paris, mas somente no seu ramo de atividade.I. - marca de produto ou serviço: aquela usada para distinguir produto ou serviço de outro idêntico, semelhante ou afim, de origem diversa;II. - marca de certificação: aquela usada para atestar a conformidade de um produto ou serviço com determinadas normas e especificações técnicas, notadamente quanto à quantidade, natureza, material utilizado e metodologia empregada; eIII. - marca coletiva: aquela usada para identificar redutos ou serviços provindos de membros de uma determinada entidade.Marca Nominativa: marca nominativa, ou verbal, é o sinal constituído por uma ou mais palavras e as combinações de letras e números, ou algarismos romanos e/ou arábicos.Marca Figurativa: Marca figurativa, ou emblemática, é o sinal constituído por: desenho, imagem, figura e/ou símbolo; qualquer forma fantasiosa ou figurativa de letra ou algarismo isoladamente, ou acompanhado por desenho, imagem, figura ou símbolo; palavras compostas por letras de alfabetos distintos da língua vernácula, tais como hebraico, cirílico, árabe, etc.; ideogramas, tais como o japonês e o chinês. Marca Mista: marca mista, ou composta, é a combinação de elementos nominativos e figurativos ou mesmo apenas por elementos nominativos cuja grafia se apresente sob forma fantasiosa ou estilizada.Marca Tridimensional: marca tridimensional é o sinal constituído pela forma plástica distintiva em si, capaz de individualizar os produtos ou serviços a que se aplica. Para ser registrável, a forma tridimensional distintiva de produto ou serviço deverá estar dissociada de efeito técnico.Ter uma lei eficaz quanto à proteção de uma marca é de extrema relevância para se transmitir segurança e confiança aos investidores, tanto estrangeiros como nacionais, inibindo concorrência desleal, por essa razão o registro no INPI é o único caminho para que lei seja aplicada evitando danos e prejuízos financeiros.Conceito de patentePatente é um título de propriedade que confere ao seu titular direito de impedir terceiros de explorarem sua invenção, em um determinado território, por um limitado período de tempo.Para entendermos o que é patenteável, é necessário entendermos 3 conceitos: Novidade: um invento é considerado novidade sempre que não seja antecipado de forma integral por um único documento do Estado da Técnica; Atividade inventiva: é considerada atividade inventiva quando o invento não apresenta semelhanças a outras patentes já concedidas, quando não se caracteriza como um mero aperfeiçoamento decorrente de maneira evidente do Estado da Técnica; Aplicação industrial: significa que a invenção tem aplicabilidade em algum ramo industrial, como a agricultura, a farmacêutica, a mecânica, a engenharia genética, a química etc. Confira a seguir os tipos de Patentes: Patente de Invenção (PI): Produtos ou processos que atendam aos requisitos de atividade inventiva, novidade e aplicação industrial. Sua validade é de 20 anos a partir da data do depósito. Modelo de Utilidade (MU): É uma espécie de patente que busca proteger inovações com menor carga inventiva, que apresente nova forma ou disposição, envolvendo o ato inventivo, que resulte em melhoria funcional no seu uso ou em sua fabricação. Sua validade é de 15 anos a partir da data do depósito. Desenho Industrial (DI): o registro de Desenho Industrial busca a proteção da forma externa do produto, o conjunto de linhas e cores aplicadas, desde que apresentem um resultado novo e original e que sejam passíveis de produção industrial. Sua validade é de 10 anos a partir da data do depósito. Ter uma lei eficaz quanto à proteção de uma invenção é de extrema relevância para se transmitir segurança e confiança aos investidores e aos inventores, inibindo a concorrência desleal. Por essa razão, o registro é o único caminho para que a lei seja aplicada, evitando danos e prejuízos financeiros.Conceito de SoftwareO artigo 1º da lei nº 9.609/98 enuncia que: Art. 1º Programa de computador é a expressão de um conjunto organizado de instruções em linguagem natural ou codificada, contida em suporte físico de qualquer natureza, de emprego necessário em máquinas automáticas de tratamento da informação, dispositivos, instrumentos ou equipamentos periféricos, baseados em técnica digital ou análoga, para fazê-los funcionar de modo e para fins determinados." }, { "title": "Anotações sobre Gestão de Projetos", "url": "/posts/gestao-projetos/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-06-26 08:00:00 -0300", "snippet": "1. O processo de planejamentoProjeto, independentemente do fim que busca atender, é o conjunto de ações coordenadas por racionalidade e metodologia específica, visando atingir a concretização de um anseio, de uma ideia ou de algum objeto material, com o maior êxito e satisfação possível.Portfólio - Programa - ProjetoPrincipais características necessárias na elaboração e execução de um projeto: padronização flexibilidade documentação modularização planejamento. Tipos de projetos: empresariais, públicos e acadêmicos.A eficiência diz respeito às qualidades inerentes aos meios, ou seja, aos métodos adotados no projeto, enquanto a eficácia está relacionada com as qualidades do fim, dos resultados.O pensamento científico: todo conhecimento deve ter como condição a verificação empírica de seus resultados.O conhecimento popular: valorativo, reflexivo, assistemático, verificável, falível e inexato.O conhecimento filosófico: valorativo, racional, sistemático, não verificável, infalível e exato.O conhecimento teológico: valorativo, inspiracional, sistemático, não verificável, infalível e exato.O conhecimento científico: objetivo, real, contingente, sistemático, verificável, falível e aproximadamente exato.2. Planejamento estratégicoNecessidade surgida da realidade.Princípios gerais do planejamento estratégico: Contribuição aos objetivos que se pretende atingir. Precedência do planejamento. Penetração e abrangência sobre as fases. Maior eficiência, eficácia e efetividade no processo como um todo. Estrutura mínima do planejamento estratégico: Capa. Sumário ou índice. Resumo do projeto. Dados e histórico da organização. Diretriz organizacional (missão, políticas, objetivos etc.). Análises da situação atual. Estratégias viáveis ao ambiente. Controles (estratégico, tático e operacional). Eventuais anexos. Indicadores de desempenho: estatísticas de controle de processo (todas documentadas); identificação da proporção de produtos defeituosos em relação à produção; documentação de atrasos (absolutos e relativos); identificação de gastos adicionais (absolutos e relativos). Níveis de decisão e planejamento em uma organização: Estratégico – visa atender a política da organização. Tático – relacionado com o método escolhido para atender a política organizacional. Operacional – manifestação prática das táticas planejadas. Nível de crise – a antítese da boa tomada de decisão, mas que se faz necessária quando em ocasiões extremas e inesperadas. A competição se tornou algo constante no mundo atual.Cinco etapas destinadas a atender a administração estratégica de um projeto: Análise do ambiente no qual vai ser desenvolvido o projeto – nesse caso, é necessário que sejam observados o ambientes interno e externo e, a partir da análise, identificados os riscos, ameaças, oportunidades, fraquezas e forças da organização. Estabelecimento da meta, da missão e do objetivo da organização. Formulação de estratégias a partir da definição de ações, dentro da organização, que contribuirão para que sejam alcançados os objetivos propostos. Prática das estratégias desenvolvidas. Monitoramento e avaliação de todo o processo para que, de modo estratégico, seja assegurado seu bom funcionamento. A missão está diretamente ligada com a atividade principal da organização. A razão de ser, o motivo pelo qual foi criada.A visão é a aspiração que se projeta no futuro.Já os valores, ou princípios, determinam como o ambiente interno da organização se comporta pela conduta individual dos seus integrantes.Os objetivos organizacionais: são desafiantes; são viáveis; tem prazos definidos; são mensuráveis; são coerentes entre si. O planejamento estratégico deve ter metas e ser fragmentado em fases e pequenos projetos.3. Estrutura da gestão de projetosCaracterísticas dos projetos: Temporalidade: É fundamental controlarmos o tempo por meio de cronogramas de atividades. Exclusividade: os produtos ou serviços originários de um determinado projeto são exclusivos a ele. Progressividade: Um projeto é dividido por fases e as equipes inseridas nessas subdivisões fazem uso de meios e recursos necessários para a sua superação, conduzindo os rumos do projeto para a fase seguinte, até a fase de encerramento definitivo.Características das operações: repetitivas, contínuas, rotineiras e ininterruptas.É recomendável que o projeto seja encerrado de modo formal.Gestor de projetos: capacidade de organização até dos menores e mais insignificantes procedimentos; capacidade de diplomacia para gerir os eventuais conflitos envolvendo pessoas de diversos níveis hierárquicos; visão de conjunto para gerenciar os recursos, o tempo e o andamento das fases; capacidade de compreender a complexidade do projeto, o que ainda fornece subsídios para que o gerente trabalhe, em paralelo ao projeto geral, com vários projetos menores. Ferramentas para gestão: sistema PERT-COM, gráfico de Gantt.Hierarquia das ações:Plano estratégicoPortfólioProgramaProjetoSubprojetoEscritório de projetos (PMO): supervisionar e gerenciar o projeto.Reengenharia é o desenvolvimento de pequenos projetos internos destinados à inserção de novos métodos, atitudes e práticas cotidianas entre os funcionários, a fim de serem obtidas melhorias nas relações.Portfólio é o agrupamento de um conjunto de projetos, ou programas, e outras atividades identificáveis e correlatas, visando atender aos objetivos dos negócios estratégicos.Ciclo de vida do projeto: conceito ou iniciação, planejamento, implementação ou execução, conclusão ou encerramento.São as necessidades dos ambientes interno e externo ao projeto que vão determinar o ritmo a ser seguido em cada fase.Ciclo de vida de produtos: introdução no mercado, crescimento, maturidade e saturação, declínio de vendas.4. Planejamento e controle de projetosO ambiente que envolve os projetos: consolidação da sociedade da informação = aumento da competitividade; mudanças externas = estruturação e desenvolvimento de novos projetos; globalização como realidade; projetos com características inovadoras e necessidades de integração; necessidade de parcerias empresariais (expansão em novos mercados); joint ventures ou aglomerados produtivos (vale do silício – EUA). A importância dos projetos: mercado exigente por inovações nos produtos; alteração nos produtos = elaboração de um projeto; projeto para o lançamento de um novo produto; busca de melhoria nos processos empresariais; mudanças internas nas organizações. A estrutura do projeto: aspectos econômicos; aspectos técnicos; aspectos financeiros; aspectos administrativos; aspectos jurídicos e legais; aspectos do meio ambiente; aspectos contábeis (questões burocráticas e de ordem prática). Etapas de um projeto: 1º passo – realizar um estudo de mercado. 2º passo – abordar os aspectos técnicos: localização e escala do projeto. 3º passo – análise financeira. 4º passo – análise da estrutura administrativa. 5º passo – elaborar as projeções de custos e receitas. 6º passo – avaliação (aprovação, ou não, do projeto). 7º passo – projeto final (elaboração, implantação e operação). 5. Elaboração de projetosElaboração de projetos: estudo preliminar; diagnóstico; análise das informações com vistas à formulação de alternativas (análise SWOT, benchmarking); elaboração de propostas; elaboração final do plano; Construção do documento: descrição do projeto; tamanho do projeto; tamanho e localização; tamanho e recursos; tamanho e aspectos técnicos; otimizando o tamanho do projeto; estrutura básica do projeto; A descrição do projeto: apresentação do projeto; justificativa; objetivos; metas; estudos preliminares para a elaboração do projeto; cronograma; orçamento. 6. Gestão de processos do projetoFluxogramas de processos internos ao projeto: as representações gráficas associadas com cada etapa doprojeto; os processos de um projeto interagem entre si e se relacionam; facilidade para o aperfeiçoamento dos processos; facilidade de serem identificados pontos críticos; facilidade de visualização da sequência e encadeamento das atividades; o registro do processo para futuras análises.Gestão de integração do projeto:Gestão de integração do projetoDesenvolver o termo de aberturaDesenvolver a declaração do escopo preliminarDesenvolver o plano de gestãoOrientar e gerenciar a execuçãoMonitorar e controlar o trabalhoControle integrado de mudançasEncerrar o projetoPlanejamento do escopo: como a equipe define o escopo do projeto; como será desenvolvido o detalhamento do referido escopo; definição da estrutura analítica do referido projeto; verificação e controle deste escopo. Gestão do tempo do projeto: definição das atividades; sequência das atividades; estimativa dos recursos da atividade; estimativa de duração da atividade; desenvolvimento do cronograma; controle do cronograma. Gestão dos custos do projeto: estimativa de custos; orçamentos; controle de custos. Gestão da qualidade do projeto: planejamento da qualidade; realização da garantia da qualidade; realização do controle de qualidade. Gestão dos recursos humanos do projeto: gerenciamento da equipe do projeto; equipe composta por pessoas focadas no término do projeto; o número de pessoas da equipe varia conforme o projeto; a equipe de gestão do projeto é a líder das demais. " }, { "title": "Anotações sobre Fundamentos Matemáticos para a Ciência da Computação", "url": "/posts/fundamentos-matematicos-ciencia-computacao/", "categories": "Estudos-faculdade", "tags": "matemática", "date": "2020-06-19 08:00:00 -0300", "snippet": "​Baseado em Fundamentos Matemáticos para a Ciência da Computação (Gersting).1 Lógica Formal1.1 Sentenças, Representação Simbólica e TautologiasTecnicamente, uma sentença (ou proposição) é uma frase que pode ser apenas verdadeira ou falsa.Conectivos e Valores-VerdadePara enriquecermos nossas conversas não nos limitamos ao uso de simples sentenças. Ao contrário, as combinamos com o uso de conectivos a fim de criarmos sentenças compostas, cujo valor-verdade depende dos valores-verdade de cada sentença que o compõe e dos conectivos usados.Técnicas Construção de tabelas-verdade para wffs compostas Reconhecimento de tautologias e contradições Principais ConceitosAs wffs são representações simbólicas de sentenças.Os valores-verdade de wffs compostas dependem dos valores-verdade de seus componentes e do tipo dosconectivos usados.1.2 Quantificadores, Predicados e ValidadeDefinição: InterpretaçãoUma interpretação de uma expressão envolvendo predicados consiste no seguinte:a. um conjunto de objetos chamados o domínio da interpretação, que deve conter pelo menos um elemento;b. a atribuição de uma propriedade dos objetos do domínio para cada predicado na expressão; ec. a atribuição de um objeto particular no domínio a cada símbolo constante na expressão.Validade:Wffs Proposicionaisl. Verdadeira ou falsa, de acordo com os valores atribuídos aos símbolos proposicionais; Tautologia - verdadeira para todas as atribuições de valores-verdade; Algoritmo (tabela-verdade) para determinar se uma wff é ou não uma tautologia. Wffs Predicativas Verdadeira, falsa ou sem valor-verdade, dependendo da interpretação; Wff válida - verdadeira para todas as interpretações; Não há algoritmo para determinar se uma é ou não válida. Técnicas Determinação do valor-verdade de uma wff predicativa em uma dada interpretação. Tradução de sentenças na língua portuguesa para wffs e vice-versa. Reconhecimento de uma wff válida e a justificação. Reconhecimento de wffs não-válidas e a construção de uma interpretação na qual ela seja falsa ou não tenha valor-verdade Ideias PrincipaisO valor-verdade de wffs predicativas depende da interpretação considerada.Wffs válidas são wffs predicativas que são verdadeiras para qualquer interpretação e, portanto, a validade é uma propriedade inerente à forma da wff propriamente dita.1.3 Lógica ProposicionalArgumentos VálidosEm português, um argumento é normalmente apresentado como uma série de sentenças que podem ser simbolizadas por $P_{1},P_{2},…,P_{n}$ seguidas de uma conclusão Q. O argumento é um argumento válido se a conclusão pode ser deduzida, do ponto de vista da lógica, da conjunção $P_{1}\\wedge P_{2}\\wedge …\\wedge P_{n}$ - em outras palavras, se $P_{1}\\wedge P_{2}\\wedge …\\wedge P_{n}\\to Q$ for um teorema." }, { "title": "Anotações sobre Técnicas de Negociação", "url": "/posts/tecnicas-negociacao/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-06-12 08:00:00 -0300", "snippet": "1. Conceitos introdutórios“Negociação é um processo no qual duas ou mais partes buscam um acordo para determinar o que cada uma delas deverá dar ou ganhar, ou fazer e receber, numa transação entre elas.” Raymond SanerModelos Ganha-perde, Ganha-ganha.A tendência atual no ambiente de negócios é a que procura um relacionamento duradouro, que leve a novas negociações no futuro e mantenha ou melhore o contato entre as partes envolvidas. Quando ambos ganham, tende-se a pensar em dividir ganhos entre as partes envolvidas. Porém, melhor do que isso é que se identifiquem as necessidades de cada uma das partes e que se possa atendê-las, pois nem sempre são conflitantes, podendo inclusive ser complementares.Ninguém entra conscientemente em uma negociação para perder.Se a situação for muito desfavorável, o ganha-ganha pode significar obter o menor prejuízo possível, em situações que são profundamente adversas.Táticas sujas: falcatruas e fragilizações do estado mental.Primeira habilidade do negociador: assertividade.O negociador assertivo é capaz de expressar-se e de recusar, ao mesmo tempo a posição de vítima (submisso) e algoz (agressivo).2. O ConflitoExistem duas reações em relação ao conflito: a reação negativa, que considera o conflito uma coisa ruim e prejudicial, devendo ser evitado a qualquer custo, e a reação positiva que considera o conflito uma forma de aprendizado e enriquecimento, mas sem desconsiderar os resultados negativos de um conflito, procurando, antes, minimizá-los.Como diz Brown (apud HAMPTON, 1991), entre os resultados positivos de um conflito estão: A expansão do entendimento dos assuntos, mobilização dos recursos e energia das partes. Esclarecimento das soluções competitivas – busca criativa de alternativas e, por último, maior habilidade para trabalhar em conjunto no futuro. a) Teoria Mecânica ou ClássicaEsta teoria afirma que o conflito pode ser suprimido com a participação de todas as partes envolvidas na organização. Se o conflito ainda persistir é porque há falhas nas regras da organização ou na postura de algumas pessoas. Nesse caso, devem-se aperfeiçoar as regras ou melhorar a postura das pessoas. Segundo esta teoria, uma empresa deve ter procedimentosprontos para a resolução dos conflitos.b) Teoria das Relações HumanasTendem a considerar os conflitos uma doença a ser curada, partindo de um pressuposto de que os conflitos existem devido a mal-entendidos entre as pessoas.c) Enfoque Gerencial (destinada a empresas e organizações)Baseia-se em duas suposições críticas: Predomínio do conflito – conflito não é patológico e não é resultado de falha nenhuma. Conflito e negociação envolvendo duas situações: Conflitos latentes – oposição permanente entre as partes. Conflitos abertos e ativos – a respeito de problemas específicos. Classificação dos conflitos com base em sua solubilidade: Terminais: quando parece que não há solução, são aqueles conflitos ganha-perde. Paradoxais: que são mais obscuros e que não se pode dizer se são solucionáveis ou não. Litigiosos: que são de fácil solução e que geralmente as duas partes saem ganhando (ganha-ganha). Classificação com base na intensidade: muito intensos ou menos intensos.Natureza dos conflitos: Alguns autores acreditam que um conflito não pode ser definido em uma única dimensão. Com isso, propõem uma classificação dividida em três pontos.Quanto aos comportamentos Falhas conflitantes — falhas que só existem na aparência. Conflitos de opinião — eles provêm de divergências de opinião ou julgamento entre as pessoas envolvidas. Tais diferenças se devem à educação, à cultura ou mesmo pela personalidade das pessoas. Conflitos de interesse — quando há o acordo de opinião, mas a discordância ocorre quanto à distribuição do que está negociado. Pode ser dinheiro ou crédito pelo feito. Conflitos hierárquicos — entre níveis hierárquicos diferentes — na maioria das vezes a solução pende para o lado mais forte. Entre pai e filho, chefe e subordinado etc. Conflitos raciais — diferenças entre raças. Conflitos entre instituições — diferenças entre empresas concorrentes em alguma coisa em comum na sociedade. Podem ser por clientes, funcionários, recursos, matéria prima etc. Conflitos neutros ideologicamente — são conflitos que não levam os envolvidos a uma separação, apenas discordam sobre determinado assunto. Conflitos espontâneos e voluntários — gerados de acordo com a vontade de alguém. Conflitos de posse — ligados à partilha de bens. Quanto aos contrários Conflitos individuais — conflitos entre qualquer tipo de pessoa. Conflitos de igual para igual — são entre vizinhos, familiares ou colegas de trabalho. Quanto aos momentos de ação Sobre os fatos — olhares diferentes sobre os mesmos fatos. Sobre as causas — diante de algum fato incontestável, as pessoas remetem a diferentes causas de tal fato. Sobre os obstáculos — conflitos difíceis de identificar, sobretudo se contêm intenções ocultas. Sobre os objetivos — quando na mesma questão, os envolvidos têm objetivos diferentes. Sobre os meios — quando os meios, estratégias ou táticas diferem entre os envolvidos. Sobre os valores — quando diferem os meios de avaliação (valores éticos, morais, religiosos, políticos etc.). Cinco maneiras ineficazes de se solucionar conflitos: Conquista, Esquiva, Barganha, Band-aid (solução rápida), Role-player.Seis passos essenciais para a resolução de conflitos: Buscar um enfoque de solução de problemas; Saber ouvir; Formular as perguntas certas; Manter a mente aberta; Lembrar que o movimento leva ao progresso; Isolar o problema das pessoas envolvidas. Dica: contar com um mediador.Planejamento da negociaçãoPré-negociação ou Planejamento da Negociação:a) Consciência do conflito - identificação do problema;b) Análise das necessidades – nossas e dos outrosc) Seleção dos objetivos – objetivos e limitesd) Estratégiase) Táticas - o meio pelo qual perseguimos a estratégiaAção – A Negociação em Si:Este passo, que muitos supõem ser a primeira etapa, só deve acontecer após umacuidadosa elaboração da primeira etapa. É, como a própria palavra afirma, o momentode ação do negócio.Pós-Negociação – Avaliação da Negociação: Avaliação da situação Revisão do acordo Início de um novo ciclo Para que a negociação saia do ganha-perde para o ganha-ganha, é necessário que ambas as partes em negociação precisem ter necessidades ainda não satisfeitas. Tais necessidades podem ser espontâneas ou surgir especificamente na ocasião. Então, a pergunta a ser formulada é a seguinte: A outra parte está interessada apenas na questão principal da negociação ou tem outras necessidades?Pirâmide das necessidades de MaslowObjetivos tangíveis e intangíveisEtapas para estabelecer limites: Saber que existem outras opções Conhecer sempre as outras opções Definir o ponto de resistência Lidar com as emoções 5. Estratégias de negociaçãoA estratégia representa a posição ou postura que temos que ter em relação ao interlocutor. Em se tratando de negociações, Saner (2005) enfoca que a estratégia adotada são as posições adotadas no conflito. Assertividade X Cooperação Competição – Alta Assertividade e Baixa Cooperação Colaboração – Alta Assertividade e Alta Cooperação Conciliação – Média Assertividade e Média Cooperação Evitação – Baixa Assertividade e Baixa Cooperação Acomodação – Baixa Assertividade e Alta Cooperação Critérios: O que está em jogo? Equilíbrio de Poder Interesses Comuns Qualidade do Relacionamento Táticas ou Técnicas de Negociação Controle da Agenda: A parte que puder estabelecer a agenda ou, pelo menos, ter alguma influência sobre ela, terá uma vantagem. Limitações de Tempo Uma Breve Interrupção – Fazer um Intervalo Local das Reuniões Limites de Autoridade: a dependência de uma autoridade pode servir como desculpa. O Precedente Falso Meio-Termo: quando a parte teria direito a menos da metade. Impasse: suspeite de situações aparentemente irremediáveis. Manter a Iniciativa Erros Deliberados Mentiras Baseadas em Estatísticas: preste atenção a gráficos e estatísticas elaboradas. Sigilo Quando o Interlocutor Obstrui todas as Tentativas de AcordoRazões para ele usar esta técnica: Não quer fechar o acordo. Cansar você a ponto de você abrir concessões maiores. Fazer você se estressar, se desestruturar e cometer erros. Protelar para aguardar o prazo chegar ao fim e você ter que ceder mais. Fazer você ficar em dúvida. E agora?Se você não está disposto a abandonar a negociação só resta tentar descobrir os motivos pelos quais o interlocutor está fazendo isso.O que fazer? Tire de sua cabeça todas as dúvidas quanto a ser razoável ou não na negociação. Fixe um prazo para finalizar as negociações, em razão do outro lado não demonstrar boa fé. Pode acontecer de o outro lado supor que você está blefando. Se acontecer isso, aborte a negociação imediatamente e diga que só volta a conversar se o outro lado estiver disposto a negociar. Deixe sempre uma abertura para o outro lado te ligar, se acontecer, terá uma vantagem, pois o outro é que tentou te contatar. Pegar ou Largar. Diante disso: Continue falando e ignore o ultimato, se o outro lado não reagir, você saberá que não são sérios. Se a oferta não for tão boa, desista mesmo, mas dê abertura para que eles reconsiderem e façam um novo contato, se fizerem saberá que não são tão rígidos. Invente um concorrente, se eles hesitarem, verá que o ultimato não é tão sério assim, só tome cuidado para não ser apanhado no seu blefe.Para ter maior controle das negociações, evitando ataques inesperados dos interlocutores: Controle a agenda – local e horários. Faça a outra parte fazer a primeira oferta. Faça perguntas que exponham os pontos fracos da proposta deles. Quando responder as perguntas deles, acentue os pontos fortes da sua proposta. Use sua documentação para embasar sua posição e solicite a mesma coisa do outro lado. Dê provas objetivas como testemunho de terceiros. Técnicas para Negociar com Alguém muito Maior do que VocêA primeira ação é conhecer bem seus limites. Defina seu limite e seu ponto de resistência, se o negócio não for bom, infelizmente terá que dizer não.Usando a Surpresa: Acrescente algo inteiramente novo na negociação: “Se não conseguirmos uma melhor negociação, teremos que rever os outros contratos”. Acrescente concorrência: “Recebemos uma oferta inesperada de outra empresa”. Traga um perito para contradizer a posição do outro lado. Demonstre uma mudança de posição repentina. Se o acordo não for fechado, eleve o nível da negociação, traga a direção da empresa para a mesa. Crie um clima de urgência. Evitar Guerra de egosCuidado com o “tenha dó de mim”BlefesSer o Rabugento: quando o interlocutor coloca obstáculos.Como manter o controle das negociações: comparações, documentação, atestados, especialistas, experiência, especializações, demonstrações.Caso você perceba que a reunião não está caminhando de forma como você gostaria, você pode tomar alguma das seguintes atitudes: Um intervalo para um café, almoço ou qualquer outra desculpa. Desvie o foco da discussão para longe do ponto onde você está sentindo o maior problema. Uma concessão se não for tocado mais naquele assunto problemático. Se for um assunto bem técnico, você pode trazer para a negociação um especialista na área, (externo às duas empresas envolvidas) ele vai reforçar os seus pontos. Habilidades e estilos de negociadores Negociadores convencionais: amigáveis, método ganha-ganha.Utilizar questões que terminem abertamenteParafrasear ou reformular o que foi dito pelo outroUsar o silêncioSumarizarExpor sentimentos e emoções Negociadores não convencionais: ganha-perde. Depreciar ou confundir a outra parte.EquívocosExagerosCriar um efeito surpresa por meio de uma mudança inesperadaUsar sarcasmo contra a outra parte para fazê-lo se sentir inferiorSufocar a outra parte com excesso de informações ou questões Habilidades dos Bons NegociadoresNão se Concentre na Visão Errada dos Outros, Concentre-se em Expor as suas Ideias de Forma ConvincenteSempre Deixe Alternativas para a outra ParteFale e OuçaEmpatiaTenha Consciência de que se Negocia o Tempo Todo Estilos de Negociadores Apoiador Orientação: relacionamento, amizade.Forças: amável, compreensivo, sabe escutar, prestativo, espírito de equipe.Fraqueza: perde tempo, evita conflitos, pode ser levado a fingir.Sob tensão: finge concordar, não se manifesta.Para obter apoio: Faz amizades, trabalha para o grupo, busca harmonia.Valoriza: atenção que recebe, ser aceito pelas pessoas.Precisa aprender: autodeterminação e fixação de metas. AnalíticoOrientação: procedimentos, segurança.Forças: sério, organizado, paciente, cuidadoso, controlado.Fraquezas: indeciso, meticuloso, teimoso, perfeccionista.Sob tensão: cala-se, retira-se ou evita conflito.Para obter apoio: mantém-se a par do que acontece, especializa-se.Valoriza: segurança, maior garantia.Precisa aprender: tomar decisões mais rápidas, arriscar mais. CatalisadorOrientação: ideias, novidades.Forças: criativo, entusiasmado, estimulante, persuasivo.Fraquezas: exclusivista, impulsivo, inconstante.Sob tensão: fala alto e rápido, agita-se e explode.Para obter apoio: usa ideias novas, persuade, estimula.Valoriza: cumprimentos recebidos, reconhecimento.Precisa aprender: autodisciplina e moderação. ControladorOrientação: resultados.Forças: decidido, eficiente, rápido, objetivo, assume riscos.Fraquezas: exigente, crítico, impaciente, insensível, mandão.Sob tensão: ameaça, impõe e torna-se tirânico.Para obter apoio: confia na eficiência, em trabalho feito a tempo.Valoriza: resultados, cumprimentos de metas.Precisa aprender: humildade e escutar os outros.Estilo primário e secundário Como negociar com cada estilo Apoiador Como agir, sem enfatizar seus pontos fracos? Procurar agradar de forma demasiada. Ter dificuldades de dizer não. Tornar-se prolixo, utilizando-se de um modo difícil de ser compreendido. Deixar dubiedades quanto ao que realmente pensa e sente. Pode-se utilizar os seguintes pontos fortes do apoiador: Eliminar conflitos. Aumentar competência interpessoal. Pensar na satisfação dos outros. Dar assistência, oferecer apoio às pessoas. Focar no trabalho em grupo. Ser amigo de todos e ser aceito pelo grupo. Analítico Como agir, sem enfatizar seus pontos fracos? Dar atenção demasiada dos detalhes. Adiar tudo na esperança de amanhã fazer melhor. Ser minucioso ao extremo Ser teimoso, maçante. Pode-se utilizar os seguintes pontos fortes do analítico: Obter todos os dados disponíveis (macro). Tomar decisões seguras Ter tempo dedicado à pesquisa, coleta de dados. Considerar mais alternativas para análise. Organizar-se. Estabelecer maior sistematização. CatalisadorComo agir, sem enfatizar seus pontos fracos? Manter-se na parte superficial do problema. Concentrar-se em metas irrealistas, podendo não cumprir o que prometeu. Ser estratosférico. Pode-se utilizar os seguintes pontos fortes do catalisador: Considerar maior rapidez e facilidade na resolução de problemas. Focar em exclusividade e inovação. Singularidade. ControladorComo agir, sem enfatizar seus pontos fracos? Considerar os recursos humanos como meras ferramentas de trabalho. Agir como dominador, faz-se pré-julgamentos. Baixa competência interpessoal. Pode-se utilizar os seguintes pontos fortes do controlador: Ganhar tempo, dinheiro, economizar. Vencer os outros. Atingir metas, resultados. Agir sozinho, ficar independente. Cumprir o dever. Outra Abordagem Sobre Estilo O Bulldog Negociam utilizando estilo agressivo e dominador. Tendem a encarar a negociação como uma confrontação de vontades. Para eles a vitória é mais importante do que a própria negociação. Afirmam sua“superioridade” levando vantagem sobre os outros. A RaposaAs pessoas com este perfil tendem a agir a partir de uma mentalidade reservada emanipuladora. Em semelhança aos bulldogs, as raposas também querem levarvantagem na negociação, porém usam outras técnicas, desta vez mais dissimuladas. O Veado Optam por demonstrar um estilo passivo e conciliador, sem procurar fazer ondasou antagonizar qualquer pessoa. Temem as situações de conflito ou confrontação, ao ponto de evitar este tipo desituação. Quando não têm como fugir, terminam aceitando negócios propostos aelas por pessoas mais agressivas. Quando decidem negociar, buscam apaziguamento de modo a não incomodar aninguém envolvido na negociação. Deixam a outra parte encarregada de ditar e controlar o processo da negociação. Preferem ocultar se atrás de substitutos como sócios da empresa, agentes, representantes e intermediários, que efetuam toda a negociação por eles. Construtor de negócios Possuem uma ideia clara dos seus interesses nos negócios e como satisfazê-losatravés do uso de diversas opções. Acreditam na negociação dentro da zona de conforto como forma dedesenvolver confiança e abertura com a outra pessoa, visando parcerias de longoprazo. Como qualquer pessoa, eles podem não ser completamente altruístas. Elesgostam de ver você ter sucesso, mas também querem ter seu próprio sucesso. Os construtores de negócios acreditam em suas habilidades para conseguir fazerbons negócios sem ter de se rebaixar utilizando táticas dos bulldogs ou dosraposas.3. Comportamento na negociaçãoA implementação é a etapa onde a negociação de um produto com certo grau de complexidade envolve dois elementos fundamentais: preço e entrega. Evite revelar informações desnecessárias. Limite o número de pessoas na roda. Trate o processo de negociação distinta e separadamente da implementação. Prenda-os logo no início e com frequência. Se você não tem nada de bom a dizer, não diga nada. Mantenha-os desequilibrados. Crie sanções rígidas para garantir o desempenho deles. Comportamentos mais adequados na hora da negociação: Evite expressões irritantes. Interrupção com uma contraproposta. Evite situação ataque/defesa. Use linguagem preparatória. Escute com atenção e recapitule o que já foi acordado. Utilize-se de perguntas na medida certa. Expresse seus sentimentos para trazer mais confiança. Use poucos e bons argumentos 4. Como lidar com objeçõesObjeção é um meio de resistir à influência de outra pessoa, neste caso, do negociador.Os pretextos são desculpas mal formuladas, com esquivas, sem precisão; às vezes, são apresentados no início da negociação, ou então pouco antes da sua conclusão, para evitar a decisão.As objeções sinceras aparecem de forma clara e objetiva, são percebidas como naturais e bem formuladas, e vêm à tona no decorrer da negociação.Quando qualquer uma das outras partes diz não, sempre está se referindo a um determinado detalhe da proposta, implicitamente solicitando para negociar mais sobre os pontos por ele negados.O bom negociador deve encarar que uma pessoa que cria uma objeção sobre um ponto qualquer, certamente tem interesse no fechamento do negócio. Se não há interesse, a pessoa fala: “Não obrigado, não estou interessado!”. Mas se ela ficou, é porque quer o acordo.Há três passos importantes no tratamento e eliminação de objeções: Acate a objeção; Focalize a objeção fazendo perguntas; Elimine a objeção com argumentos sólidos. A objeção mais temível é o preço. A objeção mais radical é o desinteresse. A objeção mais genérica se refere ao gosto pessoal. A objeção mais vaga é a divagação.O fechamento do negócio: pistas físicas e faladas.Técnicas mais eficazes de fechamento: Técnica do Único Obstáculo, Técnica da Escolha de Alternativas, Técnica de Supor e Assumir o Fechamento, Técnica da Imposição do Fechamento, Técnica do Fechamento Emocional.5. Negociações na empresaO que um gerente precisa fazer: Esclareça o propósito da negociação. Tenha uma visão ampla de quem são os stakeholders. Instrua os seus negociadores a expressarem seus receios sobre as negociações que têm pela frente. Exija transparência nos comprometimentos dados aos clientes e recebidos. Certifique-se de que os negociadores sabem que o negócio só está concluído após a implementação ou entrega final do produto. Instaure procedimentos de preparação para as negociações. Receba bem os problemas. Oriente seu processo de negociação para a implementação. Certifique-se que a equipe de negociadores tem todas as ferramentas adequadas ao serviço. Crie um kit de ferramentas para os negociadores e certifique-se de que seja usado. Incorpore o estabelecimento de precedentes no seu caderno de estratégias. Encoraje o tratamento de riscos fornecendo ferramentas de administração de riscos. Aplique treinamentos constantes. Instaure a mentalidade certa para o seu negócio. Meça os resultados comerciais críticos. Use recompensas e penalidades. Faça o que diz. Acerte a estrutura da empresa para a cultura organizacional adequada. Processo DAN de venda: Dinheiro, Autoridade e Necessidade.6. Ética nas negociações Maior cobrança sobre os empresários em relação à responsabilidade socioambiental e econômica. Líderes e gerentes sem conhecimento das características básicas humanas. Começa-se a ter consciência de que produtividade e qualidade de vida dependem uma da outra. Cultura das organizações passou a absorver melhor as questões éticas. As habilidades internas trazem maior vantagem competitiva. Há um distanciamento entre os valores da organização e os valores da sociedade. " }, { "title": "Anotações sobre Algoritmos", "url": "/posts/introduction-algorithms/", "categories": "Estudos-faculdade", "tags": "algoritmos, lógica", "date": "2020-06-05 08:00:00 -0300", "snippet": "Baseado no livro: Introduction to Algorithms (Cormen; Leiserson; Rivest; Stein)1 O papel dos algoritmos na computaçãoCORMEN, Thomas H.; LEISERSON, Charles E.; RIVEST, Ronald L.; STEIN, Clifford. Algoritmos: teoria e prática. 3ª ed. Rio de Janeiro: Elsevier, 2012.Um algoritmo é qualquer procedimento computacional bem definido que toma algum valor ou conjunto de valores como entrada e produz algum valor ou conjunto de valores como saída. Portanto, um algoritmo é uma sequência de etapas computacionais que transformam a entrada na saída.Também podemos considerar um algoritmo como uma ferramenta para resolver um problema computacional bem especificado.Em geral, uma instância de um problema consiste na entrada.Uma estrutura de dados é um modo de armazenar e organizar dados com o objetivo de facilitar acesso e modificações.2 Dando a partidaOrdenação por inserçãoUm algoritmo eficiente para ordenar um número pequeno de elementos.INSERTION-SORT(A)for j = 2 to A.comprimento\tchave = A[j]\t//Inserir A[j] na sequência ordenada A[1...j-1].\ti=j-1\twhile i&gt;0 e A[i]&gt;chave\t\tA[i+1]=A[i]\t\ti=i-1\tA[i+1]=chaveSe o arranjo estiver ordenado em ordem inversa — ou seja, em ordem decrescente —, resulta o pior caso.Análise de Algoritmos· Analisar um algoritmo significa prever os recursos de que o algoritmo necessita. Ocasionalmente, recursos como memória, largura de banda de comunicação ou hardware de computador são a principal preocupação, porém mais frequentemente é o tempo de computação que desejamos medir. Em geral, pela análise de vários algoritmos candidatos para um problema, pode-se identificar facilmente um que seja o mais eficiente. Essa análise pode indicar mais de um candidato viável, porém, em geral, podemos descartar vários algoritmos de qualidade inferior no processo.· O tempo de execução do algoritmo é a soma dos tempos de execução para cada instrução executada; uma instrução que demanda ci passos para ser executada e é executada n vezes contribuirá com cin para o tempo de execução total.· O tempo de execução do pior caso de um algoritmo estabelece um limite superior para o tempo de execução para qualquer entrada. Conhecê-lo nos dá uma garantia de que o algoritmo nunca demorará mais do que esse tempo. Não precisamos fazer nenhuma suposição sobre o tempo de execução esperando que ele nunca seja muito pior.· Para alguns algoritmos, o pior caso ocorre com bastante frequência. Por exemplo, na pesquisa de um banco de dados em busca de determinada informação, o pior caso do algoritmo de busca frequentemente ocorre quando a informação não está presente no banco de dados. Em algumas aplicações, a busca de informações ausentes pode ser frequente.· Muitas vezes, o “caso médio” é quase tão ruim quanto o pior caso. Suponha que escolhemos n números aleatoriamente e aplicamos ordenação por inserção.· Em geral, consideramos que um algoritmo é mais eficiente que outro se seu tempo de execução do pior caso apresentar uma ordem de crescimento mais baixa. Devido a fatores constantes e termos de ordem mais baixa, um algoritmo cujo tempo de execução tenha uma ordem de crescimento mais alta pode demorar menos tempo para pequenas entradas do que um algoritmo cuja ordem de crescimento seja mais baixa.Projeto de Algoritmos· Muitos algoritmos úteis são recursivos em sua estrutura: para resolver um dado problema, eles chamam a si mesmos recursivamente uma ou mais vezes para lidar com subproblemas intimamente relacionados. Em geral, esses algoritmos seguem uma abordagem de divisão e conquista: eles desmembram o problema em vários subproblemas que são semelhantes ao problema original, mas de menor tamanho, resolvem os subproblemas recursivamente e depois combinam essas soluções com o objetivo de criar uma solução para o problema original.· O paradigma de divisão e conquista envolve três passos em cada nível da recursão: Divisão do problema em determinado número de subproblemas que são instâncias menores do problema original. Conquista os subproblemas, resolvendo-os recursivamente. Porém, se os tamanhos dos sub-problemas forem pequenos o bastante, basta resolver os subproblemas de maneira direta. Combinação as soluções dadas aos subproblemas na solução para o problema original. · O algoritmo de ordenação por intercalação a seguir obedece rigorosamente ao paradigma de divisão e conquista. Intuitivamente, ele funciona do modo ilustrado a seguir. Divisão: Divide a sequência de n elementos que deve ser ordenada em duas subsequências de n/2 elementos cada uma. Conquista: Ordena as duas subsequências recursivamente, utilizando a ordenação por intercalação. Combinação: Intercala as duas subsequências ordenadas para produzir a resposta ordenada. MERGE(A, p, q, r)n1=q-p+1n2=r-qsejam L[1..n1+1] e R[1..n2+1] novos arranjosfor i=1 to n1\tL[i]=A[p+i-1]for j=1 to n2\tR[j]=A[q+j]L[n1+1]=infiniteR[n2+1]=infinitei=1j=1for k=p to r\tif L[i]&lt;=R[j]\t\tthen A[k]=L[i]\t\t\ti=i+1\t\telse A[k]=R[j]\t\t\tj=j+1MERGE-SORT(A, p, r)if p&lt;r\tthen q=[(p+r)/2]\t\tmerge-sort(A,p,q)\t\tmerge-sort(A,q+1,r)\t\tmerge(A,p,q,r)O bubblesort é um algoritmo de ordenação popular, porém ineficiente. Ele funciona permutando repetidamente elementos adjacentes que estão fora de ordem." }, { "title": "Anotações sobre Marketing digital", "url": "/posts/marketing-digital/", "categories": "Estudos-faculdade", "tags": "marketing", "date": "2020-05-29 08:00:00 -0300", "snippet": "FundamentosPhilip KotlerIdentificar e satisfazer necessidadesMarketing é um processo social pelo qual se cria valor e se constrói relacionamentos baseados em trocas.Processo de Marketing: criar valor (entender necessidades; elaborar estratégia; programa de marketing; construir relacionamento) - capturar valor.· Entender necessidades:· Necessidades, desejos e demandas:As necessidades são aquelas exigências humanas básicas. O marketing não cria necessidades.Os desejos se referem a necessidades dirigidas a produtos que sejam capazes de satisfazê-las.Demanda define se vai existir mercado para o produto. Só funciona se o público-alvo tiver condições de adquirir o produto.· Produtos, serviços e experiências:Produto é qualquer coisa capaz de satisfazer uma necessidade/desejo e normalmente está relacionado com a posse física de algo.Miopia de marketing: erro de prestar mais atenção aos produtos específicos que uma empresa oferece do que aos benefícios e à experiência.Serviço não está relacionado com posse de algo.Experiência é algo que se relaciona diretamente com sentimentos gerados por produtos e serviços. Valor e satisfação:Os clientes criam expectativas com relação ao valor e a satisfação de várias ofertas e fazem sua escolha de acordo com essas expectativas.Valor não é apenas preço! Valor é mais relacionado com a percepção do seu cliente em relação ao seu produto.Clientes satisfeitos compram novamente e comentam com outras pessoas. Trocas e relacionamentos:O Marketing ocorre quando as pessoas querem satisfazer suas necessidades e seus desejos por meio da troca.Em teoria o marketing busca uma estratégia onde as partes envolvidas tenham uma relação win-win.Marketing consiste em ações que levem à construção e manutenção de relacionamentos de troca com o seu público-alvo.O objetivo é mais do que simplesmente atrair novos clientes; é retê-los e expandir os negócios. Mercados:Um Mercado é o conjunto de compradores reais e potenciais de um produto.Todos eles compartilham de um mesmo conjunto de desejos e necessidades, que podem ser satisfeitos pelo seu produto.· Elaborar estratégiaA Estratégia de Marketing é o planejamento de como chegaremos ao cliente, criando o valor esperado e construindo fidelidade.Quais são os objetivos - Qual será o nosso mercado alvo - Qual é a nossa proposição de valor - Quais são os recursos disponíveis para tanto.A Estratégia determina como os recursos serão alocados para atingir o mercado definido, considerando todas as suas características e assim chegar ao objetivo. Iniciaremos a estratégia sempre analisando os ambientes (macro, micro, ambiente interno).Matriz SWOTUVP - Proposta Única de Valor - Por que eu deveria comprar sua marca em vez da do concorrente?· Programa de MarketingO Programa coloca essa estratégia em prática para que a entrega de valor seja exatamente aquela que foi planejada no passo anterior.Tudo isso é implantado através do que chamamos de Mix de Marketing ou Composto de Marketing. Produto - Preço - Praça e Promoção.4 Cs do consumidor: Cliente - Custo - Conveniência - Comunicação.· Construir RelacionamentoÉ possível capturar valor sem se preocupar com relacionamento. Mas é importante construir e gerenciar relacionamentos duradouros e lucrativos.O Customer Equity é o valor capturado ao longo do tempo de todos os clientes da empresa.7 dicas:· Forneça uma boa experiência;· Conheça bem o seu cliente;· Segmentação é muito importante;· Emoções vendem bem;· Seu público faz parte da criação;· Incentivar o retorno;· Monitore resultados.· Capturar ValorMarketing DigitalMétricas - Custo - Feedback· Marketing de conteúdoSão seres humanos sendo úteis para outros. Trata-se de conteúdo envolvente, compartilhável e, acima de tudo, focado em ajudar. Faz os clientes descobrirem que seu produto/serviço é aquele que vai resolver os problemas deles.Inbound Marketing - Marketing de atração: Conquistar novos clientes, gerar mais vendas e criar maior autoridade com o público-alvo.Seus clientes não se preocupam com você, seu produto ou serviço. Eles se preocupam com eles mesmos, seus desejos e necessidades. Marketing de Conteúdo cria informações interessantes e fazem clientes realmente prestarem atenção em você.Público-alvo - Persona (cliente ideal)Personas: São representações fictícias dos seus clientes ideais. Incluem dados demográficos, comportamentais, além de considerar sua história, motivações, objetivos, desafios e preocupações.Formatos: texto (blog, wiki, f.a.q., e-book, newsletter, case de sucesso, review e tutorial), imagem (infográfico, meme, post em redes sociais), vídeo, áudio (podcast, áudio post, tutorial e review) e outros (SMS, WhatsApp, games, aplicativos).Dicas:· Objetivo definido;· Estratégia;· Tenha um site;· Conteúdo interessante;· Adaptação de conteúdo;· Indexação SEN SEO;· Divulgue para o seu nicho;· Acompanhe sua métrica;· Automação de Marketing;· Prepare-se.· Marketing de busca· Redes de Ads· CRM· Analytics· MobileAutomação de MarketingMautic - https://www.mautic.org/" }, { "title": "Anotações sobre Teste de Software", "url": "/posts/teste-software/", "categories": "Estudos-faculdade", "tags": "testes", "date": "2020-05-22 08:00:00 -0300", "snippet": "IntroduçãoDanos dos Bugs :Prejuízos Financeiros e de Imagem Empresas / Organizações Pessoas Atrasos Constrangimentos Perda de Confiança / Vendas Perda ou Supressão de Direitos   Risco de Vida e Acidentes Governos Meio Ambiente Vulnerabilidade de Informações Alertas Atrasados Decisões Estratégicas Incorretas Desperdício de Recursos Derrotas Militares Poluição Os 7 fundamentos do Teste (ISTQB): Teste Demonstra a Presença de Defeitos, Mas Nunca a Sua Ausência; Teste exaustivo não é possível (é necessário avaliar riscos e prioridades); Teste antecipado; Agrupamento de defeitos (os bugs estão distribuídos de forma heterogênea); Paradoxo do pesticida (quanto mais realiza o mesmo conjunto de testes, menos defeitos; inove regularmente os testes); Teste depende do contexto; A ilusão da ausência de erros (o foco é atender a necessidade do usuário). A tolerância a falhas muda em razão do meio.Regra 10 de Myers: Quanto mais cedo encontrarmos um defeito, mais barata será sua identificação e correção.Diferença entre teste (produto) e QA (processo): Testes devem ser integrados como uma das atividades de garantia da qualidade.Softwares são feitos por pessoas para pessoas. Pessoas cometem erros (enganos), que produzem defeitos (bugs) no código, em um software ou sistema ou em um documento. Devem ser chamados de ocorrência, ou incidente, para evitar atritos com as pessoas.Se um defeito no código for executado, o sistema falhará ao tentar fazer o que deveria (ou, em algumas vezes, o que não deveria), causando uma falha.Nem todos os defeitos causam falhas (a falha só existe quando o defeito é executado). Falhas geram insatisfação com a qualidade.Tipos de testes baseados na IEC/ISO 25010 (Substitui a ISO 9126; conhecida como SQuaRE): Adequação funcional (funcionalidade); a. Completude funcional; b. Correção funcional; c. Apropriado a funcionalidade; Usabilidade; a. Reconhecibilidade: facilitar que o usuário reconheça elementos e componentes; b. Aprendizibilidade: facilitar o aprendizado do usuário; c. Operabilidade: facilitar a operação e navegação; d. Proteção contra erro do usuário; e. Estética (da interface do usuário); f. Acessibilidade: facilitar o acesso a todas as pessoas; Compatibilidade: a. Coexistência: facilidade de coexistir; b. Interoperabilidade: facilidade de comunicar; Confiança/confiabilidade: a. Maturidade: perceber e prevenir a falha antes que aconteça; b. Disponibilidade: manter-se a disposição de usuários e sistemas; c. Tolerância a falhas: perceber e compensar as falhas em tempo real; d. Recuperabilidade: recuperar-se de falhas e travamentos; Eficiência de desempenho: a. Comportamento em relação ao tempo; b. Utilização de recursos; c. Capacidade: de atender transações e usuários; Manutenibilidade: a. Modularidade: organizado em módulos; b. Reusabilidade: facilidade em reutilizar; c. Analisabilidade: facilidade de analisar; d. Modificabilidade: facilidade de modificar; e. Testabilidade: facilidade de testar; Portabilidade: a. Adaptabilidade: facilidade de adaptar; b. Instalabilidade: facilidade de instalar e desinstalar; c. Substituibilidade: facilidade de substituir; Segurança: a. Confidencialidade; b. Integridade (modificações apenas por usuário autorizado); c. Não repúdio (garantir a identidade do usuário); d. Responsabilidade: Auditável e prestação de contas; e. Autenticidade; Testes de regressão automatizados: garantir que correções e alterações não estão quebrando outras funções que já existiam.Planejamento de TestesDimensões do planejamento: Escopo, Cronograma, Qualidade, Custo, Pessoas, Riscos, Comunicação, Aquisições, Fornecedores.MVP: Mínimo Produto Viável. MVQ: Mínima Qualidade Viável.Princípio de Pareto.Gráficos de Pareto para Testes: reclamações por módulo; módulos mais usados; análise de risco; falhas por módulo; defeitos por módulo (averiguados por você).Produtos cabeça (hits/populares) e cauda longa (produtos de nicho). Testes combinatoriais - Pairwise pairwise.yuuniworks.comQuadrantes de teste:Pirâmide de teste: Testes unitários &gt; teste de serviços &gt; testes de UINegociando um acordo flexível e de valor: valor para os negócios; antecipar mudanças; acordar as trocas (trade off).Plano de teste: IEC/ISO 29119-3 Padrão de Documentação de Teste.Estória dos usuários: independente; negociável; valioso; estimável; pequeno; testável (critérios de aceite; mensurável).Pre-game: inception; planejamento do produto; Sprint do planejamento; reuniões de grooming.Épicos: estória grande - longa duração - grande entrega.Features: momento intermediário entre estória e épico. Funcionalidades mais visíveis, que podem depender de várias estorias.Análise de riscos: feita com o time; Identificação - Análise - Priorização (probabilidade x impacto) - Estratégia de tratamento - Acompanhamento.Matriz de risco: Nome do risco - Probabilidade - Impacto - R=PxI - Estratégia - Como? - Responsável - ReavaliarPlanning Poker: Dinâmica de grupo com cartas. Facilita discussões e votações.Histórico dos Riscos: ajuda a tomar boas decisões e cria uma cultura de preservar.Análise de Pareto: Priorizações. Baseia-se na existência de restrições.Priorização por Impulso: Seguir a ordem do maior para o menor.Priorização por Atração: Um item priorizado atrai menos priorizados que podem ser resolvidos juntos.Análise da cauda longa: Pairwise e Matriz Ortogonal. Análise, Modelagem e ImplementaçãoAnálise: Conjunto de testes - Suite de teste ou cenárioModelagem: Casos de teste são caros e demorados; indicados apenas para funções críticas e complexas. Mapas mentais para mapear as funcionalidades pode ser mais agil. BDD; Fichas de teste e diagramas.Testes WebTrês maiores problemas da testagem web: identificação dos elementos; sincronismo; programação exótica.Tipos de aplicações web: site, web app.Responsividade; Performance; Acessibilidade; Informação para tomada de decisão.Ferramentas: Google Analytics, Crazy Egg (mapa de calor e teste A/B). seositecheckup.com Prioridade Fluxo Cenários   1 Validações básicas Lista produtos na página principal 2 Validações básicas Validar carrinho vazio 3 Fluxo padrão Compra de um produto 4 Funcionalidade adicionais Contate-nos Java JDK + Eclipse + Browser + WebDriver do BrowserMaven + Selenium Criar um novo Maven project no Eclipse, verificar a configuração do compilador e do jdk do projeto; Editar o arquivo pom.xml (properties, dependencies, build); Dependencies: a. JUnit (JUnit Jupiter (Aggregator)); b. Hamcrest; c. Selenium (Selenium Java); Criar pacotes de teste em src/test/java; Criar os testes em classes dentro dos pacotes; O Selenium permite capturar a tela para registrar os testes.Cucumber: ferramenta voltada para BDD (Behavior Driven Development);Utiliza a linguagem Gherkin, que suporta inclusive o português. Viabiliza a execução automatizada das especificações.Plug-in do Eclipse." }, { "title": "Anotações sobre Gestão de pessoas", "url": "/posts/gest%C3%A3o-pessoas/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-05-15 08:00:00 -0300", "snippet": "Remuneração e salárioHierarquia das Necessidades Humanas de Maslow Necessidades Fisiológicas Necessidades de segurança Necessidades de Associação Necessidades de Estima Necessidade de Auto RealizaçãoA remuneração compreende o conjunto dos vencimentos que o empregado percebe por sua prestação de serviços, incluindo aí o salário como parte principal.O salário juntamente com os benefícios sociais obrigatórios e espontâneos, mais os diversos adicionais como as horas extras, o adicional noturno, o adicional por insalubridade ou periculosidade, as comissões, as gratificações, etc. formam a remuneração.Remuneração X RecompensaCurto prazo – remuneração variável: Gratificação; Prêmios e Bônus; Participação nos lucros ou resultados; Comissões.Incentivos de longo prazo: Participação Acionária;Estrutura e Política de cargos e saláriosA gestão de cargos e salários ocupa uma posição-chave no recrutamento e manutenção dos recursos humanos das empresas, pois estas precisam propiciar um ambiente de motivação e produtividade, eliminando as incoerências e distorções que possam causar desequilíbrios salariais ou a insatisfação das pessoas.A administração de cargos e salários deve ser feita considerando três itens importantes: a relatividade interna; a situação de mercado; o equilíbrio orçamentário da empresa.Descrição de cargosCargo é o nome que se dá a posição que uma pessoa ocupa dentro da empresa, ou do organograma do seu empregador, já a função é o conjunto de tarefas e responsabilidades relacionadas a esse cargo, ou seja, é um conjunto de elementos que requer o esforço humano para determinado fim, como por exemplo, apertar o parafuso, emitir a requisição, entre outros.Política de Cargos e Salários: Objetivo, premissas ou princípios. Aplicação. Definição das competências organizacionais e individuais, se for o caso. Carreira. Estrutura de cargos e seus eixos (liderança, administrativo, técnico, operacional, comercial). Critérios para contratação – promoção, reajustes salariais e manutenção do sistema.Sistema de participação nos lucros e resultadosCarreira e avaliação de desempenhoCarreira pode ser definida como os roteiros pré-estabelecidos de posições funcionais, cargos e salários.Avaliação de desempenho - feedbackSistemas de Avaliação de Desempenho: escalas gráficas; Método da Escolha Forçada; Método de Autoavaliação; Método da Avaliação por Resultados; Métodos Mistos; Avaliação 360°.Clima e cultura organizacionalCultura organizacional representa as normas informais e não escritas que orientam o comportamento dos membros de uma organização no dia a dia, e que direcionam suas ações para o alcance dos objetivos organizacionais. Formada por: valores, ritos, tabus, mitos.Relações sindicaisA estrutura sindical no Brasil se apresenta em 3 níveis:a) O Sindicato – abrangência local, municipal ou regionalb) A Federação – grau intermediário, abrangência estadualc) A Confederação – grau superior, federalPlanejamento estratégico de RHPrincipais diferenciais competitivos: Diminuição dos custos relativos à gestão e manutenção de pessoas; Motivação, iniciativa, produtividade e potencial criativo em patamar superior; Imagem positiva e reputação da empresa; Maior rentabilidade e sustentabilidade da empresa;Indicadores de desempenho: índice de rotatividade; índice de absenteísmo (voluntário, compulsório, legal, por patologia profissional, por doença); índice de retenção 90 (dias); índice de horas extras; grau de escolaridade; índice de treinamento; diversidade; taxa de frequência de acidentes; grau de terceirização.Recrutamento e seleção• Recrutamento: É o conjunto de procedimentos que visa atrair candidatos qualificados para ocupar cargos dentro da organização.• Seleção: É o processo de escolha, entre os candidatos recrutados, visando o atendimento do perfil necessário para o preenchimento das vagas existentes na organização.Formulário de Requisição de Pessoal: O nome do cargo; A faixa salarial; O tipo de contrato; A data desejada para a admissão; A descrição resumida do cargo; Os pré-requisitos necessários: experiência, escolaridade, informática,idiomas, cursos específicos, etc. As competências genéricas e específicas segundo descrição de cargos,exemplos:• Iniciativa;• Agilidade;• Comunicação clara e objetiva;• Conhecimento de matemática financeira;Premissa de uma boa entrevista: \"o comportamento passado prediz o comportamento futuro\".Orientações antes da entrevista:a) Conheça e monitore seus preconceitos;b) Estruturação do roteiro de perguntas;Procedimentos durante a entrevista:a) Crie um clima de empatia;b) Tenha um comportamento de imparcialidade;c) Cuidado com o comportamento não verbal;d) Faça anotações;e) Mantenha o controle da entrevista.Ferramentas adicionais:• Teste práticos e/ou teóricos para avaliar conhecimento técnico, destreza manual, habilidades, etc.• Estudos de casos – o candidato deve analisar o caso proposto e dar uma solução à questão em um determinado espaço de tempo. Aí avaliamos acapacidade de análise e tomada de decisão, visão sistêmica, utilização eficaz do tempo, resistência ao stress, dentre outras competências;• Simulações de situações-problema – práticas ou teóricas, para serem resolvidas pelo candidato;• Dinâmica de grupo: situação onde podemos observar e comparar as diferentes atitudes e comportamentos dos candidatos pré-selecionadosem relação às competências desejadas;• Testes para análise de perfil – existe uma infinidade de ferramentas. A opção por uma ou outra terá que estar vinculada à estratégia de R&amp;S;• Testes psicológicos. Estes só podem ser aplicados por profissionais credenciados.Treinamento e QualificaçãoO Treinamento é qualquer atividade que contribua para tornar uma pessoa apta a exercer sua função ou atividade, para aumentar a sua capacidade para exercer melhor essas funções ou atividades, ou para prepará-la para exercer de forma eficiente novas funções ou atividades.O foco do Treinamento é muito mais no presente, nas necessidades atuais ou a médio prazo.O Desenvolvimento tem foco mais voltado ao no futuro, no desenvolvimento de competências para assumir outros cargos, riscos ou responsabilidades. Está mais ligado à progressão na carreira.Processos avançadosProcesso de Saúde Ocupacional e Segurança do Trabalho - PCMSO: Programa de Controle Médico de Saúde Ocupacional - PCMSO Programa de Prevenção de Riscos Ambientais – PPRA Perfil Profissiográfico Previdenciário – PPP Programa de Alimentação do Trabalhador - PAT Comissão Interna de Prevenção de Acidentes - CIPA. Comunicação Interna / Endomarketing e os Processos Avançados Honesta / Verdadeira; Transparente; Ágil; Relevante; Consistente. Princípios da comunicação interna: diálogo; envolvimento dos colaboradores; canais variados de informações; efetividade das informações.Desenvolvimento e qualificação: universidade corporativa.Ferramentas para atração e retenção de talentosGestão da diversidade e a inclusãoGestão do conhecimento e do capital intelectualCapital intangívelResponsabilidade Social Empresarial e Ética empresarialCaracterísticas da responsabilidade social corporativa: é plural; distribuída; sustentável; transparente.Governança Corporativa: é o sistema que visa assegurar aos sócios-proprietários o governo estratégico da empresa e a efetiva monitoração da diretoria executiva, criando um conjunto eficiente de mecanismos, tanto para incentivos como de monitoração, a fim de assegurar que o comportamento dos executivos esteja alinhado aos interesses dos stakeholders.Qualidade de vida no trabalho (QVT): Não confundir QVT com política de benefícios, nem com atividade festivas de congraçamento, embora essas sejam importantes em uma estratégia global.Gestão de Competências: É a forma como a organização planeja, organiza, desenvolve, acompanha e avalia as competências necessárias ao seu negócio.Gestão por Competências: É um plano de desenvolvimento profissional cujo foco deixa de ser a função/cargo e passa a ser os conhecimentos, as habilidades e os comportamentos individuais, valorizando o trabalho em equipe e a busca contínua de melhores resultados." }, { "title": "Anotações sobre Contabilidade aplicada", "url": "/posts/contabilidade-aplicada/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-05-01 08:00:00 -0300", "snippet": "1. Contabilidade e seus conceitosContabilidade é a ciência que se ocupa do registro, por meio de técnicas próprias, dos atos e fatos da administração das entidades econômico-financeiras, que possam ser expressos monetariamente, possibilitando o controle, o estudo e a interpretação das variações do patrimônio da empresa, bem como fornecendo informações a todos os usuários interessados.5 funções: registrar; organizar; demonstrar; analisar; acompanhar.4 técnicas: escrituração; demonstrações contábeis; auditoria; análise.Classificações e nomenclaturas: Contabilidade pública ou privada; Contabilidade comercial ou empresarial; industrial ou contabilidade de custos; bancária; pública; de cooperativa; de seguros; gerencial. Outras áreas: fiscal; gerencial; financeira; de auditoria; pericial contábil; atuarial. Pessoa jurídica é a entidade abstrata que possui direitos, obrigações e patrimônios próprios, distintos dos das pessoas físicas, aspectos que a caracterizam como se tivesse vida própria, sendo constituída com o objetivo de explorar organizadamente uma atividade qualificada como comum.A contabilidade como ciência estuda o patrimônio das entidades econômico-administrativas - organizações que reúnem: pessoas, patrimônio, titular, ações administrativas e fim determinado. Podem ser divididas em instituições (não visam lucro) ou empresas.Empresários e SociedadeSociedades simples ou empresárias; em nome coletivo, em comandita simples, limitadas, anônimas ou companhia, em comandita por ações, cooperativa.2. PatrimônioObjeto de estudo da contabilidade - conjunto de bens, direitos e obrigações de uma pessoa física ou jurídica, sendo sempre suscetíveis de avaliação monetária, ou seja, sempre poderão ser transformados em moeda corrente.Bens - toda e qualquer coisa - de troca, de uso e de consumo - Materiais móveis ou imóveis, imateriais.Direitos: todos os valores que a empresa tem a receber de terceiros, provenientes de suas transações comerciais de venda a prazo.Obrigações: todos os valores que a empresa tem o compromisso de pagar a terceiros.Representação gráfica do patrimônio - elementos positivos - ativos (bens e direitos); elementos negativos - passivo (obrigações).Aspectos qualitativos do patrimônio: Ativo Bens Caixa Banco conta Movimento Mercadorias Veículos Máquinas Móveis Imóveis Direitos Clientes Duplicatas a receber Promissórias a receber Aluguéis a receber Passivo Obrigações Fornecedores Salários a pagar Financiamentos a pagar Impostos a pagar Aspecto quantitativo do patrimônioBalanço patrimonial: Ativo Passivo Bens - Direitos Obrigações - Patrimônio líquido (capital investido na empresa) Situações patrimoniais: positiva, negativa ou nula.Equação fundamental da contabilidade: Ativo=Passível exigível (obrigações) + Patrimônio líquido (capital próprio)Situação patrimonial positiva: ativo maior que o passível exigível (maior que zero); ativo maior que o passível exigível (igual a zero).Situação patrimonial negativa: quando o patrimônio líquido é negativo e é representada quando o ativo é menor que o passivo exigível.Situação patrimonial nula: ativo é igual ao passível exigível.Origem e aplicação dos recursos: o passivo representa a origem de recursos; o ativo representa a aplicação de recursos.3. ContasConta é o nome técnico dado aos elementos patrimoniais (bens, direitos, obrigações e patrimônio líquido) e aos elementos de resultado (despesas e receitas). Contas patrimonial e de resultado.Contas patrimoniais: Ativo (circulante/movimentação rápida, não circulante [realizável a longo prazo, investimentos, imobilizável e intangível]). Passivo (circulante, não circulante e patrimônio líquido).Patrimônio líquido: capital social, reservas de capital, reservas de lucro, ajustes de avaliação patrimonial, ações em tesouraria, lucro ou prejuízo acumulado (LPA).Contas retificadoras do patrimônio: demonstram uma condição específica de redução do patrimônio. Contas retificadoras do ativo circulante: perda com clientes; Contas retificadoras do ativo não circulante: depreciação acumulada (bens imobilizados), amortização acumulada (bens intangíveis), exaustão acumulada (bens imobilizados); Contas retificadoras do passivo exigível: juros a correr; Contas retificadoras do patrimônio líquido: capital a integralizar, prejuízos acumulados, ações em tesouraria. Balancete de verificação:Balanço patrimonial:Nome da empresa;CNPJnome do demonstrativodata da apuração dos valores contábeis patrimoniais.Contas de resultado: demonstração do resultado do exercício Despesas/custos: operacionais (de venda, administrativas, tributárias, outras), não operacionais (venda de imobilizado); Receitas: vendas/serviços, comissões, descontos, juros, receita com investimentos por equivalência patrimonial, não operacionais (venda de imobilizado); Demonstração do Resultado do Exercício (DRE) - Apuração do Resultado do Exercício (ARE).Plano de contas.Passivo é crédito, ativo é débito. No resultado do exercício, despesas são débito, receitas são crédito.Método das partidas dobradas: A essência do método, hoje universalmente aceito, é que o registro de qualquer operação implica que a um débito ou mais de um débito, numa ou mais contas, deve corresponder um crédito equivalente em uma ou mais contas, de forma que a soma dos valores debitados seja igual à soma dos valores credita- dos. Não há débito(s) sem crédito(s) correspondente(s).Quadro auxiliar de lançamento: Grupo de contas Débito Crédito Ativo Aumenta o saldo Diminui o saldo Retificadoras do ativo Diminui o saldo Aumenta o saldo Passivo elegível Diminui o saldo Aumenta o saldo Patrimônio líquido (PL) Diminui o saldo Aumenta o saldo Retificadoras do passivo Aumenta o saldo Diminui o saldo Retificadoras do PL Aumenta o saldo Diminui o saldo Despesas Aumenta o saldo Diminui o saldo Receita Diminui o saldo Aumenta o saldo 4. ContabilizaçãoAtos administrativos: Ocorrências que não provocam alterações no patrimônio da empresa.Fatos administrativos: Ocorrências que provocam alterações no patrimônio da empresa, podendo ou não alterar o patrimônio líquido.Tipos de fatos: Permutativos; modificativos (aumentativos ou diminutivos); mistos (aumentativos ou diminutivos).Lançamento: registro em razonetes ou meio pelo qual se processa a Escrituração.O lançamento possui, no caso da escrituração formal, cinco elementos essenciais: local e data do fato; conta a ser debitada; conta a ser creditada; histórico; valor.No caso da contabilização em razonetes, o lançamento tem apenas três elementos para a sua caracterização: conta a ser debitada; conta a ser creditada; valor.Escrituração: livros contábeis (livro diário, livro-razão, livro auxiliar contas correntes e livro-caixa), livros fiscais e livros sociais.Princípios contábeis: Entidade, Continuidade, oportunidade, registro pelo valor original, competência, prudência.Razonete: Ferramenta didática que facilita o processo de ensino-aprendizagem do débito e crédito.Regimes contábeis: Caixa (despesas ou receitas efetivamente pagas) e competência (registros independentes de pagamento).Contabilização dos ajustes5. Operações com mercadoriasNo lançamento da venda de mercadorias não existe movimentação da conta Mercadorias, isso se deve à necessidade de se apurar o custo, e a margem de lucro.Fatos que influenciam as operações com mercadorias: ICMS, PIS, Cofins.Assim como o ICMS, o PIS sobre faturamento e a Cofins serão compensados em transações futuras, portanto não fazem parte do custo da mercadoria, sendo o valor total do custo da mercadoria encontrado por meio da seguinte fórmula: total da compra - valor dos impostos.Gastos acessórios na operação com mercadorias: fretes (compra e venda); seguros; devoluções (compra e venda).Custo da mercadoria vendida:Sistema periódico de controle de estoques:CMV = El + C + CA - DC - EF, em que: CMV — custo das mercadorias vendidas El — estoque inicial C — compras de mercadorias CA — custos acessórios (fretes e seguros sobre compras de mercadorias) DC — devolução de compras de mercadorias EF — estoque final de mercadoriasSistema permanente de controle de estoques: primeiro que entra, primeiro que sai (PEPS); último que entra, primeiro que sai (UEPS); média ponderada móvel (MPM).6. Demonstrações contábeisTipos de demonstrações contábeis: Balanço patrimonial (mais importante, representa a situação econômica e financeira da empresa), demonstração do resultado do exercício (DRE), demonstração de lucros ou prejuízos acumulados (DLPA), demonstração dos fluxos de caixa (DFC - atividades operacionais, de financiamentos e de investimentos), demonstração do valor adicionado (DVA), notas explicativas (Nes).Tributação (sobre lucros, faturameno e de obrigações sociais): Federal — Simples Nacional, lucro real, lucro presumido e lucro; arbitrado; estadual; municipal.Etapas do levantamento das demonstrações contábeis: 1ª — lançamento dos fatos administrativos; 2ª — lançamento das apropriações (ajuste das contas); 3ª — levantamento do balancete de verificação; 4ª — apuração do resultado; 5ª — levantamento do balanço patrimonial; 6ª — levantamento das demais demonstrações contábeis.A situação econômica diz respeito à aplicação e ao rendimento do capital, e a situação financeira diz respeito à liquidez da empresa, ou seja, seu grau de solvência.Análise de balanços: Consiste em ferramenta de controle da evolução patrimonial equilibrada.Padronização das demonstrações: Consiste em ajustar as demonstrações contábeis, visando a uma análise mais precisa.Análise vertical: Analisa a empresa em relação à distribuição dos recursos entre os elementos patrimoniais.Análise horizontal: Analisa a empresa considerando a evolução dos elementos patrimoniais de um exercício em relação a outros.Análise por quocientes: Evidenciam posições específicas da empresa em relação à liquidez/solvência, ao endividamento e à rentabilidade.Interpretação da análise: Deverá sempre considerar o ambiente interno e externo, ou seja, a empresa e sua inserção no mercado.Relatório de análise: Deverá apresentar, de forma clara e objetiva, aos usuários de informações todas as análises efetuadas com sua interpretação." }, { "title": "Anotações sobre Comunicação Empresarial", "url": "/posts/comunicacao-empresarial/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-04-24 08:00:00 -0300", "snippet": "1. Língua e linguagem Linguagem: sistema organizado e convencional de sinais. Linguagem verbal e não verbal Língua padrão e variantes linguísticas “toda língua apresenta um padrão culto, isto é, uma modalidade cujas regras mais se aproximam das que estão descritas na gramática normativa.” Aspectos que interferem na produção linguística e levas as variantes: tempo, espaço, grupo social, atividade profissional, situação comunicativa, produção literária. Intencionalidade discursiva - contexto Separação silábica e translineação 2. Novo acordo ortográfico Alfabeto - inclusão de k, w e y. Trema abolida, exceto em nomes estrangeiros e seus derivados. Hífen: Não se usa o hífen entre prefixos e falsos prefixos terminados em vogal e palavras iniciadas por r ou s. Nesse caso, dobram-se essas consoantes; Usa-se hífen quando o prefixo ou falso prefixo terminar pela mesma vogal que inicia a palavra seguinte; Não se usa o hífen entre o prefixo ou falso prefixo quando este terminar em vogal e a palavra iniciar por uma vogal diferente; O uso do hífen permanece entre prefixos e falsos prefixos terminados em r e palavras iniciadas por r (ex: hiper-realista); O hífen permanece entre qualquer prefixo e palavras iniciadas por h; O hífen permanece entre os prefixos ex-, vice-, soto-, sem- e palavra iniciada por qualquer letra; O hífen permanece entre os prefixos circum-, pan- e palavras iniciadas por vogal, m ou n; Com o prefixo co-, não se usa hífen, ainda que o segundo elemento comece pela vogal o. * Acentuação gráfica Acentuam-se as proparoxítonas; A paroxítonas terminadas em L, N, R, X, OS, Ã, ÃO, I, UM, UNS, ONS, ditongos crescentes e -ei, -eis (fechados). Não se acentuam os ditongos abertos EI e OI; As oxítonas e monossílabos tônicos terminados em A, E, O, EM, ENS (os terminados em I e U não); Acentuam-se o I e o U tônicos em hiatos sozinhos ou seguidos de S (exceto se seguidos de NH ou antecedidos por ditongo); Quase todos os acentos diferenciais foram abolidos. 3. O texto Não há texto sem intencionalidade. Texto é uma unidade linguística dotada de certa estrutura formal. Conteúdo e forma. Gêneros textuais: relato pessoal, notícia, seminário, conferência, memorando… Ferramenta que permite exercer uma ação linguística, com objetivos comunicativos relativos a uma audiência, regularidades formais e conteúdos. Como construir a textualidade: informatividade (capacidade de oferecer informações na medida certa, sem cair na obscuridade ou no senso comum), coerência (organização lógica das ideias), coesão (conexões gramaticais entre palavras, frases e parágrafos). Coerência + Coesão = Textualidade. Mecanismos de coesão textual Coesão obtida pelo uso de elementos gramaticais: Pronomes pessoais; Pronomes demonstrativos; Pronomes relativos; Conectivos: conjunções e preposições; Advérbios e expressões adverbiais. Coesão obtida por meio de palavras ou expressões do mesmo campo semântico.Qualidades de um texto Objetividade; Clareza; Concisão (máximo de informação com um mínimo de palavras). Homônimos: palavras com grafia igual, mas com significado diferente. Parônimos: palavras com grafia parecida, mas com significado diferente. A estrutura do textoIntrodução Inicia com o tópico frasal, que orientará o parágrafo. Procedimentos introdutórios: Seguindo uma trajetória histórica; Por meio de uma conceituação ou definição; Por meio de citações ou opiniões que podem ser confirmadas ou negadas; Por meio da comparação entre realidades geográficas, sociais e culturais diferentes; Por meio da enumeração de informações; Por meio da narração, descrição ou da referência a acontecimentos e ações; Por meio da apresentação de dados estatísticos sobre o assunto enfocado pelo tema; Por meio de linguagem metafórica ou figurativa; Por meio de uma interrogação ou sequencia de interrogações O desenvolvimento das ideias Um parágrafo indica uma ideia central. Modelos de argumentação: Por citação de autoridade; Por comprovação; Por raciocínio lógico; Por causa e consequência; Por exemplificação ou ilustração; A conclusão Possibilidades de conclusão: Por retomada da tese; Com a apresentação de perspectivas de solução; Com o uso de uma interrogação; 4. Produção TextualErros mais frequentes e dúvidas mais comuns na produção textualPrincipais vícios de linguagem: Gerundismo; Pleonasmo; Clichês; Barbarismo; Cacofonia; Problemas na construção das frases: Sujeito como complemento (o sujeito não deve ser precedido de preposição); Frases fragmentadas; Ausência de paralelismo (ideias similares apresentadas em estruturas gramaticais diferentes); Erros de comparação; Uso excessivo da palavra QUE; Porque, porquê, por que, por quê Porque: sentido de explicação ou causa; Porquê: variação substantivada, precedida de artigo (o porquê), valendo pelos substantivos razão, motivo, causa; Por que: introduzir uma interrogativa direta, uma pergunta; Por quê: no final de frases interrogativas ou sozinho. E-mail E-mails, como qualquer correspondência, são confidenciais. Deixe linhas em branco entre a saudação, os parágrafos e a assinatura. A carta comercialA carta está para a empresa privada assim como o ofício está para o serviço público.Os componentes da carta são os seguintes: Timbre da empresa; Tipo e número (à esquerda e no alto da página) não obrigatórios; Local e data; Designação do destinatário; Informação da referência ou do assunto; Vocativo; Corpo do texto; Fecho; Assinatura do remetente; Cargo do remetente. O memorandoVem sendo substituído pelo e-mail.Partes de um memorando(1) Timbre da empresa ou do órgão público.(2) Identificação: número/departamento remetente e data extenso, na mesma linha.(3) Identificação do destinatário.(4) Síntese do assunto.(5) Vocativo.(6) Desenvolvimento do assunto.(7) Fecho.(8) Nome e cargo do remetente.O ofício Meio de comunicação escrita utilizado pelos órgãos públicos. O papel em que é redigido o ofício deve conter timbre, símbolo, armas ou apenas o carimbo do órgão público que o expede. Partes de um ofício (1) Timbre do órgão público. (2) Tipo e número do documento no alto da folha, à esquerda, seguidos da sigla do órgão remetente. (3) Local e data por extenso. (4) Vocativo seguido de vírgula (recorra à explicação do emprego de pronomes de tratamento, no próximo capítulo). (5) Corpo do texto, estruturado da seguinte maneira: parágrafo de abertura, no qual é apresentado o assunto que vai ser tratado. (6) Os parágrafos devem ser numerados a partir do segundo, com o detalhamento do assunto. Se houver muitas informações sobre o assunto, deve ser redigido um parágrafo para cada uma delas. (7) Conclusão, na qual deve ser reafirmada a posição recomendada para o assunto tratado. (8) Fecho: deve conter uma saudação ao destinatário. (9) Assinatura do autor do ofício. (10) Identificação do signatário (aquele que envia o documento). De acordo com a Instrução Normativa n5 4 (Brasil, 1992), a folha de papel deve ser diagramada da seguinte maneira: Margem esquerda: 2,5 cm ou dez toques de espaço no teclado, Margem direita: a 1,5 cm ou seis toques da borda Tipo e número do ofício ficam a 5,5 cm ou seis espaços duplos da borda superior. À esquerda, devem se distanciar 2,5 cm ou dez toques de teclado. Local e data: o término da data deve coincidir com o término da margem à direita e verticalmente deve ficar a 6,5 cm ou sete espaços duplos da borda superior Vocativo: a 10 cm ou dez espaços duplos da borda superior e a dez toques da borda esquerda. Parágrafos: avanço da esquerda para o centro de 2,5 cm ou dez toques no teclado. O primeiro parágrafo deve se posicionar a 1,5 cm do vocativo ou a três espaços simples Entre os parágrafos o espaço é de 1 cm ou um espaço duplo, roj O fecho do texto deve estar centralizado, a 1 cm ou um espaço duplo do final do texto. A identificação do signatário deve ficar a 2,5 cm ou três espaços duplos do fecho. A ata Relatar ocorrências verificadas em uma reunião. Não risque ou utilize corretivo, para correções escreva “digo…”. Caso erro seja constatado somente ao final, adicione “Em tempo:”. Não use abreviaturas. Números por extenso. (1) Informação da data (dia, mês e ano) e da hora. (2) Informação do local da reunião. (3) Identificação da pauta da reunião. (4) Nomeação das pessoas presentes e de seus respectivos cargos ou funções. (5) Registro sintetizado das principais ocorrências e decisões. (6) Assinatura dos presentes. (7) Data e assinatura do(a) secretário(a). O relatório Exposição de ocorrências ou da execução de um trabalho. Normalmente utiliza-se o presente do indicativo. (1) Identificação — Informe o número do documento e a sigla do departamento que o está enviando. (2) Apresentação do assunto — Selecione as ideias pertinentes ao assunto, evitando a dispersão ou a desorganização das informações. Centralize-se no essencial a ser dito e apresente uma exposição resumida dos fatos. (3) Redação das informações — Inicie seu relatório com a exposição do assunto. As informações devem ser apresentadas segundo o andamento cronológico. Se houver a necessidade de apontar causas e consequências de um fato, mencione as causas primeiramente, em um parágrafo só para elas. Em seguida, em outro parágrafo, cite as consequências. Planilhas e outros documentos acessórios podem ser inseridos em anexos. (4) Desfecho — Aponte razões para o êxito ou o fracasso da atividade desenvolvida, comente os resultados, sinalize as dificuldades encontradas e sugira soluções para os problemas verificados. (5) Fecho (6) Assinatura Outros gêneros da redação empresarial Atestado: O atestado é um documento firmado por uma autoridade com a finalidade de assegurar a existência ou a inexistência de uma situação de direito, referente a alguém ou a respeito de algum fato ou de alguma situação. (1) A palavra ATESTADO, em letras maiúsculas, deve aparecer centralizada, no alto da folha. (2) Nome e identificação da autoridade que emite o documento, seguidos da identificação da pessoa ou do órgão que solicita. (3) O texto deve ser curto, direto e claro, apresentando apenas a informação solicitada. (4) Assinatura, nome, cargo ou função de quem atesta. Aviso e Declaração são semelhantes. " }, { "title": "Anotações sobre Aspectos legais da computação forense", "url": "/posts/aspectos-legais-computacao-forense/", "categories": "Estudos-faculdade", "tags": "gestão, segurança", "date": "2020-04-17 08:00:00 -0300", "snippet": "1. Aspectos legais da computação forense Computação forense é a atividade técnica-científica capaz de colher informações que permitam identificar atividades realizadas dentro de um ambiente virtual, evidenciando os elementos necessários para a elucidação de fatos. O que foi feito? Quem fez? Como fez? Quando fez? Onde fez? Prescrição: é a perda da exigibilidade de um direito pelo decurso do tempo em que será aplicada de acordo com a natureza da ação ou da conduta praticada tipificada como crime. Vestígio: qualquer marca, fato, sinal, material que seja detectado no local onde o ato foi praticado, que ao ser relacionado com o ato criminoso, pode se tornar uma evidência. Indício: é a circunstância que não tem relação com o fato, mas que por sua existência, permite, por indução, concluir a existência de outra. Na legislação penal, este termo é utilizado na fase processual. O indício será formado pelo conjunto de evidências e demais provas obtidas nos autos, como, por exemplo, a testemunha. Evidência: é toda informação encontrada que efetivamente ajuda na formação da prova da existência de um ato ou de sua autoria. Critérios para a evidência digital: Admissibilidade: deve estar em condições de ser usada no processo, obtida de forma legal. O nosso sistema judiciário somente admitirá provas obtidas por meios ilícitos em casos extremamente excepcionais, como no caso de absolver um réu. Prova ilícita é aquela obtida, por exemplo, de forma irregular, contrária ao previsto na lei, ou que infrinja dispositivo legal. Autenticidade: deve ser demonstrado de forma inequívoca como a evidência foi obtida e o nexo de causalidade, ou seja, a ligação entre a evidência encontrada e o ato praticado ora investigado. Confiabilidade: devem ser demonstrados os procedimentos de coleta e de análise dos resultados, não se deve gerar dúvidas sobre sua veracidade e tampouco levar à ambiguidade nos resultados. Credibilidade: clara, de fácil compreensão. Lei nº. 12.965/14, conhecida como Marco Civil é considerada a primeira lei exclusivamente dedicada à regulamentação geral do uso da internet, estabelecendo os princípios, garantias, direitos e deveres. Artigo 7º, direitos dos usuários: A inviolabilidade da intimidade e da vida privada; Inviolabilidade e sigilo do fluxo de suas comunicações pela internet e de suas comunicações privadas armazenadas; Não fornecimento a terceiros de seus dados pessoais, inclusive registros de conexão e de acesso a aplicações de internet, salvo mediante consentimento livre, expresso e informado ou nas hipóteses previstas em lei; Informações claras e completas sobre coleta, uso, armazenamento, tratamento e proteção de seus dados pessoais, que somente poderão ser utilizados para finalidades que justifiquem sua coleta, ou não sejam vedadas pela legislação, ou, ainda, estejam especificadas nos contratos de prestação de serviços ou em termos de uso de aplicações de internet; Exclusão definitiva dos dados pessoais que tiver fornecido a determinada aplicação de internet, a seu requerimento, ao término da relação entre as partes, ressalvadas as hipóteses de guarda obrigatória de registros previstas nesta Lei. Lei nº 9.609/1998, conhecida como Lei do Software, trouxe a proteção e registro dos direitos do autor de propriedade intelectual. Lei 12.735/12, que passou a tipificar as condutas realizadas mediante uso de sistema eletrônico digital ou similares, praticados contra sistemas informatizados e similares. Lei federal nº. 12.737/12 (Lei Carolina Dieckmann), que alterou o Código Penal e passou a tipificar como crime a invasão de aparelhos eletrônicos. Decreto nº 7.962/2013, que regula o comércio eletrônico. Padronização na busca de evidências: SWGDE (Scientific Working Group on Digital Evidence); CAIS (Centro de Atendimento a Incidentes de Segurança). Perito Judicial é o especialista, o profissional técnico ou científico nomeado por um juiz e sob sua inteira confiança, que auxilia a justiça na busca de evidências que serão provas de um fato. O perito assistente é o profissional que tem como função analisar os fatos e dar nova conclusão de ordem técnica, concordando ou não com o perito judicial, permitido, assim, uma dupla confirmação do resultado ou, ainda, a instauração de um contraditório para que o entendimento de um não seja de caráter absoluto, tendo em vista tratar-se de um profissional, porém, passível de falha como qualquer outro. 2. Aspectos legais para a formação da prova A prova é o que demostra cabalmente os fatos ocorridos, bem como sua autoria, o momento, o motivo e as consequências geradas. Para configurar uma conduta como crime, é necessário obedecer a um princípio jurídico chamado legalidade, ou seja, não haverá crime se não houver uma lei anterior que defina a conduta praticada como tal. Essa previsão legal de conduta como sendo crime é o que chamamos de tipicidade. Tipos de crimes virtuais: O crime virtual puro compreende qualquer conduta ilícita que ataque o computador da vítima, ou seja, o hardware e/ou software. Os crimes mistos são aqueles que se utilizam da internet para a prática delituosa, não tendo como objetivo o computador da vítima, mas sim algum outro bem, como o roubo de senha para acesso a conta corrente. Por fim, os crimes virtuais comuns são aqueles que se utilizam da internet para a prática de crimes tipificados no Código Penal sobre ações de conduta do indivíduo no seu cotidiano, mas agora levadas ao mundo virtual, conforme observamos no caso de injúria racial, através de ofensas em redes e mídias sociais, o preconceito, a calúnia, a difamação. Prescrição Penal: é a perda do direito do Estado de punir um transgressor de alguma norma penal, ou seja, de quem praticou um crime, em decorrência do decurso de tempo, uma vez que o direito de punir deve ser exercido dentro do prazo legalmente estabelecido. Espécies de crimes virtuais: calúnia (atribuição falsa de conduta criminosa); difamação (atribuição de conduta desaprovada pelo meio social, ofensa à honra); injúria (ferir a honra subjetiva do indivíduo, xingamento ou humilhação); perfil falso (falsidade ideológica); preconceito e discriminação; estelionato afetivo; apologia e incitação ao crime; pornografia; pornografia de vingança; pedofilia; plágio; invasão de dispositivo informático; furto de dados; sequestro de dados; falsas premiações; Preconceito: é um julgamento prévio sobre determinada situação. Racismo: crime pela ideologia propagada de que alguns grupos humanos são superiores e melhores do que outros e por esta razão possuem direitos diferenciados. Injúria racial: é um crime contra a honra, praticado pela ofensa à dignidade de alguém, utilizando-se de elementos como raça ou cor. Discriminação: é o ato praticado propriamente que expõe o racismo ou preconceito. 3. Aspectos legais da entrevista vs. interrogatório No Brasil, é permitido ao perito realizar a entrevista, mas não o interrogatório. A entrevista é o meio em que se busca novas informações para nortear os passos na análise pericial. Deve ser realizada em tom amigável, numa linguagem clara e objetiva, evitando gírias. O interrogatório no ordenamento jurídico é a fase em que uma autoridade judiciária faz uma sucessão de perguntas, de forma oral, à pessoa acusada ou à testemunha. É um ato formal que obedece os requisitos legais para sua validade. A perícia da computação forense é utilizada na busca de evidências digitais para crimes praticados em ambientes virtuais, mas também em outros processos de diversas naturezas, tais como: tributário, trabalhista, familiar e principalmente os de natureza civil. Se o juiz verificar que o assunto tratado pode ser esclarecido por profissional técnico da área sem a necessidade da respectiva perícia e sim por meio de explicações, deverá recusar a prova pericial e determinar a prova técnica simplificada. Art. 473 – O laudo pericial deverá conter: I – a exposição do objeto da perícia; II – a análise técnica ou científica realizada pelo perito; III – a indicação do método utilizado, esclarecendo-o e demonstrando ser predominantemente aceito pelos especialistas da área do conhecimento da qual se originou; IV – resposta conclusiva a todos os quesitos apresentados pelo juiz, pelas partes e pelo órgão do Ministério Público. 4. Aspectos legais do laudo pericial A responsabilidade nos atos de natureza civil A prática de atos realizados por menores de idade A responsabilidade da Pessoa Jurídica: a empresa é responsável pelas condutas praticadas por seus colaboradores em ambiente de trabalho ou em razão do trabalho Parecer: é um documento elaborado por profissional técnico, a partir da análise de dados colhidos, onde o profissional pode emitir sua opinião técnica ou até mesmo sugerir procedimentos de solução, de acordo com o resultado encontrado. Responsabilidade dos Provedores da Internet: remover da internet eventuais servidores que agem de forma incorreta, enviando spam e outros softwares maliciosos. A perícia antecipada como meio de prova * Os órgãos de proteção e as decisões do Poder Judiciário Súmula: no contexto jurídico, é a união de várias decisões de um mesmo Tribunal, quando se tem diversas decisões idênticas sobre o mesmo tema, servindo de base para os próximos julgamentos. Lei Geral de Proteção de Dados Pessoais, sob nº. 13.709/18, para produzir efeitos a partir de 2020. O laudo pericial da computação forense: § 1o No laudo, o perito deve apresentar sua fundamentação em linguagem simples e com coerência lógica, indicando como alcançou suas conclusões. § 2o É vedado ao perito ultrapassar os limites de sua designação, bem como emitir opiniões pessoais que excedam o exame técnico ou científico do objeto da perícia. § 3o Para o desempenho de sua função, o perito e os assistentes técnicos podem valer-se de todos os meios necessários, ouvindo testemunhas, obtendo informações, solicitando documentos que estejam em poder da parte, de terceiros ou em repartições públicas, bem como instruir o laudo com planilhas, mapas, plantas, desenhos, fotografias ou outros elementos necessários ao esclarecimento do objeto da perícia. O procedimento para encaminhamento dos vestígios para análise deve obedecer à Portaria nº. 82/2014 do Ministério da Justiça, que dispõe sobre a Cadeia de Custódia de Vestígios. Modelo: Folha inicial ou preâmbulo: é a identificação do laudo que o identifique diante do processo judicial ao qual está vinculado. Alguns dados informados no preâmbulo são: dados do processo (se já houver); número do laudo e unidade de criminalística emissora; data de emissão do laudo; identificação dos envolvidos no exame e do processo; Histórico: fase onde são relatados fatos anteriores que fazem a introdução do laudo; Material: descrição do material periciado, tais como: marca, modelo, número de série, capacidade de armazenamento, país de fabricação e demais informações que o perito achar úteis para identificação inequívoca do material questionado: número do item no auto de apreensão e número do lacre; estado de conservação do material e possíveis divergências com o descrito no auto de busca e apreensão; Objetivo: etapa em que se descreve os objetivos principais da realização do exame pericial; Considerações técnicas: nesta etapa o perito pode descrever conceitos e informações técnicas, desde que de forma compreensível a um leigo, para melhor entendimento do laudo; Atividades realizadas: aqui o perito deverá apresentar os métodos e técnicas realizados para preservação do material de vestígio, bem como para localização das evidências digitais. Nesta etapa deve-se descrever todos os passos nas atividades realizadas para se chegar à conclusão apresentada, seja na análise de material, testes, diligências, entrevistas, etc. conclusão: finalizado o trabalho, o perito deverá apresentar o resultado final da perícia, evidenciando ou não o solicitado pelo juízo. respostas aos quesitos: se houver, estes deverão ser transcritos e respondidos um a um sequencialmente. " }, { "title": "Anotações sobre Empreendedorismo", "url": "/posts/empreendedorismo/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-04-10 08:00:00 -0300", "snippet": "Livro: Empreendedorismo - Paulo SertekEstratégias de Globalização de Empresas Diversificação de produtos - verticalização - agregar ao negócio principal outros secundários - excessiva diversificação é problemática. Competitividade - estratégias de diferenciação. Três estratégias para competir: Liderança em custos; Diferenciação; Foco;1. Potencial empreendedor Capacidade da pessoa em desenvolver competências que enriqueçam o seu repertório de ações, para aproveitar oportunidades, a fim de satisfazer as necessidades dos clientes. Utilidade para o cliente - finalidade da empresa - marketing e inovação. Percepção dos consumidores - consumidor é o usuário final do produto ou serviço. Aspectos de avaliação dos clientes sobre o serviço: Consistência; Competência; Velocidade de atendimento; Atendimento/atmosfera; Flexibilidade; Credibilidade/segurança; Acesso; Tangíveis; Custo. Definição do negócio e objetivos - finalidade e missão devem ser traduzidas em objetivos. Os objetivos devem derivar de qual é o nosso negócio; devem ser operacionais; devem possibilitar a concentração de recursos e esforços; devem ser múltiplos; são necessários em todas as áreas. Áreas-chave dos objetivos: marketing; o posicionamento de mercado que se deve ter como alvo não é o máximo, mas sim o ótimo inovação; no produto ou serviço, na localização de mercado e comportamento e valores de clientes e nas diversas habilidades e atividades para produzir os produtos e serviços e trazê-los ao mercado. organização do pessoal; recursos financeiros; recursos materiais e produtividade; indicadores e medições responsabilidade social; nível de lucro. mínima rentabilidade necessária2. Criatividade e inovaçãoCompetências criadoras e inovadorasLiderança e criatividade3. Identificando Oportunidades I. Identificar a oportunidade do negócio; II. Desenvolver o conceito do negócio; III. Implantar o empreendimento. Inovação de valor: fornecimento de maior valor aos consumidores com menor impacto possível nos custos. Estratégia do Oceano Azul. Fórmulas para identificar oportunidades: IV. Identificar necessidades; V. observar deficiências; aperfeiçoar o que já é bem sucedido. VI. observar as tendências; VII. derivar para algo similar à ocupação atual; VIII. procurar outras aplicações de um mesmo conceito; IX. benchmarking. Não se pode fazer pesquisa de mercado sobre uma coisa que não está no mercado. Métodos: X. Matriz de planejamento XI. Benchmarking - mensuração e padrão de referência. Não pode ser empregado isoladamente. XII. Exame das fronteiras de mercado - o não consumo - examine os setores alternativos - examine os grupos estratégicos dentro de um mesmo setor - examine a cadeia de compradores - examine as ofertas de produtos e serviços complementares - examine os apelos funcionais e emocionais dos compradores - examine o transcurso do tempo (novos paradigmas de consumo). XIII. Mapa de utilidade para o comprador Compra Entrega Uso Suplementos Manutenção Descarte Qual é a demora para encontrar o produto de que precisa? Qual é a demora pra receber o produto? O produto exige treinamento ou assistência de especialistas? Precisa-se de outros produtos ou serviços para que o produto funcione? O produto exige manutenção externa? O uso do produto gera resíduos? O local da compra é atraente e acessível? Qual é o grau de dificuldade para desembalar e instalar o novo produto? É fácil guardar o produto quando não estiver em uso? Em caso afirmativo, qual é o custo desses suplementos? Qual é o grau de facilidade para manter e atualizar o produto? Qual é o grau de facilidade para descartar o produto? Qual é o grau de segurança do ambiente de transações? Os próprios compradores devem providenciar a entrega? Em caso positivo, qual é o custo e a dificuldade da entrega? Qual é o grau de eficácia dos itens e funções do produto? Qual é a demora para obtê-los?   O descarte seguro do produto envolve questões legais ou ambientais? Com que rapidez se completa a compra?   O produto ou serviço fornece muito mais capacidade e opções do que as exigidas pela maioria dos usuários? Qual é o grau de incômodo deles resultante?   Qual é o custo do descarte?     Será que ele está cheio de itens desnecessários? Qual é o grau de facilidade para obtê-los?     4. Fatores a serem considerados na escolha do produto/serviço: primeira parteEtapas da criação de um negócio próprio:Desenvolver conceitos - definição de um a proposta de valor a ser oferecida ao cliente   Regras do jogo estáveis Regras do jogo instáveis Competição alta RESULTADOS INOVAÇÃO Competição baixa CUSTOS PROCESSOS Inovação de valor - reduzir, aumentar, criar e eliminar . Elementos chave para a definição do conceito do negócio: as necessidades, o grupo de clientes a serem atendidos, o modo como se pretende atender. Identificar Riscos: Sazonalidade, efeitos da situação econômica, controle governamental, dependência de elementos de disponibilidade e custo incerto, ciclo de vida do setor (expansão, estagnação ou retração), lucratividade, mudanças que estão ocorrendo no setor e efeitos das mudanças tecnológicas, grau de imunidade à concorrência e atração pessoal (intangíveis), formação de barreiras à entrada. Agregando valor ao cliente através dos serviços, das pessoas e da imagem; Procurar experiências similares e reduzir riscos.graph TD A[Valor fornecido] subgraph B[Valor Percebido]---C[Produtos] C---D D[Serviços]---E[Pessoal] E---F F[Imagem] end A--&gt;B subgraph L[Desempenho]---M[Recursos] M---N N[Confiabilidade]---O[Conformidade] O---P P[Manutenibilidade]---Q[Estética] end B--&gt;L subgraph R[Distribuição]---S[Instalação] S---T T[Treinamento]---U[Consultoria] U---V[Reparos] end B--&gt;R subgraph W[Competência]---X[Cortesia] X---Y Y[Credibilidade]---Z[Confiabilidade] Z---a a[Prontidão]---b[Comunicação] end B--&gt;W subgraph c[Símbolos]---d[Propaganda] d---e e[Atmosfera]---f[Eventos] end B--&gt;c subgraph G[Preço]---H[Valor monetário] H---I I[Custos de tempo]---J[Energia] J--- K[Desgaste psicológico] end A--&gt;G5. Fatores a serem considerados na escolha do produto/serviço: segunda parteAvaliação do potencial de lucro e crescimentoCaracterísticas dos tipos de negócios: Categorias dos negócios-&gt; Medíocres Sucessos pessoais Sucessos passageiros Grandes sucessos Características dos negócios Medíocres Sucessos pessoais Sucessos passageiros Grandes sucessos Potencial de lucro Subsistência Grande Muito grande Muito grande Potencial de crescimento Limitado Limitado Passageiro Grande Barreiras à entrada Não há Há Geralmente não há Há, de difícil transposição Necessidade do conhecimento Não há Especializado Marketing Muito especializado Reputação do empreendedor Indiferente Estabelecida e respeitada Indiferente Indiferente Ligações com cliente Não há Forte Não há Forte Liderança de mercado Não há Liderança Passageira Forte Grau de inovação Não há Moderado Radical Acentuado Necessidade de investimento Modesto Substancial Modesto Substancial Risco Pequeno Grande Muito grande Grande Ciclo de vida Longo Longo Curto Longo Potencial de venda do negócio Não há Grande Só para um incauto Muito grande Dinâmica dos negócios: oferta e demanda. Fases do ciclo de vida: introdução, expansão, turbulência, saturação, declínio. Efeito da experiência: quanto maior for o tempo em que um determinado produto é produzido, maiores serão as possibilidades de que seus custos de produção se reduzam e , num mercado competitivo, os preços também cairão.6. Critérios decisóriosFoco em serviço: Segmento de mercado–&gt; //////// Conceito de serviço/estratégia de operações Estreito Estreito Amplo Amplo Estreito (cardápio limitado) Maior vantagem Foco externo Maior vantagem Domínio do processo operacional Estreito (cardápio limitado) Maior problema potencial Potencial insuficiente de mercado Maior problema potencial Diversificação do conceito de serviço Amplo (cardápio variado) Maior vantagem Domínio do consumidor Maior vantagem Grande potencial de mercado Amplo (cardápio variado) Maior problema potencial Falta de foco operacional Maior problema potencial Falta de foco “ser tudo para todo mundo” Investimento fixo - bens físicos - ativo - não é consumido mas se desgasta e tem vida útil limitada. Investimento financeiro - capital de giro 5 pré-requisitos para decisões de negócio: o conceito do negócio, o conhecimento, os contatos, os recursos e as encomendas.Livro: A caminhada empreendedora - Elton Ivan Schneider &amp; Henrique José Castelo Branco1. O que é ser um empreendedor? Conhece seus limites, pessoa determinada, corre riscos. Empreendedor gestor: Ação; criatividade; otimismo; entusiasmo; perseverança; inovação; planejamento. Intraempreendedorismo - empreendedores de negócios - empreendedores sociais Necessidade - criatividade; oportunidade - inovação. Tipos de empreendedor pelo contexto: artesão, tecnológico, oportunista e “estilo de vida”. Competência = conhecimento + habilidades + atitudes. Triplo papel: empreendedor, administrador e técnico.2. A criatividade e o empreendedorismoCaçador de ideias (ter ideias); artista (melhorar ideias); juiz (escolher ideias) e guerreiro (tornar reais as ideias).3. Oportunidades de negócios: da criatividade à inovação a. Que necessidade quero satisfazer? b. Quanto o cliente quer gastar? c. Quais as opções de produto ou serviço? d. Quem fornece o produto ou serviço? e. O que fornecem? f. Como geram valor ao cliente? Avaliação de oportunidades - oito erros que precisam ser evitados: paixão; paranoia; perfeccionismo; tempo; concorrência; preço baixo; impaciência; lucro rápido. Processo decisório: decisão; ideia; estudo; plano; ação. Atitudes do empreendedor: vontade de correr riscos; aprendizado; características pessoais; Planejamento e capacidade de julgamento: visão; oportunidades; contexto. Formas de empreender: montar um negócio; comprar um negócio já existente; associar-se para a criação de um novo negócio; associar-se em projetos mais sólidos e consolidados; abrir uma franquia.Inovar é criar valor.4. O desafio do empreendedorismo sustentável Desenvolvimento Local Sustentado - DLS - satisfaz as necessidades do presente, sem comprometer a capacidade de as futuras gerações satisfazerem suas próprias necessidades. Decidir - Criar - Inovar - Consciência DLS - Planejar - Agir. Empreendedorismo sustentável: Equidade social - Conservação ambiental - eficiência econômica5. Planejando o negócio: a gestão empreendedora e o plano de negócios Planejando a abertura do negócio: conhecimento; planejamento; encontrar a melhor trilha; acreditar na própria capacidade. Desafios: trabalho árduo; vida pessoal X vida profissional; riqueza, independência e estabilidade financeira; realização e satisfação pelo dever cumprido. A pesquisa de mercado: gestão da informação (registro, classificação, análise e apresentação objetiva de dados). Objetivo da pesquisa - público-alvo da pesquisa - fontes de pesquisa - método de pesquisa - caracterizar a pesquisa - tabular a pesquisa - tomada de decisão. Personalidade dos compradores: inovadores, primeiros adeptos, maioria inicial, maioria tardia, retardatários. Tipos de pesquisa qualitativa: entrevista, cliente oculto, grupo focal, teste de produtos (degustação).Planejar o negócio: O plano de negócios - Objetivos: ◌ Conhecer o negócio; ◌ Conhecer o mercado; ◌ Formas e tendências da indústria; ◌ Posição estratégica; ◌ Administração competente; ◌ Atrair e reter talentos; ◌ Controle financeiro. A estrutura do plano de negócios: ◌ Antecedentes e objetivos; ◌ Análise de mercado; ◌ Desenvolvimento e produção; ◌ Marketing; ◌ Dados financeiros; ◌ Organização e gestão; ◌ Plano de investimentos; ◌ Estrutura societária; ◌ Riscos e contingências; ◌ Resumo e conclusões. Componentes e apresentação do plano de negócios: ◌ Sumário executivo; ◌ Descrição da companhia; ◌ Descrição do produto/serviço; ◌ Análise e tendência do segmento; ◌ Definição do mercado-alvo; ◌ Análise dos concorrentes; ◌ Avaliação de riscos inerentes ao negócio; ◌ Plano de marketing; ◌ Operações; ◌ Plano para a utilização das novas tecnologias; ◌ Uso das novas tecnologias da informação e comunicação: os e-negócios; ◌ Estrutura de gestão do negócio; ◌ Desenvolvimento local sustentado (DLS); ◌ As formas de acompanhamento do que foi planejado; ◌ O planejamento financeiro do negócio.6. Empresariando o negócio Buscando capital financeiro: próprio; empréstimo/financiamento; capitalista de risco; sócio operacional. Capital intangível: intelectual; humano; estrutural; organizacional; inovação. Empresariando com efetividade: gestão de pessoas (saber recrutar, selecionar, treinar, motivar, controlar, premiar); gestão operacional (entender de compras, estoques, logística, produção, qualidade); gestão de marketing (saber ler o mercado, ter foco, compreender os mecanismos de propaganda, de vendas, de atendimento); gestão de finanças (entender de financiamento, imobilização, fluxo de caixa, contabilidade, custos); gestão do planejamento (estudar, perceber, estruturar, planejar, controlar). " }, { "title": "Anotações sobre Fundamentos de Arquitetura de Sistemas WEB", "url": "/posts/fundamentos-arquitetura-sistemas-web/", "categories": "Estudos-faculdade", "tags": "web", "date": "2020-04-03 08:00:00 -0300", "snippet": "Vantagens e desenvolvimento de Web ServicesO que são Web ServicesServiços Web ou Web Services são soluções para aplicações se comunicarem independente de linguagem, softwares e hardwares utilizados.Inicialmente Serviços Web foram criados para troca de mensagens utilizando a linguagem XML (Extensible Markup Language) sobre o protocolo HTTP sendo identificado por URI (Uniform Resource Identifier).Podemos dizer que Serviços Web são API’s que se comunicam por meio de redes sobre o protocolo HTTP.Vantagens: Linguagem comum; Integração; Reutilização de implementação; Segurança; Custos.Principais Tecnologias: SOAP; REST; XML; JSON.Estrutura SOAPSOAP - Simple Object Acess ProtocolÉ um protocolo baseado em XML para acessar serviços web principalmente por HTTP.Pode-se dizer que SOAP é uma definição de como serviços web se comunicam.Foi desenvolvido para facilitar integrações entre aplicações.Vantagens:Permite integrações, independente de linguagem, pois usa como linguagem comum o XML.É independente de plataforma e software.Meio de transporte genérico, ou seja, pode ser usado por outros protocolos além do HTTP.XML - Extensible Markup Language.É uma linguagem de marcação criada na década de 90 pela W3C.Facilita a separação de conteúdo.Não tem limitação de criação de tags.Linguagem comum para integrações entre aplicações.•Atributo dentro da tag, =“”•Sempre com aspas duplasO “SOAP Message” possui uma estrutura única que deve sempre ser seguida:graph TD subgraph SOAP Envelope A[SOAP Header] B[SOAP Body] A---B endSOAP Envelope é o primeiro elemento do documento e é usado para encapsular toda a mensagem SOAP.SOAP Header é o elemento onde possui informações de atributos e metadados da requisição.SOAP Body é o elemento que contém os detalhes da mensagem&lt;soap:Envelope xmls:soap=\"http://www.w3c.org/2003/05/soap-envelope\"&gt; &lt;soap:Header&gt; &lt;/soap:Header&gt; &lt;soap:Body&gt; &lt;m:MetodoEndereco xmls:m=\"http://www.example.org/endereco\"&gt; &lt;m:Cidade&gt;Pitanga&lt;/m:Cidade&gt; &lt;/m:Endereco&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt;Entendendo o que é WSDL e XSDWSDL - Web Services Description LanguageUsado para descrever Web Services, funciona como um contrato do serviço.A descrição é feita em um documento XML, onde é descrito o serviço, especificações de acesso, operações e métodos.http://soapclient.com/xml/soapresponder.wsdlXSD - XML Schema DefinitionÉ um esquema no formato XML usado para definir a estrutura de dados que será validada no XML.O XSD funciona como uma documentação de como deve ser montado o SOAP Message (XML) que será enviado através de Web Service.SoapUI.org é um sistema que ajuda a visualizar e ler aquivos WSDL e XSD.Aprenda o que são REST, API e JSONREST - Representational State TransferÉ um estilo de arquitetura de software que define a implementação de um serviço web.Pode trabalhar com os formatos XML, JSON ou outros.Permite integrações entre aplicações e também entre cliente e servidor em páginas web e aplicações.Utiliza dos métodos HTTP para definir a operação que está sendo efetuada.Arquitetura de fácil compreensão.API - Application Programming InterfaceSão conjuntos de rotinas documentados e disponibilizados por uma aplicação para que outras aplicações possam consumir suas funcionalidades.Ficou popular com o aumento dos serviços web.As maiores plataformas de tecnologia disponibilizam APIs para acessos de suas funcionalidades, algumas delas são: Facebook, Twitter, Telegram, WhatsApp, GitHub…Principais métodos HTTP:GET - solicita a representação de um recurso.POST - Solicita a criação de um recurso.DELETE - Solicita a exclusão de um recurso.PUT - Solicita a atualização de um recurso.JSON - JavaScript Object Notation.Formatação leve utilizada para troca de mensagens entre sistemas.Usa-se de uma estrutura de chave e valor e também de listas ordenadas.Um dos formatos mais populares e mais utilizados para troca de mensagens entre sistemas.•Tipos:•Object{}•String “”•Number•BooleanArray [ {}, {} ]{ \"nome\": \"Os vingadores\", \"ano_lancamento\": \"2019\", \"personagens\":[ { \"nome\": \"Thanos\" }, { \"nome\": \"Homem de ferro\" } ]}Veja sobre integração com REST e métodos HTTP na práticaCódigo de estado: usado pelo servidor para avisar o cliente sobre o estado da operação solicitada. 1xx Informativo 2xx Sucesso 3xx Redirecionamento 4xx Erro do Cliente 5xx Erro do Servidor [Códigos de status de respostas HTTP - HTTP MDN (mozilla.org)](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status) É possível testar o REST com o Postman   Conceitos de arquitetura em aplicações para internetIntrodução a arquitetura de sistemasMonolito:graph LR subgraph Servidor A(Banco de dados) B[\"Aplicação(instância 1)\"] &amp; C[\"Aplicação(instância 2)\"] &amp; D[\"Aplicação(instância 3)\"] --&gt;A E[Proxy HTTP] --&gt; B &amp; C &amp; D end F[Web app] &amp; G[Mobile app] --&gt; EMicrosserviços #1graph LR subgraph Cluster subgraph Nodo 1 B[Serviço 1] end subgraph Nodo 2 C[Serviço 2] end subgraph Nodo 3 D[Serviço 3] end E[Proxy HTTP] --&gt; B &amp; C B--&gt;C C--&gt;D end F[Web app] &amp; G[Mobile app] --&gt; E B--&gt;H(Serviço Externo) C--&gt;I(Bancos de dados 1) D--&gt;J(Banco de dados 2)Microsserviços #2graph LR subgraph Cluster subgraph Nodo 1 B[Serviço 1] end subgraph Nodo 2 C[Serviço 2] end subgraph Nodo 3 D[Serviço 3] end E[Proxy HTTP] --&gt; B &amp; C end F[Web app] &amp; G[Mobile app] --&gt; E B---H(Serviço Externo) &amp; I C---I(Message Broker) D---J(Banco de dados) &amp; IMessage Broker: Permite identificar o motivo de um determinado serviço ter sido incapaz de responder no momento de uma requisição.Microsserviços #3graph LR subgraph Cluster subgraph Nodo 1 B[Serviço 1] end subgraph Nodo 2 C[Serviço 2] end subgraph Nodo 3 D[Serviço 3] end E[Proxy HTTP] --&gt; A[Gerenciador de pipeline] A--&gt; B &amp; C &amp; D end F[Web app] &amp; G[Mobile app] --&gt; E B---H(Banco de dados 1) C---I(Serviço externo) D---J(Banco de dados 2)Comparando os modelos Monolito e MicrosserviçosMonolito Prós Contras Baixa complexidade Stack única Monitoramento simplificado Compartilhamento de recursos   Acoplamento   Mais complexo a escalabilidade Microsserviços #1 Prós Contras Stack dinâmica Monitoramento mais complexo Simples escalabilidade Provisionamento mais complexo   Acoplamento Microsserviços #2 Prós Contras Stack dinâmica Monitoramento mais complexo Simples escalabilidade Provisionamento mais complexo Desacoplamento   Microsserviços #3 Prós Contras Stack dinâmica Provisionamento mais complexo Simples escalabilidade Plataforma inteira depende do gerenciador de pipeline Desacoplamento   Menor complexidade   Gerenciamento de erros e volume de acessoOnde é mais complexo: Processos assíncronos (Microsserviços 2) PipelineSolução: Dead letter queue Filas de re-tentativas A arquitetura de aplicações móveis e internet das coisas Conceito de internet das coisas Embutir sensores em objetos do dia-a-diaColetar dados dos sensoresUsar o dado para tomar decisãoThings - Cloud - IntelligenceSmart building - Smart Home - Wearables - Agriculture - Smart transportation - RFID Supply Chain (etiquetas inteligentes) - Energy EfficiencyComputação ubíqua - Mark WeiserDesafios da Internet das Coisas: 1. Privacidade e segurança 2. Quantidade exponencial de dispositivos conectados na rede 3. Ser capaz de processar e armazenar uma enorma quantidade de informações 4. Gerar valor a partir dos dados coletados ### Arquitetura da internet das coisas e protocolos de comunicação Como conectar as coisas. Considere: 5. Baixo consumo de energia 6. Rede de dados limitada 7. Resiliência 8. Segurança 9. Customização 10. Baixo Custo Arduino: Plataforma de prototipagem Com entradas/saídas Desenvolvedor escreve em C/C++ Interface serial ou USB ShieldsEmbarcados - MCUs Microcontrolador de chip único Sistema operacional real time Embarcado Uso industrial, médico, militar, transporteMinicomputadores - Raspberry Pi Computador completo Hardware integrado em uma única placa Roda SO Linux ou Windows Uso doméstico e comercialO protocolo de comunicação - MQTT Base na pilha do TCP/IP Protocolo de mensagem assíncrona (M2M) Criado pela IBM para conectar sensores de pipelines de petróleo a satélites Padrão OASIS suportado pelas linguagem de programação mais popularesModelo Publish/Subscribegraph LR A[GPS] --&gt;|Publish| B[MQTT Broker] C[Sensor] --&gt;|Publish| B[MQTT Broker] B --&gt;|Publish| D[Cloud] D --&gt;|Subscribe| B B --&gt;|Publish| E[Aplicativo] E --&gt;|Subscribe| BA flexibilidade dos tópicos mqtt:// broker.io/ a6g319/ gps/ position PROTOCOLO BROKER USER IDENTIFIER SENSOR INFORMATION TYPE QoS 0 Nível mínimo de menor esforço Sem garantia de entrega Mensagem não é retransmitidaQoS 1 Garante que a mensagem foi entregue no mínimo uma vez ao receber Mensagem pode ser retransmitida se não houver confirmação de entregaQoS 2 Garante que a mensagem foi entregue no mínimo uma vez ao receber Mensagem pode ser retransmitida se não houver confirmação de entrega Dupla confirmaçãoCloudgraph LR A[Broker] --&gt; B[Worker] A --&gt;C[Worker] B --&gt;|armazenar|D[(Data store)] C --&gt;E[Cache] E --&gt;|exibir| F[Aplicativo]" }, { "title": "Anotações sobre Sistemas Operacionais", "url": "/posts/sistemas-operacionais/", "categories": "Estudos-faculdade", "tags": "so", "date": "2020-03-27 08:00:00 -0300", "snippet": "1 ConceitoUm sistema operacional é um conjunto de elementos (programas) capazes de fazer um todo (computador) funcionar. É uma camada de software colocada entre o hardware e os programas que executam tarefas dos usuários. Seus principais objetivos são: tornar a utilização do computador mais eficiente e conveniente; distribuição dos recursos de memória, processador e dispositivos pelos programas; esconder os detalhes de baixo nível; prover recursos em alto nível para acesso a periféricos;2 História dos Sistemas OperacionaisO primeiro computador digital foi desenvolvido por Charles Babbage, também chamado de motor analítico.O primeiro sistema operacional, chamado monitor por sua simplicidade, foi desenvolvido em 1953 pelos usuários do computador IBM 701 do Centro de Pesquisas da Gereral Motors, justamente para tentar automatizar as tarefas manuais até então utilizadas. Posteriormente, este sistema seria reescrito para um computador IBM 704 pelo grupo de usuários da IBM.Os sistemas operacionais foram desenvolvidos para automatizar a execução de programas (JOBS) e facilitar a vida de usuários e programadores.Evolução Histórica – Primeira Geração de Computadores • ENIAC – Programação em linguagem de máquinaEvolução Histórica – Segunda Geração de Computadores • Jobs em cartões magnéticos • Uso de Sistema Operacional para leitura dos cartões • Programas em Assembly e FortranEvolução Histórica – Terceira Geração de Computadores • Inicio da multiprogramação, compartilhamento de tempo entre jobs • Desenvolvimento do UnixEvolução Histórica – Quarta Geração de Computadores • Surgimento dos computadores pessoais • Criação de uma interface amigável baseada em ícones (GUI)Linha do Tempo• 1950 – O conceito de sistema operacional apareceu durante a segunda geração da computação moderna• 1969 – Primeira versão do Unix§ 1981 – Lançamento do MS DOS 1984 – Sistemas Operacionais com Interface gráfica§ 1991 – Surgimento do Linux§ 2001 – Windows XP§ 2005 – Android§ 2009 – Windows 7§ 2010– Chromium OS§ 2011 – Windows 8201…§ SO integrados a web (Windows 10, Firefox OS)3 Tipos de Sistemas OperacionaisOs sistemas operacionais são classificados quanto ao tempo de resposta e entrada de dados em sistema operacional em lote (batch), Interativos, tempo real, Híbridos.Sistema de processamento batch, não exige interação com usuário a entrada de dados feita por meio de um dispositivo, geralmente arquivos em disco, processamento de cálculos, compilações, ordenações, backups.Os sistemas interativos, também conhecidos como sistemas de tempo compartilhado, geralmente permitem a interação com usuário por meio de terminais, vídeo, teclado e mouse.Sistemas de processamento em tempo real, implementados para responder 100% das respostas em tempo real, o tempo de resposta é o fator principal do sistema, utilizado em monitoramentos, controle de tráfego aéreo, de usinas nucleares. Os sistemas híbridos é uma combinação de sistema batch com sistemas interativos.Quanto a execução de tarefas os sistemas operacionais são classificados como sistemas monotarefas, multitarefas e multiprocessamento.Os sistemas monotarefas são caracterizados por executarem uma única aplicação de cada vez, já nos sistemas multitarefas, varias programas concorrem pelos recursos de processamento. Os sistemas multiprocessados, possuem duas ou mais CPUs interligas trabalhando em conjunto fortemente acoplados ou fracamenta acoplados.Os sistemas com multiprocessadores fortemente acoplados são aqueles que possuem duas ou mais CPUs que compartilham uma única memória e são controladas por um único sistema operacional. Os fracamente acoplados, possuem duas ou mais CPUs cada uma com a sua memória e controladas por sistemas operacionais independentes.Quanto a estrutura (do núcleo/kernel), os sistemas operacionais são classificados como Monolíticos, em camadas, máquinas virtuais, microkernel e cliente servidor.Monolíticos: Pode ser comparada com uma aplicação formada por vários módulos que são compilados separadamente e depois linkados.Em camadas: O sistema é dividido em níveis sobrepostos § Cada camada oferece um conjunto de funções que podem ser utilizadas apenas pelas camadas superiores.graph TD A(Usuário) --- B(Aplicações) B --- C(Shel) C --- D(Kernel) D--- E(Hardware)Os sistemas operacionais ainda são classificados como sistemas operacionais de computadores de grande porte, servidores, computadores pessoais e sistemas operacionais embarcados.Grande Porte: Possuem muitas E/S. Processamento simultâneo de muitos jobs. Permite que múltiplos acessos remotos executem jobs simultaneamente.Servidores: Servem múltiplos usuários de uma vez. Permite o compartilhamento de recursos de hardware e software. Provem serviços de impressão, armazenamento ou web.Os embarcados são sistemas que controlam dispositivos móveis ou que não são computadores, como exemplo, micro-ondas, geladeiras os IPads, Iphone, PDAs e etc.Os sistemas operacionais modernos são divididos em várias camadas, onde cada camada prove serviços a camada superior mais próxima e oferece proteção a camada mais inferior, o núcleo do sistema ou Kernel do sistema operacional.O acesso ao recursos do Kernel é feito por meio de chamada de sistemas (system calls) de forma protegida para evitar dano ao sistema. As instruções que têm o poder de comprometer o sistema são conhecidas como instruções privilegiadas (modo kernel), enquanto as instruções não-privilegiadas são as que não oferecem perigo ao sistema.As chamadas de sistemas são os comandos de acesso as funções do SO, e podem ser dividas em chamadas para Gerenciamento de Processos, para sinalização, para gerencia de arquivos, para manipulação de diretórios, para proteção e para gerenciamento de tempo.4 O conceito de concorrência em Sistemas OperacionaisSistemas Operacionais podem ser vistos como um conjunto de rotinas executadas de forma concorrente e ordenada. (Pinkert, 1990). A possibilidade de o processador executar instruções ao mesmo tempo que outras operações, como, por exemplo, operações de E/S, permite que diversas tarefas sejam executadas concorrentemente pelo sistema. O conceito de concorrência é o princípio básico para o projeto e a implementação dos sistemas multiprogramáveis.Nos sistemas multiprogramáveis, vários programas podem estar residentes em memória, concorrendo pela utilização do processador. Dessa forma, quando um programa solicita uma operação de E/S outros programas poderão utilizar o processador.Para permitir a concorrência entre programas, o sistema operacional implementa vários mecanismos de software e ou de hardware.As interrupções são o mecanismo que tornou possível a implementação da concorrência nos computadores é sempre gerada por algum evento externo ao programa, exemplo uma operação de E/S.A exceção é gerada por um evento síncrono direto do programa concorrente.Os controladores são mecanismos de hardware que controlam as operações de I/o em disco, liberando o processador para executar outras tarefas. O controlador sinaliza as interrupções ao processador.A técnica de buffering consiste na utilização de uma área na memória principal, denominada buffer, para a transferência de dados entre os dispositivos de E/S e a memória. Esta técnica permite que em uma operação de leitura o dado seja transferido primeiramente para o buffer, liberando imediatamente o dispositivo de entrada para realizar nova tarefa.A técnica de spooling utiliza uma área em disco como se fosse um grande buffer. Neste caso, dados podem ser lidos ou gravados em disco, enquanto programas são executados concorrentemente. Todos os sistemas operacionais utilizam esta técnica no gerenciamento de impressão. (arquivos de spool).A reentrância é a capacidade de um código executável (código reentrante) ser compartilhado por diversos usuários, exigindo que apenas uma cópia do programa esteja na memória.Técnica de DMA: Acesso direto a memória: técnica que permite a transferência de dados direto da memória para o dispositivo de saída sem passar pelo processador.5 Gerência de ProcessosUm processo pode ser entendido inicialmente como um programa em execução, só que seu conceito é mais abrangente. Este conceito torna-se mais claro quando pensamos de que forma os sistemas multiprogramáveis (multitarefa) atendem os diversos usuários (tarefas) e mantêm informações a respeito dos vários programas que estão sendo executados concorrentemente [MACHADO, 1997].Um processo possuí informações do contexto de hardware, software e endereçamento de memória.O contexto de hardware é fundamental para a implementação dos sistemas time-sharing, onde os processos se revezam na utilização do processador, podendo ser interrompidos e, posteriormente, restaurados como se nada tivesse acontecido. A troca de um processo por outro na CPU, realizada pelo sistema operacional, é denominada mudança de contexto (context switching). A mudança de contexto consiste em salvar o conteúdo dos registradores da CPU e carregá-los com os valores referentes ao do processo que esteja ganhando a utilização do processador. Essa operação resume-se, então, em substituir o contexto de hardware de um processo pelo de outro.O contexto de software especifica características do processo que vão influir na execução de um programa, como o número máximo de arquivos abertos simultaneamente ou o tamanho do buffer para operações de E/S. Essas características são determinadas no momento da criação do processo, mas algumas podem ser alteradas durante sua existência. O contexto de software define basicamente três grupos de informações de um processo: sua identificação, suas quotas e seus privilégios.O espaço de endereçamento é a área de memória do processo onde um programa poderá ser executado, além do espaço para os dados utilizados por ele. Cada processo possui seu próprio espaço de endereçamento, que deve ser protegido do acesso dos demais processos.Os processos são executados de forma cíclica alternando seu estado. Estado de execução (running) quando está sendo processado pela CPU. Estado de pronto, (ready) quando apenas aguarda uma oportunidade para executar, ou seja, espera que o sistema operacional aloque a CPU para sua execução. Estado de espera (wait) quando aguarda algum evento externo ou algum recurso para poder prosseguir seu processamento.Tipos de Processos Foreground X Background:Tipos de Processos CPU-Bound X I/O-Bound:ThreadsEm sistemas tradicionais, cada processo tem seu espaço de endereçamento individual e apenas um fluxo de controle (thread). No entanto, algumas vezes desejamos ter vários fluxos de controle (threads) no mesmo espaço de endereçamento simulando uma execução em paralelo, como se cada fluxo fosse visto realmente como um processo distinto (exceto pelo fato de compartilharem um único espaço de endereçamento).Muitos threads podem existir dentro de um único contexto de processo, cooperando entre si a fim de realizar um dado cálculo e compartilhando o espaço de endereçamento e o restante do contexto desse processo. (multithread).Um ambiente multithread se utiliza dos mesmos mecanismos de concorrência entre processos, interrupções, exceções e a comunicação entre processos (Inter Process Comunication – IPC), essenciais para permitir acesso concorrente a um recurso compartilhado.Vantagens para Utilização de Thread: § São mais fáceis de criar e destruir que os processos § Compartilham espaço físico de memória, disco, periféricos e outros recursos § Apresentam melhor performance do que os processos.Utilização de Thread: § O sistema operacional deverá ter suporte à thread. API CreateThread do Windows § A ferramenta de programação (linguagem) também deverá ter suporte para threads (JAVA).Conceitos para gerência de threadsRegião Crítica: Também chamada de Seção Crítica. É a parte do sistema que permite acesso concorrente entre os processos. Exemplo: spool de impressão, buffer de memória, etc.;Exclusão Mútua: É uma técnica usada em programação concorrente para evitar que dois ou mais processos ou threads tenham acesso simultaneamente a um recurso compartilhado do sistema, ou seja, a uma região crítica;Sinais: São interrupções de software que notificam ao processo que um evento ocorreu. Os sinais não permitem que processos especifiquem dados para trocar com outros processos. São utilizados para sincronização entre processos e S.O, ou seja, os sinais só ocorrem entre processos ou entre um processo e o S.O.Trap: É o sinal que o processo envia para o S.O solicitando um serviço protegido do mesmo (como por exemplo sua entrada em uma região crítica). Um trap bloqueia o processo até que o serviço requerido pelo mesmo, ao sistema operacional, seja realizado.Problema de comunicação entre processos ou threadsProcessos podem solicitar recursos, mesmo que estejam de posse de recursos obtidos anteriormente. Caso estes recursos já estejam alocados a outros processos, o processo solicitante deve aguardar pela liberação do mesmo. Essa é a condição natural do sistema de alocação de recursos, porém, alguns problemas naturalmente podem ocorrer, neste caso temos os problemas de comunicação entre processos ou threads.Condição de Corrida: Também chamada de Corriza de Hazards, é uma das consequências da sincronização incorreta, gerando a disputa de recursos do sistema por múltiplos processos, ou threads, causando o corrompimento dos dados, onde parte dos dados são modificados por um processo/thread e parte por outro, ou seja, acontece quando dois ou mais processos entram simultaneamente na região crítica.Starvation: Também chamado de Livelock, acontece quando processos/threads estão em execução, mas nada acontece, isso ocorre geralmente quando dois ou mais processos/threads então trabalhando com intenções contrarias, o que é feito por um processo/thread é desfeito pela outro. Também ocorre quando um processo/thread tenta o acesso a um recurso que está sendo utilizado por outro processo/thread, o S.O pede para que o mesmo aguarde sua liberação, porém o processo/thread não está preparado para o aguardo, ou seja, ele vai continuar solicitando o recurso indefinidamente, mesmo que o recurso seja liberado, pois o processo/thread não foi programado para uma “rejeição”.Deadlock: É o problema mais terrível e mais estudado em sistemas operacionais. É uma situação em que dois ou mais processos/threads estão em estado simultâneo de espera, cada um aguardando que um dos demais libere um bloqueio para ele poder prosseguir, ou seja, um conjunto de N processos está em deadlock quando cada um dos N processos está bloqueado à espera de um recursos que somente pode ser liberado por um processo desse conjunto.Sequência lógica para que processos utilizem recursos do sistemaPedido: o processo cria um trap para solicitar um recurso. Se o processo não tiver seu pedido atendido, pois o recurso não está livre, ele é bloqueado e ficará esperando até ganhar a posse do recurso.Uso: tendo posse do recurso ele poderá utilizá-lo.Liberação: desalocar o recurso adquirido pelo processo o liberando para outro processo. O gerenciamento desses recursos é feito pelo sistema operacional através de uma tabela, que registra se cada recurso está livre ou ocupado. Caso o recurso esteja ocupado, também é especificado o processo que tem a posse do recurso.6 Gerência do processadorA política de escalonamento de um sistema operacional tem diversas funções básicas, como a de manter o processador ocupado a maior parte do tempo, balancear o uso da UCP entre processos, privilegiar a execução de aplicações críticas, maximizar o throughput do sistema e oferecer tempos de resposta razoáveis para usuários interativos. Em ambientes que implementam apenas processos, o escalonamento é realizado com base nos processos prontos para execução. Em sistemas que implementam threads, o escalonamento é realizado considerando os threads no estado de pronto, independentemente do processo.graph TD A(Estado de Execução) --- B(Estado de Espera) B --- C(Estado de Pronto) C ---A C --&gt;|Escalonamento| A C ---E((fa:fa-list-alt)) C ---F((fa:fa-list-alt)) C ---G((fa:fa-list-alt)) C ---H((fa:fa-list-alt))Critérios de escalonamentoAs características de cada sistema operacional determinam quais são os principais aspectos para a implementação de uma política de escalonamento adequada. Os principais critérios são:Utilização do processador: Na maioria dos sistemas é desejável que o processador permaneça a maior parte do tempo ocupado.Throughput: representa o número de processos executados em um determinado intervalo de tempo.Tempo de Processador /Tempo de UCP: É o tempo que um processo leva no estado de execução durante seu processamento.Tempo de Espera: É o tempo total que um processo permanece na fila de pronto durante seu processamento, aguardando para ser executado.Tempo de Turnaround: É o tempo que um processo leva desde a sua criação até seu término, levando em consideração todo o tempo gasto na espera para alocação de memória, espera na fila de pronto, processamento na UCP e na fila de espera, como nas operações de E/S.Tempo de Resposta: Tempo decorrido entre uma requisição ao sistema ou à aplicação e o instante em que a resposta é exibida.graph LR A(Estado de Execução) subgraph Fila dos processos no estado de Pronto B((fa:fa-list-alt)) --&gt; C((fa:fa-list-alt)) C --&gt; D((fa:fa-list-alt)) end A --&gt; B D --&gt; E{UCP} E --&gt; G(Estado de Término) E --&gt; F(Estado de Espera) F --&gt; H[Fila dos processos no estado de Pronto]Tipos de escalonamento Não-Preemptivos e Preemptivos: As políticas de escalonamento podem ser classificadas segundo a possibilidade de o sistema operacional interromper um processo em execução e substituí-lo por um outro, atividade esta conhecida como preempção. O escalonamento não-preemptivo (sem interrupção) foi o primeiro tipo de escalonamento implementado nos sistemas multiprogramáveis, onde predominava tipicamente o processamento bath. No escalonamento preemptivo, o sistema operacional pode interromper um processo em execução e passá-la para o estado de pronto, com o objetivo de alocar outro processo na UCP. Escalonamento First-in-First-Out (FIFO): O processo que chegar primeiro ao estado de pronto é o selecionado para execução. Escalonamento Shortest-Job-First (SJF): Seleciona primeiro o processo de menor tempo de processador ainda por executar. Escalonamento Cooperativo: É uma implementação que busca aumentar o grau de multiprogramação em políticas de escalonamentos que não possuam mecanismos de preempção. Neste caso, um processo em execução pode voluntariamente liberar o processador para outro processo. Escalonamento Circular: É um escalonamento do tipo preemptivo, projetado especialmente para sistemas de tempo compartilhado. Quando um processo passa para o estado de execução existe um tempo-limite para uso contínuo do processador denominado fatia de tempo (time slice) ou quantum. Escalonamento por Prioridades: É um escalonamento do tipo preemptivo realizado com base em um valor associado a cada processo denominado prioridade de execução. O processo com maior prioridade no estado de pronto é sempre o escolhido para execução, e processos com valores iguais são escalonados seguindo critérios de FIFO. Escalonamento Circular com Prioridades: Implementa o conceito de fatia de tempo e de prioridade de execução associada a cada processo. Escalonamento por Múltiplas Filas: Existem diversas filas de processos no estado de pronto, cada qual com uma prioridade específica. Os processos são associados às filas em função de características próprias, como importância para a aplicação, tipo de processamento ou área de memória necessária. Escalonamento por Múltiplas Filas com Realimentação: É semelhante ao escalonamento por Múltiplas Filas, porém os processos podem trocar de filas durante seu processamento. Possibilidade de reorganizar os processos nas filas de acordo com o seu comportamento. Circular com fila auxiliar:graph LR A(Estado de Execução) subgraph Fila dos processos no estado de Pronto B((fa:fa-list-alt)) --&gt; C((fa:fa-list-alt)) C --&gt; D((fa:fa-list-alt)) end A --&gt; B D --&gt; E{UCP} E --&gt; G(Estado de Término) E --&gt; F(Estado de Espera) subgraph Fila auxiliar I((fa:fa-list-alt)) --&gt; J((fa:fa-list-alt)) J --&gt; K((fa:fa-list-alt)) end F --&gt;|Preempção por tempo| I K --&gt; EMúltiplas filas:graph LR A[Maior prioridade] subgraph Fila de processos do sistema B((fa:fa-list-alt)) --&gt; C((fa:fa-list-alt)) C --&gt; D((fa:fa-list-alt)) end A --&gt; B D --&gt; E{UCP} F[ ] subgraph Fila de processos interativos G((fa:fa-list-alt)) --&gt; H((fa:fa-list-alt)) H --&gt; I((fa:fa-list-alt)) end F --&gt; G I --&gt; E J[Menor prioridade] subgraph Fila de processos batch K((fa:fa-list-alt)) --&gt; L((fa:fa-list-alt)) L --&gt; M((fa:fa-list-alt)) end J --&gt; K M --&gt; ERealimentação:graph TD A[Maior prioridade] subgraph Fila 1 - FIFO Adaptado B((fa:fa-list-alt)) --&gt; C((fa:fa-list-alt)) C --&gt; D((fa:fa-list-alt)) end A --&gt; B D --&gt; R[Menor fatia de tempo] R --- E{UCP} D --&gt;|Preempção por tempo| F F[ ] subgraph Fila 2 - FIFO Adaptado G((fa:fa-list-alt)) --&gt; H((fa:fa-list-alt)) H --&gt; I((fa:fa-list-alt)) end F --&gt; G I --&gt; S[ ] S --- E I --&gt;|Preempção por tempo| J J[ ] subgraph Fila 3 - FIFO Adaptado K((fa:fa-list-alt)) --&gt; L((fa:fa-list-alt)) L --&gt; M((fa:fa-list-alt)) end J --&gt; K M --&gt; T[ ] T --- E M --&gt;|Preempção por tempo| O N[Menor prioridade] subgraph Fila n - Circular O((fa:fa-list-alt)) --&gt; P((fa:fa-list-alt)) P --&gt; Q((fa:fa-list-alt)) end N --&gt; O Q --&gt; U[Maior fatia de tempo] U --- E7 Gerência de memóriaHistoricamente, a memória principal sempre foi vista como um recurso escasso e caro. Uma das maiores preocupações dos projetistas foi desenvolver sistemas operacionais que não ocupassem muito espaço de memória e, ao mesmo tempo, otimizassem a utilização dos recursos computacionais. A gerência de memória deve tentar manter na memória principal o maior número de processos residentes, permitindo maximizar o compartilhamento do processador e demais recursos computacionais.Tipos de alocaçãoAlocação Contigua Simples: A memória principal é subdivida em duas áreas: uma para o sistema operacional e outra para o programa do usuário.Técnica de Overlay: A memória é dividida em área do sistema operacional, área do módulo principal do programa do usuário e uma área de troca entre os módulos secundários do programa do usuário, denominada área de overlay.Alocação Particionada Estática ou fixa: A memória era dividida em pedaços de tamanho fixo, chamado partições. O tamanho das participações, estabelecido na fase de inicialização do sistema, era definido em função do tamanho dos programas que executariam no ambiente.Alocação fixa com código absoluto os programas só podem ser executados em posições físicas de memória.Alocação fixa com código relocável, todas as referências a endereços no programa são relativas ao inicio do código, e não a endereços físicos de memória. Nesse tipo de alocação o principal problema é a fragmentação interna, os espaços que sobram nas partições quando alocado aplicações e tamanho menor que a partição.Alocação Particionada Dinâmica: As partições são criadas exatamente de acordo com o tamanho dos programas que serão executadas, eliminando problema da fragmentação interna. Cada vez que surge um novo programa para ser executado, são criadas novas partições, com isso surge um novo problema, a fragmentação externa, que são as partições tão pequenas que não suficientes para alocar os programas necessários.Estratégias de alocação de partiçãoOs sistemas operacionais implementam, basicamente, três estratégias para determinar em qual área livre um programa será carregada para execução. Essas estratégias tentam evitar ou diminuir o problema da fragmentação externa. Best-fit, a melhor partição é escolhida, ou seja, aquela em que o tamanho da partição tem o mesmo tamanho do programa. Worst-fit, nesta estratégia a pior partição é escolhida, deixando espaços livres maiores permitindo que mais programas sejam executados, diminuindo o problema da fragmentação. First-Fit, a primeira partição livre de tamanho suficiente para carregar o programa é escolhida.Swapping: É uma técnica aplicada à gerência de memória para programas que esperam por memória livre para serem executadas. Nesta situação, o sistema escolhe um processo residente, que é transferido da memória principal para a memória secundária (swap out), geralmente em disco.8 Memória virtualÉ uma técnica sofisticada e poderosa de gerência de memória, onde as memórias principal e secundária são combinadas dando ao usuário a ilusão de existir uma memória muito maior que a capacidade real da memória principal. O conceito de memória virtual fundamenta-se em não vincular o endereçamento feito pelo programa dos endereços físicos da memória principal.MapeamentoO mapeamento é o mecanismo que permite a conversão do endereço virtual em endereço real. Nos sistemas modernos a tarefa de tradução dos endereços virtuais é realizada por hardware juntamente com o sistema operacional, de forma a não comprometer seu desempenho e torná-lo transparente a usuários e aplicações. O dispositivo de hardware responsável por esta tradução é conhecido como unidade de gerência de memória (Memory Management Unit – MMU), sendo acionado sempre que se faz referência a um endereço virtual.Tipos de memória virtualMemória Virtual – Paginação - A memória virtual por paginação é a técnica de gerência de memória onde o espaço de endereçamento real são divididos em blocos de mesmo tamanho chamado páginas.Memória Virtual – Segmentação - Memória virtual por segmentação é a técnica de gerência de memória onde o espaço de endereçamento virtual é dividido em blocos de tamanhos diferentes chamados segmentos.Enquanto na paginação existe o problema da fragmentação interna, na segmentação surge o problema da fragmentação externa.Mecanismo de traduçãoSempre que o processo referencia um endereço virtual, a unidade de gerência de memória verifica, através do bit de validade, se a pagina que contém o endereço referenciado está ou não na memória principal. Caso a página não esteja na memória, dizemos que ocorreu um page fault. Para corrigir o erro o sistema deverá transferir a página da memória secundaria para principal.Políticas de busca de páginasO mecanismo de memória virtual permite a execução de um programa sem que seu código esteja completamente residente na memória principal. A política de busca de páginas determina quando uma página dever ser carregada para a memória. Paginação por demanda e paginação antecipada.Políticas de alocação de páginasA política de alocação de páginas determina quantos frames cada processo pode manter na memória principal.Alocação fixa: cada processo tem um numero máximo de páginas que pode ser utilizado durante sua execução.Alocação variável: o numero máximo de páginas alocadas ao processo pode variar durante sua execução.Política de substituição de páginasConsiste na atuação do sistema operacional na substituição páginas (Page out e Page in) quando o processo atinge o numero máximo de páginas que foram alocadas.Working Set: Tem o objetivo de reduzir o problema de thrashing (sucessivos page faults e I/O de páginas) e erros de page faults (páginas não encontradas na memória).Algoritmos de substituição de páginasOs algoritmos de substituição de páginas tem o objetivo de selecionar os frames que tenham as menores chances de serem referenciados em um futuro próximo. A partir do princípio da localidade, a maioria dos algoritmos tenta prever o comportamento futuro das aplicações em função do comportamento passado, avaliando o numero de vezes que uma página foi referenciada, o momento em que foi carregada para memória principal e o intervalo de tempo da última referência.Principais algoritmos de substituição de páginasÓtimo: seleciona para substituição uma página que não será mais referenciada no futuro ou aquela que levará o maior intervalo de tempo para ser novamente utilizada.Aleatório: Todas as páginas alocadas na memória principal têm a mesma chance de serem selecionadas, inclusive os frames que são frequentemente referenciados. Consome pouco recurso de memória, mas possui baixa eficiência.FIFO: Seleciona para substituição a primeira página que foi utilizada e que está a mais tempo na memória. A fila é por ordem de tempo, as primeiras utilizadas são as primeiras da fila.LFU (least frequently used): A página que possuir o contador com o menor número de referências será escolhida, ou seja, o algoritmo evita selecionar páginas que são bastante utilizadas. O problema é que justamente as páginas que estão a pouco tempo na memória é que podem ser selecionadas.LRU (least recently used): Seleciona a página na memória principal que está há mais tempo sem ser referenciada. É necessário que cada página tenha a ela associado o momento do último acesso, que deve ser atualizado a cada referência a um frame. Quando for necessário substituir uma página, o sistema fará uma busca por um frame que esteja há mais tempo sem ser referenciado. Outra maneira de implementar o LRU seria através de uma lista encadeada, onde todas as páginas estariam ordenadas pelo momento da última referencia. Elevado custo de implementação.NRU (not recently used): O algoritmo NRU é bastante semelhante ao LRU, porém com menor sofisticação. Para a implementação deste algoritmo é necessário um bit adicional, conhecido como bit de referência (BR). O bit indica se a página foi utilizada recentemente e está presente em cada entrada da tabela de páginas.Quando uma página é carregada para a memória principal, o bit de referência é alterado pelo hardware, indicando que a página foi referenciada (BR=1). No momento da substituição de uma página, o sistema seleciona um dos frames que não tenha sido utilizado recentemente, ou seja, com o bit de referência igual a zero. Categorias Bits avaliados Resultado 1 BR = 0 BM = 0 Página não referenciadas e não modificada. 2 BR = 0 BM = 1 Página não referenciadas e modificada. 3 BR = 1 BM = 0 Página referenciada e não modificada. 4 BR = 1 BM = 1 Página referenciada e modificada. FIFO com buffer de páginas: O algoritmo FIFO com buffer de páginas combina uma lista de páginas alocadas (LPA) com uma lista de páginas livres (LPL). A LPA organiza todas as páginas que estão sendo utilizadas na memória principal, podendo ser implementada como uma lista única para todos os processos ou uma lista individual para cada processo. Independente da política utilizada, a LPA organiza as páginas alocadas há mais tempo na memória no início da lista, enquanto as páginas mais recentes no seu final. Da mesma forma, a LPL organiza todos os frames livres da memória principal, sendo que as páginas livres há mais tempo estão no início e as mais recentes no final. Sempre que um processo necessita alocar uma nova página, o sistema utiliza a primeira página da LPL, colocando-a no final da LPA. Caso o processo tenha que liberar uma página, o mecanismo de substituição seleciona o frame em uso há mais tempo na memória, isto é, o primeiro da LPA, colocando-o no final da LPL.É importante notar que a página selecionada e que entrou na LPL continua disponível na memória principal por um determinado intervalo de tempo. Caso esta página seja novamente referenciada e ainda não tenha sido alocada, basta retirá-la da LPL e devolvê-la ao processo. Nesse caso, a LPL funciona como um buffer de páginas, evitando o acesso à memória secundária. Por outro lado, se a página não for mais referenciada, com o passar do tempo irá chegar ao início da LPL, quando será utilizada para um outro processo. Caso a página seja posteriormente referenciada, o sistema terá que carregá-la novamente da memória secundária.FIFO circular: O algoritmo FIFO circular utiliza como base o FIFO, porém as páginas alocadas na memória estão em uma estrutura de lista circular, semelhante a um relógio. Este algoritmo é implementado, com pequenas variações na maioria dos sistemas Unix. Para a implementação do algoritmo existe um ponteiro que guarda a posição da página mais antiga na lista . Cada página possui associado um bit de referência, indicando se a página foi recentemente referenciada. Quando é necessário substituir uma página, o sistema verifica se o frame apontado tem o bit de referência desligado (BR = 0). Nesse caso, a página é selecionada para descarte, pois, além de ser a mais antiga, não foi utilizada recentemente. Por outro lado, se a página apontada tem o bit de referência ligado (BR = 1), o bit é desligado e o ponteiro incrementado, pois, apesar de ser a página mais antiga, foi utilizada recentemente. O processo se repete até ser encontrada uma página com bit de referência igual a zero.Neste algoritmo, existe a possibilidade de todos os frames possuírem o bit de referência ligado. Nesse caso, o ponteiro percorrerá toda a lista, desligando o bit de referência de cada página. Ao final, a página mais antiga é selecionada. A utilização do bit de referência permite conceder a cada página uma segunda chance antes de ser substituída. É possível melhorar a eficiência do algoritmo utilizando o bit de modificação, juntamente com o bit de referência, como apresentado no esquema NRU.Proteção de memóriaEm qualquer sistema multiprogramável, onde diversas aplicações compartilham a memória principal, devem existir mecanismos para preservar as áreas de memória do sistema operacional e dos diversos processos dos usuários.Um primeiro nível de proteção é inerente ao próprio mecanismo de memória virtual por paginação. Neste esquema, cada processo tem a sua própria tabela de mapeamento e a tradução dos endereços é realizada pelo sistema. Desta forma, não é possível a um processo acessar áreas de memória de outros processos, a menos que haja compartilhamento explícito de páginas entre processos. A proteção de acesso é realizada individualmente em cada página da memória principal, utilizando-se as entradas das tabelas de mapeamento, onde alguns bits especificam os acessos permitidos.Compartilhamento de memóriaEm sistemas que implementam memória virtual, é bastante simples a implementação da reentrância, possibilitando compartilhamento de código entre os diversos processos. Para isso, basta que as entradas das tabelas de mapeamento dos processos apontem para os mesmos frames na memória principal, evitando, assim, várias cópias de um mesmo programa na memória. Apesar de os processos compartilharem as mesmas páginas de código, cada um possui sua própria área de dados em páginas independentes." }, { "title": "Anotações sobre Sistemas de Informação Gerencial", "url": "/posts/sistemas-informacao-gerencial/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-03-20 08:00:00 -0300", "snippet": "1. Informação nas organizaçõesAs informações permeiam os níveis operacional, tático (ou gerencial) e estratégico.As informações são um elo de sinergia e um fator de motivação.Proteção - Sistemas de segurança - Políticas de controle de acesso às informações.Fluxos informacionais formais e informais: Provenientes do mundo externo; Produzidas e organizadas internamente; Produzidas pela organização e destinadas ao mercado. Processo de manipulação da informação: identificação da necessidade, aquisição, organização, armazenamento, distribuição e utilização.Computadores - Tecnologia digital - redes de comunicação digitalComputadores - Softwares - Redes de comunicaçãoComunicação no mundo virtual: ubiquidade e assincronia.TICs ou ICTs - tecnologias da informação e comunicaçãoRevolução agrícola - industrial - digital (informação, conhecimento e tecnologia)Big dataCapital intelectual - ativo intangível - gestores da informação - CIO chief information officer2. Informações e prática gerencialBits - Dígitos - Dados - Grupos de dadosDados: registros de algo que foi observado e medido, não analisados. Elemento básico ou matéria prima da informação. Fácil manipulação e armazenamento em computador.Informação: resultado da interpretação dos dados. Contexto significativo e útil. Quantitativa ou qualitativa.Valor da informação: potencial em afetar o negócio da empresa.Propósito (finalidade) e relevância (irrelevante, potencial, mínima, crítica) da informaçãoQualidade das informações: característica multidimensional e variável ao longo do tempo. Adequação ao uso. Relevância; Precisão; Confiabilidade; Temporalidade; Compreensibilidade. Conversão de dados em informações: Filtragem, Processamento e Apresentação (sumarização e roteamento).Dados para informações: contextualização - categorização - cálculo - correção - condensação.Informação para conhecimento: comparação - consequências - conexão - conversação.Pirâmide do conhecimento DIKW3. Prática gerencial e tomada de decisõesGerenciar: fazer com que as pessoas façam o que precisa ser feito. Planejamento e coordenação de pessoas.Atividades de um gestor: Estabelecer objetivos; Organizar atividades; Motivar e comunicar; Mensurar; Desenvolver as pessoas; Tomada de decisões - Atividade intelectual ou cognitiva - processo decisório - qualidade da decisão.Decisões simples ou complexas.Grau de estruturação: Estruturadas: nível operacional, informações consistentes; Não estruturadas: níveis estratégicos e de alta gestão, contexto de incerteza e informações imprecisas; Semiestruturadas: níveis gerenciais intermediários. Etapas do processo decisório: Inteligência (objetivo - análise inicial - decisão a ser tomada); Concepção (alternativas); Seleção; Revisão. Seleção: atribuir valor ou desempenho para as alternativas. Método aditivo ou linear (objetivos + relevância = nota geral).Ferramentas de apoio à decisão - SIGs sistemas de informações gerenciais.Ferramentas analíticas - problemas complexos: SADs sistemas de apoio à decisão ou DSS decision support systemsFerramentas para executivos: SAEs sistemas de apoio aos executivos, BI business intelligence, processamento analítico online, algoritmos inteligentes, mineração de dados ou data mining.4. Sistemas de informaçãoSistema: conjunto de elementos que interagem com a finalidade de produzir um resultado específico, onde cada elemento e o todo se afetam reciprocamente.Entrada - processamento - saída - ambiente - objetivoUnidade e integridadeSistema de informação (SI) - armazenar e processar informação. Combinação organizada de pessoas, hardware, software, redes de comunicação, recursos de dados e políticas e procedimentos que armazenam, restauram, transformam e disseminam informações.Ponto de vista tecnológico: hardware, software e redes de dados.Camadas do software: interface de usuário - código - banco de dados.O que caracteriza um sistema de informação é a existência de um banco de dados, logo, nem todo software é um SI.Banco de Dados: linguagem SQL structured query language, ou linguagem de consulta estruturada. Insert, select, update - transação de dados.Modelagem de dados - DBA database administrator.Modelagem relacional: dados organizados em tabelas relacionadas, vinculando os dados.5. Sistemas de informação utilizados nas empresasSistema de informação organizacional: atingir a excelência operacional; desenvolver novos produtos e serviços; melhorar a qualidade das decisões gerenciais; aprimorar o relacionamento com os clientes; assegurar a sustentabilidade do negócio. Surgiram no final da década de 1960. Information Management System (IMS), criado pela IBM, foi o primeiro programa de computador capaz de armazenar, organizar e recuperar dados com rapidez em um banco de dados.Evolução dos sistemas de informação: Era dos mainframes (década de 1960-70); Minicomputadores e computadores pessoais (1980); Redes de dados corporativas (1980); Internet e plataformas online (1990); Classificação dos sistemas de informaçãoConforme a abrangência:ERP - Enterprise Resource PlanningIOS - Inter-Organizational SystemsConforme o nível decisório:Requisitos mínimos de qualidade para SPTs: desempenho, disponibilidade, integridade de dados, modularidade, facilidade de uso.OLTP - online transaction processingSIGs - relatórios gerenciais e gráficos. Em empresas maiores o SPT pode ser um módulo interno do SIG, funcionando de forma integrada.Tipos de relatórios gerenciais: programados, sob demanda e de exceção.Um sistema de informação é considerado estratégico quando for capaz de:a. apoiar as decisões estratégicas;b. integrar os processos de negócios para otimizar os recursos empresariais;c. utilizar as bases de dados da organização como fontes de inovação e descoberta de conhecimento, empregando-se técnicas computacionais que possibilitem revelar novas oportunidades de mercado ;d. oferecer sistemas de tempo real para assegurar respostas rápidas e garantir a qualidade dos indicadores de desempenho.SADs - natureza interativa com o usuário - fórmulas matemáticas e estruturas lógicas.Tipos de SADs: baseados em comunicação; baseados em modelos; baseados em dados; baseados em documentos; baseados em conhecimento.SAEs - BI - Business Intelligence.6. Sistemas de informações gerenciais (SIGs) e sistemas integrados de gestão (ERPs)SIG para a administração financeira: controle contábil, administração de caixa, planejamento orçamentário, administração de investimentos.SIG para o relacionamento com os clientes (CRM): automação da equipe de vendas, atendimento ao cliente e marketing.SIG para a gestão da produção: projeto e engenharia, planejamento e escalonamento da produção, controle de processos, gestão da qualidade.SIG para a gestão de pessoas: Administração de pessoal, treinamento e desenvolvimento, gestão salarial.SIG para a gestão de projetos: gerenciamento de tarefas, gerenciamento orçamentário, gerenciamento da colaboração.Sistemas integrados de gestão (ERPs): evolução dos MRP (material requirement planning) da década de 1970, utilizados para planejamento de recursos empresariais. ERP2 passou a ter integração com o ambiente externo.7. Tendências em sistemas de informação· Inteligência de negócios ou business intelligence (BI), diz respeito ao processo de análise de informações que oferece suporte aos negócios de uma empresa. Tecnologias: data warehouse (DW), Olap e data mining.O DW coleta e organiza dados corporativos heterogêneos. Conceito criado por pesquisadores da IBM. O DW é projetado especificamente para realização de consultas e análises complexas sobre os dados. Características de DW: orientação ao assunto; consolidação; não volatilidade; variação temporal.Olap; online analytical processing. Funções: detalhamento sucessivo, diferentes dimensões, diferentes visualizações.Data mining: método computacional derivado de IA; análise exploratória; knowledge discovery from databases (KDD). Técnicas de data mining: predição, associação, identificação, classificação, agrupamento (clustering), otimização, sequenciamento.· Computação em nuvem - benefícios: custo, flexibilidade, segurança, recuperação de dados, equipe mínima de TI, acessibilidade e mobilidade; SaaS - software as a service." }, { "title": "Anotações sobre Redes de Computadores", "url": "/posts/redes-computadores/", "categories": "Estudos-faculdade", "tags": "redes", "date": "2020-03-13 08:00:00 -0300", "snippet": "1 Introdução a redes de computadoresUma rede, network ou simplesmente net é conhecida pelo acrônimo (sigla) em inglês DCN – Data Communication Network.Finalidade das redes de computadores: Interoperabilidade; Interconectividade; Serviços de mensagem; Serviços de telefonia; Acesso remoto à informação; Compartilhamento de recursos; Distribuição da carga de trabalho; Reforçam a confiabilidade e segurança dos sistemas, uma vez que permitem a estruturação de sistemas com tolerância a falhas; Gerenciamento ou gestão de recursos, através da sua capilaridade e da sua abrangência. Classificação das redes em função da sua abrangência geográfica: PAN, do Inglês Personal Area Network ou rede de área pessoal (&lt;=10m); LAN, de Local Area Network ou rede de área local, ou simplesmente Rede Local; MAN, de Metropolitan Area Network ou rede de área metropolitana ; WAN, de Wide Area Network ou rede de grande área; E a Internet, isto é, a interconexão de redes, a rede das redes, ou rede de alcance mundial. Classificação das redes em função da conectividade:Redes lógicas, na qual a configuração é definida por um arranjo de software, ou redes físicas, que resultam da combinação de meios de comunicação e hardware específico em arranjos físicos e com distribuição geográfica conhecida. Uma rede também pode ser composta pelos combinação destes dois tipos. O melhor exemplo para isto é a famosa Computação na Nuvem, ou seja, o Cloud Computing.Classificação das redes em função da forma de gerenciamento:Públicas ou privadasClassificação das redes quanto à arquitetura:Cliente/servidor, ponto a ponto ou híbrida.TecnologiasEthernet: É típica de topologia do tipo Estrela, e faz uso de prevenção e detecção de colisões com o CSMA/CD. As interfaces (cartões ou placas) de rede física (MAC) possuem endereços de 48 bits, ou seja, é possível designar até 248 endereços para os dispositivos ou hosts. A ethernet usa como padrões de mídia o 10 Base-T, com cabos CAT-5 e conector RJ-45. Com estes padrões consegue atingir distâncias de até 100 metros mantendo uma velocidade de comunicação de 10 Mbps (dez megabits por segundo). Com o passar do tempo e a evolução tecnológica, a ethernet também foi evoluindo, passando a apresentar novos padrões, tais como: FAST ETHERNET, padrão IEEE 802.2, mídia 100 Base-T, cabo CAT-5 e conector RJ-45, que atinge até 100 Mbps em distâncias de até 100m; FAST ETHERNET em fibra ótica, mídia 100 Base-Fx, que atinge até 100 Mbps em até 2.000 m (ou 2 Km, dois quilômetros); GIGABIT ETHERNET, padrão IEEE 802.3ab, cabos CAT-5, CAT-5e e CAT-6, com velocidades até 1 Gbps (Gigabits por segundo); GIGABIT ETHERNET em fibra óptica, padrão IEEE 802.ah; Token Ring: utilizada principalmente em redes de topologia ANEL em ambientes de altíssimo volume de tráfego de dados, exigência de alta disponibilidade e baixíssima taxa de erros. Geralmente é empregada para a comunicação de computadores de grande porte, os Mainframes, dispositivos de armazenamento de grande capacidade, os Storages ou dispositivos voltados para a cópia de segurança dos dados destes sistemas, o Backup. Esta rede é eficiente para ambientes que trocam grandes volumes de dados pois evita a colisão – a tentativa de comunicação simultânea entre mais de dois dispositivos. Isto porque existe um TOKEN, isto é, um sinalizador que fica de posse de apenas um host a cada momento, e somente o host que tiver a posse do token poderá transmitir seus dados através da rede.WiFi® – Wireless Fidelity, marca registrada da WiFi Alliance. É definida pelos padrões IEEE 802.11a para a velocidade de até 2 Mbps, IEEE 802.11b para 11 Mbps, IEEE 802.11g para 54 Mbps e IEEE 802.11n de 150 até 600 Mbps.O Bluetooth é outra tecnologia de rede sem fio, criada pela ERICSSON na década de 90, e transformada no padrão IEEE 802.15.x, é uma tecnologia voltada para a comunicação à curta distância, basicamente para as redes pessoais (PAN ou WPAN), e também associada à mobilidade e à IOT.Mobile é composta de outras tecnologias que permitem o tráfego de dados, denominadas 2G, 3G, 4G, etc.Topologia (ou arquitetura)Topologia de uma rede de computadores é a forma através da qual os computadores e demais componentes ou dispositivos da rede estão organizados, ligados ou conectados entre si. Esta ligação pode ocorrer de forma física, através dos meios de comunicação e transmissão, ou lógica, configurada por software. A topologia física expressa a aparência ou layout da rede, e a lógica representa o fluxo dos dados na rede. Ponto a ponto: um exemplo é a VPN; Barramento (BUS): todos os hosts compartilham um único meio para a comunicação. Este tipo de rede é fácil de se construir, pois o meio é único – um único cabo coaxial ou fibra ótica percorrendo toda a extensão da rede. Para evitar problemas de transmissão este tipo de rede usa um controle de acesso ao meio e de detecção de colisão do tipo CSMA/CD - Carrier Sense Multiple Access with Collision Detection ou Bus Master, ou seja, quando um host vai iniciar uma transmissão, primeiro verifica se o meio está livre. Estrela (Star): todos os hosts são conectados a um ponto ou nó central, normalmente um dispositivo de rede do tipo Hub ou Switch , mas também podem ser do tipo Repetidor, Bridge, Gateway, Router, etc. De fato existe uma conexão ponto a ponto entre os hosts e este nó central, pelo qual passa todo o tráfego da rede. Por isso, em caso de falha de um host os outros não são afetados, porém se o equipamento do nó central falhar, toda a rede fica inoperante. Anel (Ring): cada host é conectado a dois outros, seu antecessor e seu sucessor, ou o anterior e o seguinte. Desta forma há uma conexão ponto-aponto entre cada um destes dois hosts, e o tráfego da rede passa por cada um deles. Por isso mesmo, em caso de falha de um host toda a rede falha. Para evitar este tipo de falha normalmente há um anel backup no qual a informação circula em sentido contrário ao do principal. Mesh (Malha): Nas redes do tipo malha, cada host é conectado a todos os outros hosts (Full Mesh) ou pelo menos aos mais próximos a ele (Partially Mesh), através de uma conexão ponto a ponto entre cada host. Árvore (Tree): Também chamada de Hierárquica ou de Hierarquia, este tipo de rede é organizada em camadas (layers), resultado de uma combinação das redes do tipo Barramento e Estrela. Hosts vizinhos e dispositivos em nós de transição entre os níveis utilizam uma conexão ponto a ponto, resultando que, em caso de falha dos nós centrais toda a rede falha. Esta é uma configuração típica das Redes Locais. Daisy Chain: cada host é conectado a dois outros hosts, exceto os dois da extremidade da rede. É o resultado de uma combinação de redes do tipo barramento e anel, também fazendo uso de uma conexão ponto-a-ponto entre hosts vizinhos. Híbrida. Ativos de rede: são os equipamentos ou dispositivos que, em síntese, fazem a rede funcionar. Concentrador ou Reforçador (Hub): É o dispositivo que centraliza a conexão de diversos hosts em um mesmo segmento da rede, ligando-os e formando uma rede de topologia estrela. Repetidor: É o equipamento que conecta dois segmentos de rede recuperando e reforçando ou amplificando os sinais da transmissão. Bridge: É um ativo de rede que conecta dois segmentos de rede, tornando-os uma única rede, ou duas redes distintas entre si. Comutador (Switch): É o equipamento mais comum em redes locais, pois conecta hosts de diferentes segmentos de rede. Diferentemente do HUB, o Switch retransmite os pacotes de dados apenas para o host ou nó de destino, fechando um circuito entre este e o host ou nó de origem dos dados e emulando uma rede ponto a ponto entre ambos. Também permite as transmissões simultâneas (“conversas em paralelo”) e, devido à segregação dos circuitos comutados, diminui o número de colisões no segmento de rede. Roteador (Router): é o dispositivo que conecta - ou separa - redes distintas, evitando que pacotes de uma trafeguem de forma indiscriminada para outra, e encaminhando os pacotes destinados a hosts da outra rede. Um router é capaz de traçar a melhor rota – ou caminho - para um determinado pacote de dados, identificar o estado dos segmentos de rede quando à disponibilidade ou tráfego e ainda impor determinadas regras de segurança. Gateway: É o dispositivo que conecta redes com tecnologias distintas entre si, tal como as Bridges, porém com capacidade de realizar a tradução de protocolos e a conversão de dados. Proxy, Firewall e IDS (Intrusion Detection System). Meios de transmissão: são os canais, as vias ou condutores pelos quais os computadores e os dispositivos de rede enviam e recebem os dados. Eles são capazes de transportar sinais elétricos e eletromagnéticos (ondas de rádio) e a luz, que por sua vez carregam as informações em sua menor unidade, o BIT. Cabos elétricos; Cabos óticos; Sinais luminosos ou ondas eletromagnéticas. 2 Protocolos de comunicaçãoProtocolos são as regras aplicadas à comunicação de dados nas redes de computadores – às informações e aos dispositivos da rede – para possibilitar a compatibilidade entre diferentes tipos de equipamentos, redes e formatos de informação, e principalmente garantir que a informação trafegue entre origem e destino de modo efetivo, no menor tempo possível e mantendo suas qualidades.O modelo ISO/OSIO modelo ISO/OSI é um padrão da ISO - International Standard Organization para a interconexão de sistemas abertos (Open Systems Interconnection). É formado por sete camadas ou níveis de tratamento da informação:1 - Física: A camada física possibilita a ligação física de duas estações diferentes. É esta camada que trata da interação entre o hardware e os mecanismos de sinalização.2 - Enlace ou link de dados: É a que faz a conversão do fluxo de dados recebido da camada de rede para os sinais a serem transmitidos pela camada 1, interagindo com o hardware. Do lado do receptor da transmissão a camada de enlace de dados recebe os dados de hardware, transformados de sinais elétricos em BITs pela camada 1, e os agrupa em um formato de QUADRO reconhecível, disponibilizando este quadro para a camada de rede. É dividida em: - Controle lógico do link: Cuida dos protocolos, controle de fluxo e do controle de erros. - Controle de acesso ao meio (MAC - Media Access Control): Realiza o controle dos meios de comunicação. Contém o endereço físico da mídia (“placa” ou “cartão” de rede) denominado MAC Address.3 - Rede: É a camada ou nível que: Cuida da atribuição de endereços aos hosts. É nesta camada que o endereço lógico é configurado, reconhecido e tratado; Trata da definição do roteamento, isto é, o caminho pelo qual os pacotes de informação serão enviados até o destino; Faz o controle da transmissão, adequando o fluxo de dados às características do meio de transmissão (como a velocidade, por exemplo); Realiza o tratamento de erros de transmissão, fazendo a detecção e providenciando a correção dos erros; - Mantém as tabelas de roteamento ou rotas estáticas; Controla a formação dos pacotes de dados de entrada e saída e faz o encaminhamento de acordo com a qualidade e as restrições do serviço; Possibilita a conexão entre redes diferentes; Busca a entrega de pacotes para o destino com o menor esforço; Fornece os mecanismos para a comunicação através de conexões ou a comunicação sem conexão. Além disso, provê os seguintes serviços e recursos: Gerenciamento da qualidade dos serviços (QoS – Quality of Service); Balanceamento de carga e gerenciamento de link de dados; Segurança; Interação entre diferentes protocolos e a comunicação entre redes diferentes; Configuração de uma rede lógica sobre a rede física. Utilização de VPN - Virtual Privative Network ou Rede Privativa Virtual nível L3 Túneis para a conexão dedicada ponto-a-ponto. É na camada de rede que atuam os roteadores, tratando do encaminhamento (ou roteamento) dos pacotes e da distribuição da transmissão, que pode ser: - Unicast: destinado a um único host; - Multicast: destinado a um grupo de hosts; - Broadcast: destinado a todos os hosts da rede; - Anycast: destinado aos hosts mais próximos.4 - Transporte: É a camada que responde pela entrega dos pacotes de dados aos hosts, cuidando da comunicação de ponta a ponta, entre host que podem nem mesmo pertencer à mesma rede. Suas principais atribuições são: Divide os dados fornecidos pela camada de aplicação em unidades menores, chamadas segmentos, numerando-os e mantendo o registro de cada segmento. Assegura que os dados devem ser recebidos na mesma sequência em que foram enviados. - Além dos endereços de rede são associados aos segmentos um número de porta. Por sua vez estas portas estão associadas a determinados tipos de serviço e às aplicações que os utilizam. As portas também são numeradas e tem usos definidos. 5 - Sessão: Nesta camada são estabelecidas as sessões de comunicação entre os hosts. Sessões são definidas por intervalos de tempo nos quais um serviço é fornecido ou uma atividade é realizada. Para iniciar uma sessão é necessário realizar uma autenticação, isto é, identificar quem está solicitando o serviço ou a atividade. Esta camada também cuida do reconhecimento de nomes e do registro das atividades (log) na rede.6 - Apresentação: Nesta camada é tratado o formato dos dados a serem apresentados pelos aplicativos. Pode-se considerá-la como o serviço tradutor da rede. Entre outros serviços, fornece a conversão de códigos de caracteres, conversão, compactação / descompactação e criptografia de dados;7 - Aplicação: Esta camada é a que interage com os programas de aplicação ou aplicativos do usuário para que estes possam utilizar os serviços da rede.Protocolo TCP/IPTransmission Control Protocol/Internet Protocol suite é um conjunto de protocolos utilizado pela Internet. Por isso também é chamado de Internet Model.De modo análogo ao modelo ISO/OSI, é apresentado em camadas, porém, ao invés das sete camadas do modelo OSI/ISO, contém quatro camadas interdependentes, a saber: Interface de rede: especifica o tratamento dos bits, isto é, como a informação vai ser repassada para o meio físico por meio das interfaces eletrônicas. Nesta camada estão as tecnologias voltadas para o hardware, como o Ethernet e Token Ring. Inter rede ou internet: é a que contempla o IP – Internet Protocol, que trata do empacotamento dos dados (IP Datagrams) e de seu encaminhamento, isto é, do roteamento do pacote pela rede. A face mais característica é o endereço IP, um conjunto de números que representa o endereço de cada host para a rede. Transporte: é a responsável pelo nível de serviço e pelo controle da conexão que provê o transporte das informações pelas rotas da rede. Nela estão definidos os protocolos TCP (Transmission Control Protocol) e UDP(User Datagram Protocol, mais simples e sem garantia de entrega). Aplicação: cuida dos protocolos de aplicação e de como a aplicação realiza a comunicação com os serviços da camada de transporte. Nesta camada estão os protocolos como FTP, HTTP, SMTP e DHCP. O endereço IP: É um conjunto de quatro grupos de números binários de oito bits (bytes ou octetos), podendo variar de 0 (20) a 255 (28 – 1). É o identificador único de um host (ou interface) em uma rede específica. Os grupos de números são representados por dígitos decimais separados por pontos.O processo de comunicação por meio do TCP/IP:1. A comunicação pela rede por meio do TCP/IP inicia-se com o empacotamento dos dados.2. Os pacotes são numerados sequencialmente para manter a ordem e identificação.3. Os pacotes numerados são colocados no meio de transmissão pelos protocolos da suíte, e então enviados individualmente para o IP do destinatário. Cada pacote segue pela melhor rota possível no momento, até o endereço do host destino.4. Para cada pacote recebido o destinatário informa o seu recebimento ao remetente. Caso algum pacote não seja recebido em um determinado tempo, é enviado novamente.5. Os pacotes recebidos são então colocados na ordem da origem e a informação completa é reconstruída.3 InternetworkingA conexão ou roteamento entre duas redes é chamada de internetworking ou conexão inter-redes, e é tratada na camada 2 do protocolo TCP/IP, principalmente pelo protocolo IP.Os protocolos de roteamento utilizados na rede interna de da organização são chamados protocolos de gateway interior ou Interior Gateway Protocol (IGP), como por exemplo os protocolos RIP e OSPF. Roteamento entre diferentes organizações requerem o Exterior Gateway Protocol (EGP), e há apenas um EGP para cada rede, normalmente o Border Gateway Protocol (BGP).Internetworking no TCP/IP e no ISO/OSINo modelo TCP/IP a camada de Rede combina as camadas de enlace de dados (link) e a física do modelo ISO/OSI (camadas 1 e 2) para que haja independência da infraestrutura de rede. A camada superior – camada 2 ou inter-rede, equivalente à camada de rede (camada 3) do modelo ISO/OSI, trata do roteamento ou encaminhamento de pacotes entre os nós das redes.No modelo TCP/IP as camadas de Aplicação, Apresentação e Sessão - camadas 7, 6 e 5 do modelo ISO/OSI - são combinadas e formam a camada de aplicação. Nesta camada estão presentes os seguintes protocolos ou serviços, entre outros: DNS - Domain Name Service ou serviço de nomes do domínio; SMTP – Simple Mail Transfer Protocol ou protocolo simples de transferência de correio FTP – File Transfer Protocol ou protocolo de transferência de arquivo; - Ping – serviço / programa de teste de tráfego entre hosts e redes que funciona por meio de um “eco” de pacotes; HTTP – Hyper Text Transfer Protocol ou protocolo de transferência de hipertexto; NFS – Network File System ou sistema de arquivo em rede; POP – Post Office Protocol ou protocolo de correio; Telnet – Terminal Link over Network ou Terminal Virtual da Rede. As camadas de Enlace e Física – camadas 2 e 1 do modelo ISO/OSI são unificadas na camada de Rede – camada 1 do TCP/IP. Como já visto, isto se deve à necessidade de preservar, no TCP/IP, a independência da rede.Na camada 2 do TCP/IP – camada inter-redes, são definidos os protocolos responsáveis por tratar da comunicação entre as redes, a saber: IP – Internet Protocol ou protocolo internet, é o mais conhecido e mais importante protocolo desta camada, responsável, entre outras funcionalidades, pelo endereçamento dos hosts na Internet, que também chamamos endereço IP. O IP faz o encaminhamento dos pacotes entre as redes utilizando o endereço IP do host, a máscara de rede e o gateway padrão. Por exemplo: endereço do host 192.168.1.25, máscara de rede 255.255.255.0 e gateway padrão 192.168.1.1; ARP – Address Resolution Protocol, ou protocolo de resolução de endereço, busca o endereço físico da interface de rede que corresponde a um IP. Este endereço, também chamado MAC Address, é um número de 48 bits, geralmente representado em hexadecimal, como por exemplo: 94-eb-cd-26-5d-16. O ARP cria uma tabela em memória com a equivalência entre endereço físico e endereço IP. É possível acessar esta tabela com o comando ARP –a na linha de comando do Windows. RARP - Reverse Address Resolution Protocol ou Protocolo de Resolução Reversa de Endereços associa um endereço físico (MAC Address) conhecido à um endereço IP. É necessário haver um servidor ou serviço RARP na rede para responder às solicitações dos hosts, retornando o IP ligado ao MAC Address fornecido. Como o próprio nome diz, faz o trabalho reverso do ARP. ICMP - O Internet Control Message Protocol ou Protocolo Internet de Controle de Mensagem permite informar os erros ocorridos no processo de comunicação entre hosts. O protocolo IP não trata os erros, mas os informa às camadas subjacentes que podem tratar, registrar ou comunicar os erros. Os switches e os routers utilizam o ICMP para assinalar erros (delivery problem). Um exemplo do uso do ICMP é o comando ping, que faz uso de mensagens ICMP. O comando solicita um “eco” para um host destino. Se o host destino devolver o pacote enviado à origem, então pode ser alcançado pela comunicação. IGMP - Internet Group Management Protocol serve para controlar os membros de um grupo de multicast controlando a entrada e a saída dos hosts deste grupo. Desta forma o protocolo otimiza os recursos de uma rede, pois os roteadores só enviam multicast para os hosts de um determinado grupo. Multicast é a transmissão de áudio e/ou vídeo de um host para um grupo ou conjunto de outros hosts previamente conhecidos. Como exemplos de uso de multicast estão os jogos em rede, as videoconferências e a distribuição de vídeo pela rede no formado de Video on Demand - VOD e IP Television – IPTV. Endereçamento IP: Todo host conectado à uma rede TCP/IP requer uma identificação exclusiva e universal perante a rede, de forma que os pacotes endereçados a ele cheguem somente até ele. Para esta identificação o host é designado por um endereço IP. O endereço é um número binário de 32 bits, que pode endereçar até 4.294.967.296 hosts. Este número, o endereço, pode ser representado em binário ou em decimal pontuado, que é a notação mais comum e mais fácil de entender e memorizar.A notação decimal é resultado da transformação de cada conjunto de oito bits (octetos ou bytes) em um número decimal, que pode variar de 0 a 255, representando um intervalo de 256 valores (28). Os endereços IPv4 contém 32 bits e são divididos em endereço da rede e endereço do host. As máscaras de subrede ou simplesmente Mask são conjuntos de bits que mostram onde o endereço de rede termina e o onde o endereço de host começa. Para isto são utilizados os bits 1 para as posições do endereço que representam a rede e os bits 0 para as posições reservadas ao endereço dos hosts da rede.Classes: O endereço é composto de identificação da rede (endereço da rede ou NetID) e identificação do host (endereço do host ou HostID). A organização de NetID e de HostID define a classe de endereço, e a máscara de rede ajuda a identificar o NetID e o HostID, como mostrado a seguir:As classes são designadas pelas letras A, B, C, D e E. Na Classe A o primeiro bit do endereço é sempre 0 (zero), resultando em 224 ou 16.777.216 possíveis endereços de hosts (7 bits para NetID e 24 para HostID). Na Classe B os primeiros bits do endereço são sempre 10 (um, zero), resultando em 216 ou 65.536 possíveis endereços de hosts (14 bits para NetID e 16 para HostID). Na Classe C os primeiros bits do endereço são sempre 110 (um, um, zero), resultando em 28 ou 256 possíveis endereços de hosts (21 bits para NetID e 8 para HostID). Na Classe D os primeiros bits do endereço são sempre 1110 (um, um, um, zero). Esta classe é conhecida por Multicast ID, dada a sua utilização padrão para grupos de multicast. Na Classe E os primeiros bits do endereço são 1111 (um, um, um, um). Esta classe é de uso reservado pelos gestores de endereços globais para uso em projetos de pesquisa e testes.Endereços reservados: 127.x.x.x - Reservados para testes internos (também chamado de localhost ou loopback); O primeiro e o último endereço da classe ou da sub-rede: O primeiro, por exemplo 192.168.10.0, é o endereço da rede. O último, por exemplo 192.168.255.255, é o endereço de broadcast para a rede em questão. Além disso existem os endereços específicos recomendados para as redes locais ou redes internas conectadas à Internet. As faixas recomendadas para redes locais (internas) são: 10.0.0.0 a 10.255.255.255 172.16.0.0 a 172.31.255.255 192.168.0.0 a 192.168.255.255 É por isto que sempre se verifica a ocorrência destes endereços nos hosts das redes locais.Notação Standard e CIDR: Notação Standard começa com o endereço e contém o prefixo que determina o tamanho (máscara) da rede. Por exemplo, a representação 192.168.0.0 /24 corresponde a uma sub-rede que contém 254 endereços possíveis, de 192.168.0.1 até 192.168.0.254, com 192.168.0.0 sendo o endereço de rede e 192.168.0.255 sendo o endereço de broadcast para esta rede.Na representação 192.168.0.0 /22 tem-se uma sub-rede com 1022 possíveis endereços de hosts, de 192.168.0.1 até 192.168.3.254, com 192.168.0.0 sendo o endereço de rede e 192.168.3.255 sendo o endereço de broadcast para esta rede.Para o IPv4, uma representação alternativa usa o endereço de rede, escrito na forma decimal com pontos, seguido da máscara de sub-rede após uma barra. Desta forma o endereço 192.168.0.0 /24 pode ser escrito como 192.168.0.0 255.255.255.0, pois contando os 24 bits da esquerda para a direita temos:11111111.11111111.11111111.00000000Já o endereço 192.168.0.0 /22 pode ser escrito como 192.168.0.0 255.255.252.0, pois contando os 22 bits da esquerda para a direita, temos:11111111.11111111.11111100.00000000A representação com a barra torna mais flexível o endereçamento, liberando-o do emprego somente das classes-padrão de endereçamento. Por isto é chamada também de CIDR - Classless Inter-Domain Routing ou Roteamento inter-domínio sem uso de classes, e serve para o endereçamento e agregação de sub-redes, flexibilizando as máscaras de rede e permitindo um maior aproveitamento dos endereços.Endereçamento IP – IPv6: O IPv6 é a versão mais atual do protocolo IP, desenvolvida em função do esgotamento de faixas de endereço do IPv4. Os endereços são representados por números de 128 bits, permitindo assim a representação de 2128 hosts. O de, normalmente escritos como oito grupos de 4 dígitos hexadecimais, como por exemplo: 2001:0db8:85a3:08d3:1319:8a2e:0370:7344Ao escrever o endereço os grupos de vários dígitos seguidos de zeros (0000) podem ser omitidos, como por exemplo: 2001:0db8:85a3:0000:0000:0000:0000:7344 é o mesmo endereço IPv6 que 2001:0db8:85a3::7344.Endereçamento IP – DHCP: O DHCP - Dynamic Host Configuration Protocol ou Protocolo de configuração dinâmica de host é um protocolo de serviço TCP/IP que oferece configuração dinâmica, concessão de endereços IP de host, máscara de sub-rede e Default Gateway (Gateway Padrão). Isto evita o cansativo e recorrente trabalho de atribuição de endereços aos hosts de uma rede. O DHCP funciona do seguinte modo: um host envia um pacote UDP em broadcast com uma requisição DHCP para a porta 67. Um servidor DHCP que capturar este pacote irá responder, caso o cliente se enquadrar numa série de critérios, para a porta 68 do host solicitante, com um pacote contendo um endereço IP, uma máscara de rede e outros dados, como o default gateway, servidores de DNS, etc.Endereçamento IP – NAT: O NAT - Network Address Translation ou Tradução de Endereços de Rede é uma técnica que permite reescrever o endereço de um host de uma rede interna quando este é colocado na Internet, e vice-versa. Desta forma os endereços da rede interna (rede local), geralmente padronizados, não são publicados na internet. Desde modo o uso de NAT torna a rede interna mais protegida e reduz o número de endereços IP necessários para a rede externa. Porém só é possível utilizar NAT com os protocolos TCP e UDP. É bom ressaltar que o NAT permite um máximo de 65535 conexões ativas concorrentes, devido ao uso de 16 bits para a identificação das portas utilizadas para a conversão.4 TransporteO protocolo TCPO Transmission Control Protocol, ou protocolo de controle de transmissão, é um dos principais protocolos da Internet. É adequado às redes globais, pois verifica se os dados são enviados pela rede da forma correta, na sequência apropriada e sem erros. É um protocolo da camada de transporte do modelo TCP/IP (camada3), sobre o qual se assentam a maioria dos demais protocolos e aplicações, como o SSH, FTP, HTTP — e praticamente toda a World Wide Web.O processo de transmissão nesta camada funciona da seguinte maneira: transmissor e receptor criam pontos extremos – os sockets. Os Sockets são representados pelo endereço IP e mais um número de 16 bits, denominado porta. Por exemplo: 192.168.10.1:8080. As portas com valor abaixo de 1024 são chamadas de portas conhecidas e são reservadas para serviços específicos do TCP. As portas conhecidas só podem ser inicializadas por usuários com privilégio.O protocolo TCP tem como principal característica a garantia da entrega da informação, isto é, a confiabilidade da transmissão. As suas outras características são: Orientado à conexão: É necessário estabelecer uma conexão entre os hosts que pretende comunicar entre si. Para isto é necessário encaminhar, por meio da rede, informações de um para o outro de forma que se reconheçam e consigam iniciar a comunicação. Ponto a ponto: A comunicação acontece entre um host e outro do início ao fim, isto é, um host é a origem e outro é o destino (e vice-versa) como se estivessem fisicamente ligados. Confiabilidade: As informações encaminhadas por meio da rede têm a garantia da entrega durante todo o processo de comunicação, incluindo-se a identificação, o tratamento e a correção de erros. Full duplex: Uma vez estabelecida a conexão entre os hosts a comunicação flui nos dois sentidos, fazendo com que ambos sejam, simultaneamente, origem e destino da comunicação. Handshake: O processo de comunicação precisa estabelecer o reconhecimento mútuo entre os hosts antes de iniciar a transmissão/recepção das informações. O TCP usa para isso o triplo handshake com o objetivo de sincronizar algumas informações, como o número de sequência dos pacotes, por exemplo. Entrega ordenada: Os pacotes da informação são entregues em sequência ordenada ao destinatário, de forma que a informação original possa ser remontada ou reconstruída para ser entregue à camada de aplicação exatamente como estava na origem. Controle de fluxo: O processo de comunicação inclui a confirmação do recebimento de cada pacote e a avaliação da quantidade de informações recebidas e aceitas, podendo inclusive atuar sobre parâmetros da comunicação para adequar o fluxo às condições da rede naquele momento. O TCP não permite broadcast e tampouco multicasting. Existem portas do TCP associadas a serviços e protocolos específicos, que não podem ser utilizadas com outro propósito. Como já mencionado, estas portas são denominadas portas conhecidas e seu valor está no limite de 1024. As mais conhecidas são as seguintes: Porta Protocolo Uso 20, 21 FTP Transferência de arquivos 22 SSH Login remoto, substituto do Telnet 25 SMTP Correio eletrônico 80 HTTP World Wide Web 110 POP-3 Acesso remoto a correio eletrônico 143 IMAP Acesso remoto a correio eletrônico 443 HTTPS Web segura (HTTP sobre SSL/TLS) 543 RTSP Controle de player de mídia 631 IPP Compartilhamento de impressora Transmissor e receptor trocam informações na forma de segmentos. Os Segmentos são compostos de um cabeçalho de tamanho fixo de 20 bytes e os dados da transmissão (informações que o usuário quer transmitir ou necessita receber). O software decide o tamanho do segmento, porém este é limitado ao payload do IP, que é de 64 kBytes (65.535 Bytes). O segmento também é limitado pelo MTU (Maximum Transfer Unit) do enlace de dados, isto é, a capacidade máxima de encaminhamento de segmentos e seu tamanho.Um pacote TCP:Os oito bits dos flags do TCP atuam no processo de comunicação com as seguintes finalidades: CWR - Congestion Window Reduced ou janela de congestionamento reduzida, significa que o fluxo de informação deve ser reduzido em função de perdas ou atraso na informação; ECE - Confirma o “echo” da conexão TCP durante um handshake; URG – Indica que o pacote requer tratamento de urgência (pouco utilizado); ACK – Reconhecimento válido; PSH – Envio imediato dos dados, sem aguardar o preenchimento do buffer; RST, SYN e FIN – Processo de estabelecimento e liberação da conexão; O protocolo UDPUser Datagram Protocol é um protocolo simples da camada de transporte que permite que a aplicação escreva um datagrama encapsulado num pacote (IPv4 ou IPv6), o qual é então enviado ao endereço IP do destino. Porém não há qualquer tipo de garantia que o pacote será entregue. O protocolo UDP não é confiável, e se for necessário garantir a entrega, é preciso implementar controles tais como timeouts (limite de tempo), retransmissões, acknowlegments (reconhecimento), controle de fluxo, etc.Cada datagrama UDP tem um tamanho e pode ser considerado como um registro indivisível. O UDP é um serviço sem conexão, isto é, não há necessidade de manter uma ligação entre o cliente e o servidor (ou entre origem e destino). Isto significa que um cliente UDP pode criar um socket, enviar um datagrama para um servidor e imediatamente enviar outro datagrama com o mesmo socket para um servidor diferente. Da mesma forma, um servidor poderia ler datagramas vindos de diversos clientes, usando um único socket. O UDP também fornece os serviços de broadcast e multicast, permitindo que um único cliente envie pacotes para vários outros na rede.O protocolo UDP é a escolha adequada para fluxos de dados em tempo real, especialmente aqueles que admitem uma certa perda ou dano de parte de seu conteúdo. Parte do desempenho obtido por comunicação com o UDP deve-se ao fato de que este não perde tempo com criação ou destruição de conexões. Em função disso, durante uma conexão o UDP troca apenas 2 pacotes, enquanto no TCP esse número é superior a 10.O UDP também contempla portas específicas para determinados tipos de serviço ou operações, dentre as quais cabe citar: Porta Protocolo Descrição 7 Echo Ecoa um datagram recebido de volta ao emissor 9 Discard Descarta qualquer datagrama recebido 11 Users Usuários ativos 13 Daytime Retorna data e hora 17 Quote Retorna um comentário do dia 19 Chargen Retorna uma string de caracteres 53 Nameserver Domain Name Services 67 BOOTPs Servidor bootstrap 68 BOOTPc Cliente bootstrap 69 TFTP Trivial File Transfer Protocol 111 RPC Remote Procedure Call 123 NTP Network Time Protocol 161 SNMP Simple Network Management Protocol 162 SNMP Simple Network Management Protocol (trap) O pacote UDP:Protocolo SCTPStream Control Transmission Protocol é um protocolo de transporte confiável que opera sobre um serviço de pacotes não confiável e sem conexão, como é o caso do IP. O SCTP é orientado a mensagens e utiliza o conceito de associação para estabelecer vários fluxos de comunicação. Além disso provê suporte para Multihoming. As principais características do SCTP são: Entrega confirmada de dados de usuário, livre de erros e não duplicados; Fragmentação de dados em conformidade com o MTU descoberto do caminho; Entrega sequencial de dados de usuário em múltiplos fluxos; Empacotamento opcional de múltiplas mensagens de usuário num único pacote SCTP; Tolerância a falhas de rede através do suporte a caminhos múltiplos (multihoming); O SCTP é rate adaptative, adaptando-se às variações da rede; O SCTP é um protocolo mais adaptado às necessidades de comunicação das redes modernas, e, portanto, apresenta alguns benefícios quando comparado ao TCP e ao UDP, como segue: O SCTP provê transmissão confiável, e detecta quando os dados são descartados, reordenados, duplicados ou corrompidos, retransmitindo os dados quando necessário; O SCTP é orientado a conexão; O SCTP usa o conceito de associação, o que o torna mais abrangente que a conexão TCP. Enquanto uma conexão TCP estabelece apenas um único fluxo full duplex, uma associação SCTP estabelece um número arbitrário de fluxos simplex. Porém, para simular uma conexão TCP, basta criar um fluxo SCTP em cada direção; O SCTP tem potencial de substituir o TCP em diversas aplicações, e além disso pois todas as portas reservadas pelo IANA ao TCP são automaticamente reservadas ao SCTP. 5 Aplicação Aplicação Acessar recursos da rede Apresentação Traduzir, criptografar, comprimir Sessão Estabelecer, gerenciar e encerrar sessões Transporte Entrega confiável ponto a ponto, correção de erros Rede Encaminhamento de pacotes da origem ao destino, conectar redes Enlace Entrega de nó em nó, frames/quadros de bits Física Transmitir bits por meio físico, especificações mecânicas e elétricas DNSO DNS – Domain Name System ou sistema de nomes de domínio é uma aplicação que realiza o serviço de identificação de computadores na rede por meio de um nome. O DNS atende as outras aplicações, permitindo o uso de endereços da camada de aplicação – URLs ou um endereço de e-mail – ao invés de endereços lógicos da camada de rede (endereço IP). Diferentemente das pessoas, a rede identifica os computadores por seu endereço IP, totalmente numérico e de difícil memorização. Por causa disto é necessário um serviço que possa relacionar um nome de domínio ou de um host à um endereço IP: este serviço é o DNS.Os servidores DNS da internet estão organizados em uma hierarquia na forma de uma árvore invertida de nomes de domínio.Esta “árvore” de domínios comporta até 128 níveis, partindo da raiz – nível 0 –até o nível mais baixo – nível 127. Cada nó ou subdivisão da árvore é identificado por um rótulo (label) exclusivo que não se repetirá naquele nível. Uma sequência de rótulos separadas por pontos “.” forma um nome de domínio.Os domínios podem ser genéricos – por especialidade – como “.edu”, “.com”, “.net”, por área geográfica ou país, como “.br”, “.ch”, “.ar”.Os domínios contêm diversos servidores de DNS, sendo o principal chamado de servidor DNS RAIZ. Este servidor define uma ZONA, à qual estão vinculados todos os demais servidores DNS primários e secundários. O servidor primário armazena e mantém atualizada a tabela de nomes do domínio, enquanto o servidor secundário mantém uma cópia desta tabela para atuar em caso de falha do servidor primário.Para que um nome possa figurar em um servidor de domínio é necessário que seja cadastrado em uma entidade registradora homologada pela ICANN - Internet Corporation for Assigned Names and Numbers – Corporação da Internet para Designação de Nomes e Números. No Brasil o cadastro é mantido pelo registro.br aos cuidados da FAPESP – Fundação de Amparo à Pesquisa do Estado de São Paulo. Juntamente com o nic.br – Núcleo de Informações e Coordenação do Ponto BR este cadastro define os nomes de domínio para o território brasileiro.O DNS consiste em uma aplicação cliente/servidor. Um host executando o módulo cliente encaminha uma mensagem de consulta à um host executando o servidor – ou um servidor DNS. A mensagem compõe-se de um cabeçalho com as informações do cliente e uma seção de perguntas, que contém os nomes de domínios a serem traduzidos para endereços IP.O servidor DNS devolve uma mensagem de resposta formada pelo cabeçalho, com as informações do cliente e do servidor, a seção de perguntas, uma seção de respostas, uma seção de autoridades e uma seção de informações adicionais.O que acontece se um servidor primário não conseguir resolver um determinado nome? Ele repassará aos nós superiores da hierarquia do domínio para que estes resolvam o nome. Caso a solicitação chegue até o servidor raiz sem a descoberta do IP, um erro será devolvido na mensagem de resposta.O DNS pode usar tanto o TCP quanto o UDP, e faz as conexões através da porta 53. Para pacotes de mensagem de resposta cujo tamanho não exceda os 512 bytes – tamanho típico de um pacote UDP – este protocolo, o UDP, será usado. Caso o tamanho da mensagem de resposta ultrapasse os 512 bytes ou não seja conhecido o tamanho, então será usada uma conexão TCP.DDNS – Dynamic Domain Name SystemO sistema de nomes de domínio dinâmico – DDNS é uma evolução do DNS devido às constantes mudanças nas redes, com a inclusão de novos hosts e domínios ou eliminação de hosts ou domínios. Promover uma atualização de grande escala é inviável de forma manual. No DDNS, quando um nome é resolvido as informações são enviadas por meio de DHCP para o servidor primário do domínio, que cuida da replicação deste novo conjunto para os demais servidores, incluindo os servidores de DNS secundários. Para evitar o uso inadequado o DDNS pode usar mecanismos de autenticação, garantindo que somente servidores autorizados possam publicar as mudanças.DNSSEC – Domain Name System SecureO sistema de nomes de domínio seguro é uma versão de DNS que utiliza a criptografia e a assinatura digital para a manutenção e o acesso à base de dados do sistema. O uso deste tipo específico de serviço tem por objetivo evitar ataques de DNS forjado.TELNETO programa aplicativo cliente/servidor TELNET – de TErminaL NETwork é uma aplicação para serviços de terminal virtual que provê uma conexão a um sistema remoto por meio da rede. É a aplicação padrão do TCP/IP para os serviços de terminal virtual de acordo com a ISO – International Standard Organization. O TELNET permite que um host crie, por meio de terminal local, uma conexão a um host remoto, fazendo com que este terminal se comporte como se fosse um terminal do sistema remoto. Um terminal, neste cenário, é um dispositivo composto de Teclado, Monitor e Mouse – ou um computador emulando terminal – que possibilita a interação do usuário com os sistemas do computador remoto. O uso de terminal é típico de sistemas operacionais de tempo compartilhado - Time sharing – como o UNIX e o LINUX. O TELNET provê uma interface universal chamada NVT – Network Virtual Terminal – que utiliza um conjunto de caracteres padrão, pois hosts diferentes podem usar diferentes conjuntos de caracteres, em função do idioma ou do sistema operacional utilizado por cada um.Para estabelecer a comunicação com o host remoto o TELNET usa uma conexão TCP e a porta 23 do servidor. O funcionamento do TELNET ocorre de três modos de operação: O modo Padrão, utilizado quando nenhum outro modo for negociado, e aquele no qual o eco é local, isto é, uma vez digitado um caractere, o próprio cliente (terminal local) faz a apresentação do mesmo na tela, porém só transmite para o servidor (host remoto) a linha inteira (ou até que pressionada a tecla ). No modo Caractere cada vez que um caracter é digitado o mesmo é enviado ao servidor, que o retransmite de volta para que o cliente faça a apresentação na tela. Isto gera dois efeitos: em conexões mais lentas ou congestionadas, pode haver um retardo entre a digitação e a apresentação do caracter; além disso cada caracter digitado vai gerar três segmentos de TCP na rede. No modo Linha a edição de linhas (eco, correção, etc.) é realizada pelo cliente. Quando finalizada a edição pela tecla então toda a linha é enviada para o servidor. Correio EletrônicoO serviço de correio eletrônico usa uma arquitetura com três componentes principais, a saber: O User Agente (UA), agente de usuário, é o serviço ou aplicação responsável pelas operações do e-mail no cliente, seja o remetente ou o destinatário; O Message Transfer Agent (MTA), agente de transferência de mensagens, é a aplicação cliente/servidor que responde pelo envio de mensagens à um servidor de correio eletrônico; Message Access Agent (MAA), agente de acesso às mensagens, é a aplicação cliente/servidor responsável por buscar as mensagens em um servidor de e-mail. Um serviço de Correio Eletrônico pode operar de quatro modos distintos. No primeiro modo, o remetente e destinatário est]ao conectados no no mesmo sistema. Neste caso é necessário apenas o uso dos programas User Agent (UA). O remetente faz uso do UA para preparar e encaminhar seu e-mail para o remetente que, quando usar seu UA, receberá a mensagem. É o caso típico do serviço “mail” do UNIX / LINUX.Em um segundo modo, o remetente e destinatário estão conectados a sistemas distintos. Então é necessário o uso de dois programas User Agent (UA) e um par de programas Message Transfer Agent (MTA), que funcionam em um modelo cliente/servidor para encaminhar a mensagem de um sistema ao outro. Este é o caso de uma mensagem de e-mail trocada entre dois sistemas UNIX / LINUX conectados à rede.Em um terceiro modo o Remetente faz parte de uma LAN / WAN e o destinatário está conectado diretamente ao serviço de correio eletrônico. Neste modo é necessário o uso de dois programas User Agent (UA) e dois pares de servidores Message Transfer Agent, cada par funcionando em modelo cliente / servidor para o encaminhamento da mensagem de um sistema até o outro.Finalmente, no quarto modo, o remetente e destinatário estão conectados ao serviço de correio eletrônico por meio de uma LAN / WAN. É necessário o uso de dois programas User Agent (UA), dois pares de servidores Message Transfer Agent (MTA) e um par de servidores Message Access Agent (MAA). Este é o cenário típico atualmente na internet.SMTP – Simple Mail Transfer ProtocolO SMTP - Simple Mail Transfer Protocol ou Protocolo Simples de Transferência de Mensagem é o protocolo que define a comunicação entre cliente e servidor do Message Transfer Agent (MTA). O SMTP utiliza a porta 25 (conexão em texto plano)1 ou a porta 465 (conexão criptografada via SSL). Em um processo típico de envio de e-mail o SMTP é utilizado tanto entre o cliente (UA) e o servidor de correio quanto entre os servidores de correio MTA).POP3 – Post Office Protocol versão 3O POP3 – Post Office Protocol versão 3 ou Protocolo de Posto de Correio é o protocolo que define a comunicação entre cliente e servidor Message Access Agent (MAA) para acessar as mensagens deixadas em um servidor de e-mail. O POP3 acessa as mensagens no servidor de e-mail e as disponibiliza para o UA apresentá-las ao seu destinatário. O POP3 permite o acesso em dois modos, o modo keep e o módulo delete. No modo keep as mensagens são acessadas, porém mantidas no servidor de e-mail, e, portanto, podem ser acessadas novamente a partir de outro cliente MAA. No modo delete as mensagens são acessadas e excluídas do servidor de e-mail, sendo mantidas no UA a partir deste ponto. O POP3 utiliza a porta 110 do TCP para acessar as mensagens de correio eletrônico em um servidor.IMAP4 – Internet Mail Access Protocol versão 4O IMAP – Internet Mail Access Protocol ou Protocolo de Acesso a Correio pela Internet é o protocolo que define a comunicação entre cliente e servidor Message Access Agent (MAA) de forma similar ao POP3, porém com muitos recursos adicionais, como por exemplo: É possível acessar o assunto de um e-mail antes de transferi-lo para o UA; É possível pesquisar um conteúdo específico nos e-mails do servidor; É possível baixar parcialmente um e-mail (sem as imagens, vídeos ou anexos, por exemplo); Também é possível que o usuário gerencie pastas e defina o armazenamento de suas mensagens nestas pastas no servidor de e-mail. O IMPA4 utiliza a porta 143 do TCP para as conexões cliente / servidor com o servidor de e-mail.TRANSFERÊNCIA DE ARQUIVOS - FTP – File Transfer ProtocolO FTP – File Transfer Protocol ou Protocolo de Transferência de Arquivos é o protocolo padrão do TCP/IP para transferência de arquivos entre hosts. É uma aplicação cliente / servidor que estabelece duas conexões entre os hosts: uma para os dados e outra para o controle da transferência, e utiliza as portas 20 e 21 para estas duas conexões. Para acessar o servidor e fazer uma transferência é necessário ter uma conta com um nome de usuário (login) e uma senha. A transmissão dos dados do FTP é feita por uma conexão TCP. É possível utilizar também o FTP Anônimo para arquivos de acesso público. Neste caso, geralmente não é necessário login e senha, porém o padrão é que sejam:Login: anonymousSenha: guestNestes casos o acesso ao sistema é restrito e poucas operações são permitidas.Outra alternativa para o FTP é o TFPT - Trivial File Transfer Protocol , um protocolo de transferência de arquivos muito simples e muito semelhante ao FTP. É muito utilizado para transferir pequenos arquivos entre hosts de uma rede, como, por exemplo, quando um terminal remoto ou um cliente inicia o seu funcionamento, a partir do servidor.6 AplicaçãoA World Wide Web é um serviço cliente/servidor distribuído, no qual um cliente (browser) pode acessar serviços em um ou mais servidores distribuídos por diversas localidades. Os serviços constituem-se em sua maioria em provimento de conteúdo. O conteúdo é distribuído em sites, e cada site administra seus documentos ou páginas web, com um servidor provendo o acesso aos documentos mediante a requisição do browser do cliente.O cliente (browser) é aplicação que viabiliza o acesso, a apresentação dos documentos e a interação com o usuário. É formado por três partes: o controlador, que provê a interface com o usuário (teclado, mouse e tela), os programas clientes, que efetivamente acessam os documentos arquivados nos servidores, e os interpretadores, que apresentam os documentos de acordo com o padra o por eles definidos.O servidor armazena as páginas e os elementos que as compõem. Ao receber uma solicitação de um cliente, busca a página e a transfere para o cliente para que possa interpretá-las e exibi-las. O servidor também mantém as páginas solicitadas anteriormente em cache para melhorar a eficiência, pois é provável que o acesso à uma página não seja único. Um servidor é um computador que utiliza técnicas multitarefa / multithread / multiprocessamento para melhorar o desempenho, e assim providenciar o atendimento a vários clientes simultâneos.A URL - Uniform Resource Locator ou localizadora uniforme de recursos é utilizada pelo protocolo HTTP para prover o acesso a documentos distribuídos mundo afora. Uma URL é um padrão para a especificação de qualquer tipo de informação na Internet. O formato de uma URL é: protocolo://host:porta/path, onde:Protocolo: Identifica o tipo de aplicação utilizada para acessar o conteúdo;Host: Nome do computador que armazena as informações. Geralmente começa com a designação www, porém isto não é obrigatório;Porta: Número da porta (0 – 65535) para acesso ao HostPath: O caminho para chegar até a informação na estrutura de diretórios do Host. Utiliza o mesmo modelo do sistema operacional UNIX.A função do cookie é armazenar informações da sessão e do cliente no host utilizado para o acesso ao site. O formato de um cookie geralmente é um arquivo de texto ou sequência de caracteres contendo, na maioria dos casos: - O nome de domínio do cliente; - Informações coletadas pelo servidor relativas à sessão do cliente - Data e horaOs documentos estáticos apresentam uma estrutura fixa. O seu conteúdo é definido na criação do documento.Os documentos dinâmicos, ao invés disso, são criados pelo servidor à cada solicitação de um cliente.Os documentos ativos são os que implicam na execução de um código pelo próprio cliente. Estes documentos resultam de uma interação com o usuário ou com o host do cliente. Estes códigos são geralmente formados por Applets Java ou JavaScript. O que diferencia estes códigos é que os Applets são compostos de código executável, enquanto o JavaScript é composto por texto plano.A HTML – Hipertext Markup Language ou linguagem de marcação de hipertexto.HTTP – HyperText Transfer ProtocolO HTTP - HyperText Transfer Protocol ou protocolo para transferência de hipertexto é o protocolo utilizado para acessar os dados na WEB. Pode-se dizer que é uma combinação de FTP e SMTP: faz a transferência de arquivos do mesmo modo que o FTP usando conexão TCP, porém com apenas uma conexão. E utiliza mensagens para a requisição de dados como o SMTP.O HTTP usa os serviços TCP na porta 80 por padrão. Além disso o HTTP também inclui comandos ou métodos nas mensagens, tais como GET, POST e PUT, que são interpretados pelos clientes e servidores da Web e geram respostas em formato de códigos, dentre os quais o mais conhecido é o 404 (Not Found). O HTTP requer uma conexão persistente, partindo do princípio que, uma vez transferida e exibida uma página, haverá uma interação com o usuário que resultará em nova mensagem ou consulta. Então o servidor mantém a conexão mesmo após enviar a resposta ao cliente.O HTTP permite o uso de servidores PROXY, os quais mantém uma cópia dos documentos em seu cache. Neste caso, o cliente consulta primeiro o PROXY: se a informação não for localizada, então o próprio PROXY consulta o WEB Server para obter a informação atualizada. Isto reduz o tráfego na rede de forma significativa, especialmente em redes locais de grande porte.Sistema de Gerenciamento de RedesUm sistema de gerenciamento de redes é composto de um conjunto de atividades e recursos para atender às principais funções do gerenciamento de rede, que podem ser agrupadas em: Gerenciamento de configuração: tem por finalidade informar o estado de cada elemento e sua relação com os demais a cada instante, incluindo as mudanças e problemas ocorridos. Geralmente estas informações são fornecidas pelos processos de reconfiguração e de documentação (software e hardware) da rede; Gerenciamento de falhas: trata do funcionamento adequado de cada elemento da rede, buscando o bom funcionamento da rede como um todo. O processo de gerenciamento de falhas da rede comporta duas abordagens: gerenciamento reativo e gerenciamento proativo. O gerenciamento reativo abrange as tarefas de detecção, isolamento, correção e registro de falhas. O gerenciamento proativo tem por objetivos impedir a ocorrência de falhas por meio de medidas de prevenção e identificação de sinais divergentes, ou mesmo da utilização de critérios específicos como a vida útil e a capacidade de trabalho de determinados elementos da rede; Gerenciamento de desempenho: busca a melhor eficiência os equipamentos e da rede como um todo, e trabalha e, conjunto com o gerenciamento de falhas. Trata-se do monitoramento e controle da rede com base em critérios quantitativos e qualitativos que analisa constantemente a capacidade (determinada pelos equipamentos e meios de transmissão), o tráfego na rede (representa a quantidade de bits ou bytes que são encaminhados e recebidos pelos nós de rede em função do tempo), o throughput (taxa de transferência medida em um nó da rede ou trecho da rede para determinar se há um gargalo ou estrangulamento no tráfego) e o tempo de resposta (intervalo de tempo entre o encaminhamento de uma solicitação de usuário e o recebimento da resposta). Gerenciamento de segurança: é o processo que concentra as atividades de controle de acesso à rede e aos elementos da rede. É o responsável pela aplicação da política de segurança – especialmente no que diz respeito a tráfego e acesso, e depende de todos os demais processos para fazer a aplicação, o monitoramento e o controle de uso e acesso aos recursos da rede; Gerenciamento de contabilização: providencia a quantificação de acessos e o uso dos recursos da rede, conhecida como Tarifação. Esta medição é necessária para efeitos de desempenho e segurança, e tem como principais objetivos evitar o monopólio de recursos escassos ou críticos da rede – como o link de internet, por exemplo - e promover o uso da forma mais eficiente possível. Além disso a contabilização provê informações para os administradores planejarem a expansão e a atualização da rede em função da demanda e do desempenho. É comum também haver o fornecimento de informações da tarifação para fins de Auditoria. SNMP – Simple Network Management ProtocolO protocolo simples para gerenciamento de redes é um Framework para gerenciamento de dispositivos em rede com base no TCP/IP e que usa o conceito de gerente e agente. É um protocolo do nível de aplicação, o que permite sua utilização independe das características físicas da rede e dos fabricantes do hardware. Um elemento gerente – ou gerenciador – é um host ou estação que executa uma aplicação SNMP Cliente. Um elemento agente é um equipamento de rede que executa uma aplicação SNMP Servidor. O gerenciamento é o resultado da interação entre o cliente e o(s) servidor(es). O agente é responsável por coletar as informações e mantê-las em uma base de dados, e encaminhá-las ao gerente quando solicitado, para que o gerente avalie as informações e também possa endereçar ações ao equipamento no qual o agente está em execução. Os agentes também podem transmitir mensagens de alerta, os traps, no caso de identificação de situações anômalas, falhas ou problemas de capacidade.O SNMP geralmente é implementado em uma ferramenta mais abrangente que cuida da criação e atualização de estatísticas e de sua apresentação, geralmente em formato gráfico. Além disso o SNMP conta com dois protocolos auxiliares: SMI – Structure of Management Information, ou estrutura de informações de gerenciamento: é o protocolo que define as regras de atribuição de nomes, estabelece tipos de objetos e mostra como codificar os objetos e valores. Porém não define o número de objetos, não lhes dá nomes e tampouco atua na associação entre os objetos e seus valores. MIB – Management Information Base, ou base de informações de gerenciamento: é o protocolo que cuida da criação de um conjunto de objetos, nomes, tipos e relações entre si para um equipamento gerenciável da rede, formando um banco de dados para o equipamento. Estas informações serão solicitadas pelo SNMP e, em função delas, determinadas ações poderão ser comandas ao agente. " }, { "title": "Anotações sobre Programação Orientada a Objetos", "url": "/posts/programacao-orientada-objetos/", "categories": "Estudos-faculdade", "tags": "java, poo", "date": "2020-03-06 08:00:00 -0300", "snippet": "Paradigmas de programação e história da programação orientada a objetosPor meio do paradigma procedural que geralmente iniciamos o aprendizado na programação, podemos citar como exemplo a linguagem C, que utiliza exclusivamente esse paradigma. No paradigma procedural baseamos nosso código em comandos que mudam o estado da memória de forma detalhada e sequencial, ou seja, procedural. Reservamos espaços de memória por meio de variáveis para armazenar nossos dados e criamos funções que definem comportamentos desejados para esses dados. Esse paradigma se aproxima da forma com que o processador interpreta os comandos e trabalha com os dados efetivamente, dando maior liberdade para o programador desenvolver algoritmos eficientes.Junto ao paradigma procedural surgiu também o paradigma funcional, no qual o código é pensado e descrito por meio da resolução de funções matemáticas. Esse paradigma facilita o desenvolvimento de certos algoritmos que são mais facilmente representados de forma puramente matemática. Trata-se de um paradigma ainda muito utilizado em certas linguagens que combinam paradigmas como a linguagem Scala.Outro importante paradigma que surgiu na década de 50 foi o paradigma lógico, no qual uma base de declarações lógicas matemáticas é gerada pelo programador com a qual o computador se baseia para calcular respostas fundamentadas na base inicialmente criada. Uma linguagem proeminente que adota esse paradigma de forma exclusiva é o Prolog, que possui diversas aplicações na inteligência artificial.Em meados dos anos 60, um pesquisador chamado Alan Kay, influenciado por sua formação em biologia e matemática, além de outras tecnologias da época, como Sketchpad e Simula, pensou em uma nova arquitetura de programação que chamou de paradigma orientado a objetos. Em sua concepção original, a programação orientada a objeto deveria se basear em células independentes trocando mensagens entre si, retirando o foco dos dados. As linguagens de programação Simula e Smalltalk foram as primeiras a adotar as práticas propostas por Alan Kay.graph LR A[Paradigmas de programação] --&gt;B[Imperativo] A--&gt; C[Declarativo] B--&gt;D[Estruturada] B--&gt;E[Orientada a objetos] C--&gt;F[Lógica] C--&gt;G[Funcional]Paradigmas de tipo Imperativo, voltados para representar os comandos que resolvem o problema, focado no COMO resolver. Em contrapartida temos os paradigmas do tipo declarativos, que não focam nas mudanças de estado sequencial de um programa, mas sim O QUE se deve resolver.Paradigma de programação orientada a objetosSua grande popularidade influenciou todas as principais linguagens de programação de hoje, C++, C#, PHP, Python e Java que é a linguagem base de nossa disciplina.Em programação estruturada o foco está nas ações, por exemplo: em um programa de computador de vendas, o conjunto de instruções que efetua a compra de itens por um cliente geralmente seria agrupado em uma função chamada comprar(). Porém, em um sistema orientado a objetos, pensamos primeiro no objeto, “Quem está realizando essa compra?”, e teríamos um objeto cliente com todos os seus dados em específico e teríamos um comando como cliente.comprar(). Associamos sempre os objetos (cliente neste exemplo) na ação (comprar), que deixa mais claro e intuitiva a leitura dos códigos, pois tem maior contexto pensar em um “cliente comprando” do que simplesmente na ação comprar isolada, trazendo o código mais perto de como entendemos o mundo. Associando essa prática com outros conceitos como herança, polimorfismo, encapsulamento, entre outros, promovemos ganhos de produtividade especialmente na manutenção de códigos pela maior facilidade no entendimento.História do JavaA Linguagem Java surgiu no início dos anos 90, em uma importante empresa de tecnologia chamada Sun Microsystems. A equipe responsável pelo desenvolvimento dessa linguagem atuava no chamado Green Project e foram liderados pelo cientista da computação James Gosling. O Green Project tinha por objetivo gerar tecnologias voltadas para conectividade de equipamentos domésticos. A comunicação entre os dispositivos deveria se dar por meio de uma linguagem de programação que fosse independente de plataforma. A linguagem Oak possuía o diferencial de ser uma linguagem interpretada por uma máquina virtual fornecida pela Sun. Todo o dispositivo que rodasse a máquina virtual da Sun, seria capaz de executar códigos Oak sem necessidade de compilação específica para o dispositivo em questão. Por questões legais e de registro de marca, a linguagem Oak, em 1995, mudou seu nome para Java.Na década de 1990 e 2000, a popularização da internet levou uma grande popularização da linguagem Java, que recebeu suporte de grandes companhias de informática, como IBM. E, de certa forma, o objetivo inicial Green Project foi atingido com Java sendo utilizado para conectar todo o tipo de dispositivo móvel, celulares, tablets, computadores, e até uma das primeiras sondas espaciais robóticas a atingir solo marciano em 2004 utilizou linguagem Java.A linguagem Java adotou licença de software livre GPL v3 em 2006, o que significa que os programas feitos pela Sun para permitir o funcionamento do Java, assim como suas bibliotecas, possuem código aberto para consulta, cópia e modificação, desde que o desenvolvedor que faça modificações também disponibilize seu código livremente. A Sun Microsystems foi adquirida pela Oracle, em 2010, que é quem oferece suporte ao Java até hoje.Trata-se de uma linguagem Orientada a Objetos com sintaxe baseada na linguagem C.Organização do JavaTradicionalmente as linguagens de programação passam por um processo denominado compilação, que transforma o código alto nível escrito pelo programador no que chamamos de código de máquina, ou binário. Esse código nativo é lido pelo processador que executa as instruções. Os programas .exe do windows são um exemplo de binário.Em contrapartida existem também linguagens que são interpretadas que não passam por esse processo de compilação, de modo que o código escrito pelo programador em tempo de execução é traduzido para código de máquina.Códigos interpretados são essencialmente menos eficientes do que códigos compilados, pela quantidade extra de instruções que requer sua interpretação. Porém possuem a vantagem de serem facilmente portados para diferentes plataformas justamente por não o necessitar de recompilação para cada plataforma, por exemplo um mesmo código interpretado sem alterações pode ser executado em diferentes computadores com sistema operacional Linux, Windows ou Mac.Quanto ao Java dependendo do ambiente de execução é possível trabalhar com ele tanto interpretado quanto compilado. Porém tipicamente ele funciona em um processo em dois passos. Primeiro o código alto nível é compilado para um conjunto de instruções internas do java denominado bytecode. Esse código bytecode, posteriormente, é interpretado por um programa chamado máquina virtual Java, em inglês Java Virtual Machine, e ao longo das aulas chamaremos pela sigla JVM. As JVM para as principais plataformas são mantidas pela Oracle, mas podem ser desenvolvidas de forma independente para os mais diversos dispositivos por qualquer equipe, visto que possui licença livre. Portanto um mesmo bytecode pode ser executado em qualquer sistema que possua uma JVM.Pelo fato de o Java utilizar JVM para interpretar seus bytecodes, existe uma perda em desempenho quando comparado a um código compilado nativo. Porém as JVM evoluíram muito ao longo dos anos, e uma das principais tecnologias nesse sentido é o chamado Hotspot. Estudos estatísticos mostram que, na grande maioria dos programas, 80% do processamento se concentra em somente 20% do código. O Hotspot é uma tecnologia que identifica esses trechos de código com muito processamento e executa uma compilação dos mesmos durante a execução do código. Essa tecnologia de compilação em tempo de execução é chamada de Just in time compilation, mais conhecida pela sigla JIT. A combinação das duas tecnologias, dentre outras melhorias, tornou o Java muito eficiente, diminuindo a distância em relação às linguagens compiladas.Quando se deseja apenas executar bytecodes do Java, é necessário instalar em sua máquina o Ambiente de execução Java, em inglês, Java Runtime Environment, mais conhecido pela sigla JRE. Ela é composta principalmente pela JVM e bibliotecas padrão do Java.Agora quando desejamos programar em Java, precisamos instalar o Kit de desenvolvimento Java, em inglês Java Development Kit, mais conhecido pela sigla JDK. Ele é composto por um conjunto de utilitários como o compilador de bytecode além de uma JRE.Versões do Java O Java ME visa a construção de softwares para dispositivos embarcados, sistemas de propósito específico com poucos recursos computacionais. Ela é compatível com uma biblioteca básica de classes e se torna especialmente importante no contexto de soluções desenvolvidas pensando na internet das coisas. Java SE é a edição padrão do Java com o principal conjunto de bibliotecas, perfeita para desenvolver programas desktop e de console. Por console entenda programas com interface puramente em modo texto que são geralmente executados por prompt de comando sistema operacional Windows ou terminal do Linux. Por fim Java EE é a edição mais completa, já vem equipada com bibliotecas prontas para soluções empresariais especialmente voltadas para internet e banco de dados. Trata-se de uma série de especificações que foi desenvolvida integralmente ou parcialmente na forma de servidor de aplicações por diversos fornecedores. Uma importante tecnologia que ajuda a formar a espinha dorsal da internet hoje.Os principais elementos que compõem o projeto são:Bibliotecas: Que são bytecodes com funcionalidades específicas implementadas. Permitem o programador reaproveitar códigos geralmente desenvolvidos por equipes diversas e que já são muito bem testados e eficientes. No caso o Eclipse já inclui uma biblioteca básica em todos os projetos.Pacotes: Um conceito semelhante ao de pasta/diretório para organizar a estrutura dos códigos Java. Supondo que temos um projeto grande com muitos códigos, podemos agrupar os arquivos ligados a bancos de dados em um pacote e que estão ligados a interface visual em outro por exemplo. Usualmente o pacote principal de um projeto é nomeado com o inverso do domínio da sua instituição. Por exemplo empresa.com se torna com.empresa essa é uma prática comum porém não é necessário. Esse pacote principal fica inserido dentro de uma pasta nomeada src (que vem da palavra source, código em inglês).Classe: Os códigos são descritos em arquivos com extensão .java e geralmente temos um arquivo por classe.Visão Geral sobre o Código JavaPrincipais comandosEntrada e saída:System.out.print(\"msg1\"); //Imprime uma mensagemSystem.out.println(\"msg2\"); //Imprime uma mensagem e pula linhaSystem.out.printf(\"msg3 %d\", 10); //Imprime mensagens formatadas, análogo ao printf da linguagem Cimport java.util.Scanner;Scanner teclado = new Scanner(System.in);int idade = teclado.nextInt();Tipos de dados Tipo Tamanho Descrição byte 1 byte Números inteiros (-128 até 127) short 2 bytes Números inteiros (-32.768 até 32.767) int 4 bytes Números inteiros (-2.147.483,648 até 2.147.483.647) long 8 bytes Números inteiros (-9.223.372.036.854.775.808 até 9.223.372.036.854.775.807) float 4 bytes Armazena números inteiros e fracionários até 6 a 7 dígitos decimais. double 8 bytes Armazena números inteiros e fracionários até 15 dígitos decimais. boolean 1 bit Armazena apenas 0 ou 1 (false ou true) char 2 bytes Armazena um único caractere, letra ou ASCII values Classes e AtributosOs objetos são os elementos em si que compõem o nosso sistema, enquanto as classes são a descrição desses objetos, e como o nome sugere, classificam um conjunto de objetos que pertençam a um mesmo conjunto.De forma geral cada objeto possui três aspectos principais: Atributos: São as variáveis que descrevem o objeto. Métodos: São como funções que dizem o que cada objeto faz. Estado: Seria o valor de cada atributo que representa aquele objeto específico.A convenção entre os programadores Java é a de criar um arquivo separado para cada Classe Java. O arquivo que contém o método main também é uma classe própria geralmente.No POO, um objeto pode ser chamado de instância de uma classe e criar uma nova instância, o que é chamado de instanciação.MétodosMais do que agrupar um conjunto de variáveis, as classes também possuem o que chamamos de métodos, que são equivalentes às funções em programação estruturada, um bloco de código que só é executado quando chamado. Os métodos podem receber dados de entrada (parâmetros) e opcionalmente um valor de retorno. A diferença básica do método em relação à função, é que o método está sempre associado a um objeto e consegue acessar os dados internos do objeto associado.Padrões e modificador StaticO padrão principal da linguagem é o Camel Case, que consiste em descrever uma palavra composta ou frase sem dar espaços ou utilizar underline (ou sublinha), mas utilizando letras maiúsculas para indicar a letra inicial da próxima palavra.Dentro do Java, os padrões são os seguintes: Pacotes: são descritos inteiramente em letras minúsculas. Ex: com.empresa Classes: inicia com letra maiúscula e segue o Camel Case. Ex: Aluno Métodos, atributos e variáveis: iniciam com letra minúscula e seguem o Camel Case. Ex: nomeCompleto Constantes: inteiramente com letras maiúsculas separadas por underline. Ex: VALOR_PI A palavra reservada static possui dois usos na linguagem JAVA. Um quando é associada a um método e outro quando é associada a um atributo. Nos dois casos significa que o atributo ou método poderá ser acessado de forma independente de instâncias. Métodos e atributos sempre são relativos a um objeto, porém métodos e atributos estáticos são independentes. Um atributo estático pode ser entendido como uma variável global da classe, todas as instâncias podem trabalhar sobre a mesma variável.ConstrutoresNo bloco de código de um construtor qualquer código pode ser escrito, mas usualmente utilizamos para carregar alguma informação, especialmente informações que sejam cruciais para o funcionamento do objeto no momento da sua criação. Os construtores são criados de forma semelhante aos métodos, porém, devem possuir o mesmo nome da classe e não possuem valor de retorno. É possível também possuir diversos construtores para uma mesma classe variando apenas os parâmetros de entrada.Quando criamos uma classe, um construtor vazio implícito que não executa nenhum código é criado. No entanto, a partir do momento que criamos um construtor qualquer, esse construtor vazio implícito deixa de existir.VisibilidadeOutra prática que nos ajuda a simplificar o uso das classes é esconder métodos e atributos que sejam de uso interno da classe, de forma que, ao fazermos uso da classe posteriormente, não seja exibido detalhes de implementação, e sim apenas os métodos e atributos que sejam pertinentes. Antes da definição de cada método, atributo e classe, podemos colocar um dos três modificadores: Public: o elemento é público e pode ser acessado por qualquer outra classe sem restrições. Private: o elemento é privado e só pode ser acessado internamente na classe. Protected: o elemento é protegido e será acessado somente de dentro da própria classe, outras classes no mesmo pacote e também por classes filhas. A definição de classe filha será abordada em detalhes na aula de herança. Default (sem nenhum modificador): o elemento, neste caso, é acessível por classes dentro do mesmo pacote.EncapsulamentoEntende-se que o Paradigma Orientado a Objetos possui três pilares, herança, polimorfismo e o encapsulamento. Alguns autores defendem a abstração como um quarto pilar, no entanto, ela pode também ser entendida como parte do encapsulamento.Em uma classe que segue boas práticas de encapsulamento, seria possível trocar a classe por outra que possua a mesma interface (métodos com os mesmos nomes e parâmetros) e, por mais que as suas implementações internas mudem, o sistema continuará funcional sem maiores mudanças.Em resumo, a vantagem do encapsulamento são: A abstração oferecida em que o funcionamento interno dos objetos da classe não fica visível ao programador que utiliza a classe. A possibilidade de acrescentar funcionalidades à classe desde que respeitando a interface original manterá o sistema funcional sem alterações. Simplificação da utilização dos objetos em um alto nível acelera o desenvolvimento dos códigos. O sistema fica robusto a mudanças internas, mesmo uma substituição completa do código que poderia até mesmo ser desenvolvido por outra equipe que não manteve contato com a primeira, bastando respeitar a interface. Collections graph BT A[TreeSet] --&gt; B[Set - Conjunto] C[HashSet] --&gt; B D[LinkedHashSet] --&gt; B E[Vector]--&gt;F[List - Lista] G[LinkedList]--&gt;F H[ArrayList]--&gt;F I[PriorityQueue]--&gt;J[Queue - Fila] K[SynchronousQueue]--&gt;J L[DelayQueue]--&gt;J M[HashTable]--&gt;N[Map - Mapas] O[LinkedHashMap]--&gt;N P[HashMap]--&gt;N B &amp; F &amp; J &amp; N --&gt; Q[Collections] ArrayList é uma das classes mais comuns dentro da API Collections, como já apresentada anteriormente ele representada um array dinâmico. Os elementos dentro dela possuem uma ordem definida e trazem métodos de manipulação, como remoção, inserção, busca, entre outros. LinkedList é outra classe que também implementa um array dinâmico com as mesmas funcionalidades do ArrayList tradicional, no entanto, sua implementação interna utiliza a estratégia de lista ligada e realiza as operações de remoção e inserção de forma muito mais rápida e a busca por elementos de forma muito mais lenta em comparação ao ArrayList tradicional. De maneira geral, é mais comum ao longo da execução de um programa que mais buscas sejam executadas do remoções/inserções, portanto, o ArrayList de forma geral é o mais indicado, entretanto, para aqueles casos em que isso não ocorre, contamos com essa alternativa. HashSet na computação, o termo Hash diz respeito a uma função que transforma um valor em outro, e a palavra Set tem diversos significados diferentes sendo que, nessa situação específica, significa conjunto. Então uma HashSet é um conjunto de elementos organizados por meio de uma função Hash. Ela realiza operações de adição, remoção e busca de forma muito rápida, contudo, não garante uma ordem dos elementos. LinkedHashSet é semelhante a HashSet, porém, ele armazena a ordem em que os elementos foram adicionados. HashMap é a estrutura de dados também baseada em Hash, com a diferença que é possível mapear (daí o nome Map) uma ID de um tipo diverso. Por exemplo, podemos ordenar os filmes de um catálogo não por um valor inteiro, mas por uma string contendo o nome do filme seguido do ano de exibição. Não possui ordem garantida. TreeMap semelhante a HashMap, entretanto, também armazena a ordem dos itens, essa ordem pode ser livremente manipulada combinando as características de em um array. LinkedHashMap é semelhante a HashMap, todavia, internamente também armazena a ordem em que os elementos foram adicionados. Queue é uma estrutura de dados geralmente adotada para representar filas de prioridade, queue no inglês significa fila. Ela pode implementar uma fila de prioridade comum, semelhante a uma fila convencional no mundo real em que o primeiro elemento a entrar é o primeiro a ser atendido. Stack é outra classe semelhante a fila de prioridades, mas implementa uma fila reversa à ordem de inserção, o último elemento adicionado é o primeiro a ser tratado, conceito denominado pilha, se empilharmos diversos objetos um sobre o outro, o último objeto empilhado será o primeiro que vamos acessar. Métodos Estáticos Collections Sort (List&lt;&gt; lista): coloca em ordem crescente os itens da lista passada por parâmetro. Shuffle (List&lt;&gt; lista, Random rnd): embaralha de forma aleatória os elementos da lista passada por parâmetro, a aleatoriedade do embaralhamento é dada pelo objeto da classe Random passado por parâmetro também. Max (Collection&lt;&gt; coll, Comparator&lt;&gt; comp): retorna o maior elemento, aceita tanto lista, quanto hash. Como segundo parâmetro, você pode indicar como deseja realizar a comparação com um objeto da classe Comparator, caso passe null como segundo parâmetro, a ordem natural será adotada. Min (Collection&lt;&gt; coll, Comparator&lt;&gt; comp): análogo ao max, porém, retorna o menor elemento. Reverse (List&lt;&gt; lista): coloca todos os itens em ordem reversa. Iterator Quando desejamos visitar os dados em uma estrutura de dados, as estratégias mudam dependendo da estrutura, listas contam com índices inteiros, mapas são indexados pelas chaves que foram definidas, conjuntos não possuem forma de indexação alguma. No entanto, os iterators são uma ferramenta poderosa nesse sentido, pois com eles é possível navegar pelos dados independentes da classe Collections utilizada.O iterator é bastante simples e compatível com diversas estruturas de dados, o que o torna particularmente útil para criar um código flexível e independente da estrutura de dados adotada. Classe LocalDate A classe LocalDate representa datas de forma bem prática. Cada data sendo um objeto LocalDate, para, por exemplo, recuperarmos a data do momento da execução de uma linha de código. LocalDate.now().Se imprimirmos na tela objeto do tipo LocalDate, teremos a impressão no formato americano que coloca o mês na frente do dia. Para representar no formato brasileiro, é necessário criar um objeto do tipo DateTimeFormatter, que estabelece formatações para datas e horários. HerançaÉ possível que uma classe (filha) herde comportamentos (métodos) e características (atributos) de outra classe (mãe), e nessa relação a classe filha pode ter suas características e comportamentos únicos também. De forma geral, a classe herdeira pode ampliar as funcionalidades da classe herdada e também modificar algumas das tais funcionalidades.Termos atribuídos à classe herdada e à classe herdeira: Classe herdada Classe herdeira Classe mãe Classe filha Superclasse Subclasse Classe base Classe específica Classe original Classe derivada Construtores e HerançaOs construtores funcionam de forma parecida com os métodos, pois são códigos executados no momento da instanciação. A aplicação mais comum dos construtores é a definição de valores para os atributos no momento em que o objeto é instanciado. Relembrando o que já sabemos sobre o tema, para criar construtores, devemos fazê-lo semelhante a um método só que sem um parâmetro de retorno e com nome igual ao da classe.Diferente dos métodos e atributos, os construtores não são herdados pelas classes filhas, mas podem ser invocados por elas.Palavras reservadas super e thisO comando super faz uma referência explícita à superclasse, à classe herdada, semelhante à palavra this que faz referência explícita à classe corrente. Outro uso importante e bastante comum da palavra reservada super é para invocar o construtorda classe mãe.Palavra reservada instanceOfAlém de herdar atributos, a tipagem também é herdada. Ou seja, se temos uma classe Base e outra Derivada herdeira de Base, então objetos da classe Derivada também são do tipo Base. Em outras palavras, as classes filhas são consideradas do tipo da classe mãe também. Existe um comando chamando instanceof (instância de, em tradução do inglês), que é utilizado justamente para identificar se uma determinada instância pertence a determinada classe, ele retorna true ou false (verdadeiro ou falso) caso seja ou não uma instância.Herança e UMLAssociação é um cenário bastante comum, em que existe um vínculo entre as classes.Agregação é um tipo especial de associação em que a temos uma classe que representa o todo e outra classe que representa a parte.Composição pode ser entendida como uma variação da agregação, pois também representa uma relação de todo-parte, no entanto a relação aqui é mais próxima entre o todo e a parte, sendo que a parte não faz sentido sem o todo, pois o todo cria e destrói as partes.A herança é outra relação representada pelo UML e serve para indicar qual é a classe geral e a classe especializada. É importante observar que os métodos da classe superclasse são acessados pelas subclasses também.Dependência é outra relação importante que pode ser representada pelo UML. Essa relação indica simplesmente a dependência para compilar de uma classe pela outra.PolimorfismoO nome polimorfismo vem do grego (polýs = muitas; morphé = formas) e geralmente descreve a capacidade de objetos de uma superclasse assumirem a forma (métodos e atributos internos) de diferentes subclasses, mas existem outras situações que também são denominadas de polimorfismo que veremos na sequência.Segundo a classificação mais amplamente adotada na literatura sobre polimorfismo, podemos agrupá-lo em duas categorias, universal e ad hoc:Universal: é o tipo de polimorfismo em que temos um mesmo algoritmo, um mesmo comportamento, que pode ser executado para diversas classes ou dados primitivos.Ad Hoc: é outra forma de polimorfismo, que atua em um conjunto específico de classes para as quais uma mesma chamada de método permite comportamentos diferentes para cada tipo.graph TD A[Polimorfismo] --&gt;B[Universal] &amp; C[Ad Hoc] B --&gt; D[Subtipagem] &amp; E[Paramétrico] C --&gt;F[Coerção] &amp; G[Overloading] Subtipagem: É a forma mais usualmente associada ao nome polimorfismo. Ela ocorre quando temos uma superclasse que possui determinado método, e suas subclasses reimplementam esse método com outro comportamento. Lembramos que uma subclasse, além de herdar métodos e atributos, herda ainda a tipagem, portanto, é possível instanciar uma subclasse e referenciá-la como membro da sua superclasse. Paramétrico: É o tipo de polimorfismo em que uma função e os dados dentro dela podem ser escritos de forma genérica para diferentes tipos de dado. Uma função matemática que você deseja que funcione da mesma forma para valores de entrada do tipo int, float ou double seria um exemplo de uso. Nas linguagens Java e C#, o conceito é chamado de Generics, enquanto no C++ damos o nome de Template. Coerção: Esse tipo de polimorfismo mais frequentemente visto em códigos com tipos primitivos, embora seja possível também com objetos, ocorre quando fazemos conversão seja ela implícita, feitas de forma automática pelo compilador, ou explícita, com código descrevendo a transformação entre tipos diferentes de dados. Overloading: Neste tipo de polimorfismo, temos funções com o mesmo nome, mas com parâmetros de entrada diferentes, o que permite que executem códigos distintos. Em português, podemos chamar esse conceito de sobrecarga. Referência e instanciação Quando criamos uma variável de uma classe na linguagem Java, esta se comporta como umareferência, semelhante ao conceito de ponteiro da C/C++. Em outras palavras, a variável indica(aponta) uma posição de memória. Para indicar que desejamos criar um novo objeto na memóriareservando espaço e efetivamente instanciar o mesmo, utilizamos o comando new. Classe abstrataNo contexto de orientação a objetos, eventualmente teremos classes que não desejamos instanciar.Propriedades das classes abstratas: Pode referenciar objetos de subclasses graças ao polimorfismo. Permite que criemos métodos desprovidos de implementação, mas que obrigatoriamente devem ser implementados por suas subclasses. Não podem ser instanciadas, ocorre um erro ao tentarmos instanciar um objeto dessa classe. Erros de compilação, ao contrário do senso comum, são muito positivos pois são fáceis de se identificar e corrigir, diferentemente de um bug que só será identificado durante a execução do programa e não possui qualquer indicação de onde possa estar no código. Os erros de compilação caem em duas categorias: erros léxicos, quando um comando é escrito errado, e semânticos, quando o comando é escrito corretamente, mas em local que não faça sentido; o compilador detecta esses erros, que são fáceis de localizar. Erros semânticos são aqueles em que o comando está escrito certo, no local certo, mas executa instruções diferentes das desejadas, em outras palavras, o significado do que está escrito não é o que se imaginava. Interface Na linguagem Java, não é possível termos múltiplas superclasses para uma mesma subclasse, certas linguagens permitem isso, como o C++, porém, não é o caso do Java. No entanto, temos o que chamamos de Interface. A palavra interface diz respeito ao meio de ligação/comunicação entre dois sistemas.A Interface força que classes diferentes implementem métodos com os mesmos nomes, entradas e saídas, garantindo que a classe Principal possa acessar as diferentes classes de banco de dados da mesma forma.Em resumo, uma interface pode ser entendida como um protocolo que explica como deve ser aassinatura dos métodos de uma classe.As interfaces funcionam de forma semelhante a classes que não podem ser instanciadas, maspodem servir de referência para cenários de polimorfismo. Interface funciona de forma muito semelhante à herança, no entanto, em vez da palavra extends, utilizamos a palavra implements. Propriedade Interface Classe abstrata Herança Classes podem implementar diversas interfaces. Uma classe só pode herdar uma única superclasse. Métodos Interface só possui a assinatura dos métodos Uma classe abstrata pode implementar códigos dentro de seus métodos, que serão ou não sobrescritos. Atributos Só pode possuir atributos estáticos. Pode ter tanto atributos estáticos quanto não estáticos. Adaptação Fácil adaptar uma classe existente para implementar uma interface, bastando implementar os métodos conforme a assinatura. Adaptar uma classe existente para herdar uma classe abstrata pode ser trabalhoso por ser necessário modificar a hierarquia já existente de heranças. Quando usar? Classes que compartilham mesmo comportamento, assinatura. Classes que compartilham os mesmos atributos e precisam ter seu estado avaliado de forma compatível. Modificações adicionais Ao adicionar um novo método a uma interface, todas as classes devem trazer suas implementações. Ao adicionar um novo método, é possível trazer uma implementação padrão que servirá para todas as classes filhas. EnumEm diversas linguagens de programação, incluindo a Java, existe o conceito de enum, que consiste de uma classe especial de rápida e simples implementação que é capaz de representar um grupo de constantes enumerando-as geralmente por debaixo dos panos, com inteiros em sequência.Geralmente é adotado para representar estados.Para criar um enum, utilizamos a palavra reservada enum em vez de class ou interface. E dentro do corpo do enum, deve vir o nome das constantes separadas por vírgula, pela convenção estabelecida oficialmente pela Oracle. Ademais, as constantes devem sempre descritas em letras maiúsculas na linguagem Java.Enum pode ser declarado no próprio arquivo como uma classe, e geralmente é, ou pode ser declarado internamente dentro de uma classe existente para ser utilizado apenas localmente.Enum, na linguagem Java, é representado como uma classe, que inclusive pode possuir métodos e atributos, no entanto, suas constantes são sempre entendidas como public, static, final. public: as constantes são acessíveis por qualquer classe que possua visibilidade do enum. static: existe apenas uma constante para a classe inteira, e não uma por instância. final: não pode ter o valor alterado em tempo de execução.Quando utilizar enum? Ele é recomendado especialmente em situações em que você tem quedescrever uma coleção de valores fixos que não variam, como meses, cores, baralho de cartas etc.Tratamento de exceções Erro (Error): é um problema sério que ocorre em tempo de execução, impossível para o compilador detectar e que geralmente não tem tratamento para ele. No geral, são problemas na plataforma que está rodando o programa Java.Por exemplo, a falta de memória para alocar recursos necessários do programa gera um erro que, na maioria das aplicações, não existirá meio de se contornar e, na maioria das vezes, o programa deverá simplesmente ser interrompido. A solução real seria realmente agir na plataforma em que o software está rodando e cabe ao programa gerar um log (relatório), ou alerta descrevendo o evento. O Java, ao detectar esse problema, lança esse erro no formato java.lang.OutOfMemoryError. Exceção (Exception): também é um problema, mas que geralmente pode ser manejado pelo programa e tratado de alguma forma. Por exemplo, ao tentar ler dados em um arquivo que foi apagado e não existe mais, irá gerar a exceção chamada pelo Java de FileNotFoundException. Nesta situação, geralmente é possível em vez de simplesmente encerrar o programa repentinamente, apresentar uma mensagem para o usuário e solicitar alguma intervenção e seguir com o programa funcionando.Tanto os erros quanto as exceções no Java, ao ocorrerem, são identificadas e lançadas de umaforma que determinados comandos conseguem recuperar o controle do programa e impedir que ele seja encerrado subitamente. Erros e exceções geram subclasses de uma superclasse Throwable erespeitam a hierarquia da figura a seguir. graph BT A[Checked Exception] &amp; C[Unchecked Exception] --&gt;B[Exception] D[Virtual Machine Error] &amp; E[Assertion Error etc]--&gt;F[Error] B &amp; F--&gt;G[Throwable]--&gt;H[Object] Quando ocorre uma exceção/erro em um método, ele gera um objeto do tipo específico e envia para a máquina virtual Java (JVM). O objeto Exception contém o nome, uma descrição e o estado do programa no momento que ocorreu o problema. A ordenação das chamadas dos métodos é conhecida como Call Stack (pilha de chamadas). Depois isso, ocorre a seguinte sequência de passos. A JVM busca na call stack um método que contenha um bloco de código capaz de tratar a exceção, vamos chamar de bloco tratador de exceção. A busca inicia no método que gerou a exceção e segue ordem reversa de chamada. Ao encontrar um bloco tratador apropriado, ele recebe o controle do fluxo de código junto ao objeto exceção. Por apropriado, entendemos que ele trata um tipo de exceção compatível com a que foi gerada. Se a JVM não encontrar um bloco tratador de exceções na call stack, então a JVM utiliza um bloco tratador de exceções padrão que irá encerrar o programa imediatamente e imprimir uma mensagem no console dando todas as informações da exceção, nome, descrição e a call stack. Lidando com exceções Na linguagem Java, assim como nas principais linguagens de programação, existem os comandos try (tentar) e catch (capturar). O comando try é associado a um bloco de código que será executado e caso um erro ou exceção aconteça o programa não encerrará automaticamente com mensagem de alerta no console, mas, sim, o controle será devolvido ao programa dentro do bloco catch adequado. Opcionalmente, é possível colocar o comando finally (finalmente) que também é associado a um bloqueio de código que será executado independente de o código ter entrado ou não no bloco catch. Criando as próprias exceçõesAlém de tratar as exceções e erros que o sistema lança por padrão, podemos lançar exceções e até mesmo criar nossas próprias exceções. A ideia por trás de lançar exceções está em evitar que o programa continue executando mediante situações anormais e devolver o controle para o método tratador adequado.Por exemplo, se o seu programa falhar em conectar com o banco de dados, o sistema lançará uma exceção de forma automática, provavelmente do tipo java.sql.SQLException. No entanto, se o banco de dados conectar adequadamente, mas um dado crítico para o funcionamento do seu programa não estiver presente na base dados, então não existirá uma exceção e, caso a situação não seja devidamente identificada e tratada, o programa continuará em execução com um comportamento imprevisível.Este é o cenário adequado para se lançar uma exceção própria, identificando que o dado crítico não está presente na base de dados e isso pode ser feito por meio do comando throw. Esse comando é capaz de explicitamente lançar uma exceção qualquer.Tipos de exceções Checked: são exceções verificadas em tempo de compilação, checked em inglês significa checada. Isso significa que ao lançar uma exceção desse tipo o método deve tratar ela com try/catch ou explicitamente anunciar na assinatura do método que pode lançar esse tipo de exceção com a palavra throws, caso não faça nenhuma das duas coisas, o compilador irá gerar um erro. Todo o método A que explicitamente lance uma exception na assinatura obriga que, ao ser invocado por um outro método B, ele deva ou tratar com try/catch ou ele também lançar a exception na sua assinatura. No caso da main, se ela lançar a exceção para quem a invocou, o programa será interrompido imediatamente com mensagem no console informando a exceção. Unchecked: são exceções que não são checadas em tempo de compilação, dispensam o uso de throws na assinatura da função quando não tratadas, fica livre ao programador decidir se precaver com o uso de try/catch ou não. Problemas do tipo Error também não são checados, na hierarquia de classes, as exceções não checadas também são chamadas de RuntimeException. Desenvolvendo sua própria Exception Além de lançar as exceções existentes, é possível criar a sua própria exceção subclasse de Exception ou RuntimeException e até mesmo Error. Ao criar uma exceção que estende Exception, ela será do tipo checada e, se ela estender RuntimeException, será do tipo não checada. Basta criar uma subclasse e ela poderá ser utilizada para descrever uma situação inesperada. IgualdadeNo Java as Strings são objetos e não tipos primitivos, portanto, não é possível comparar o conteúdo com ==, para isso utilizamos um método chamado equals. O método equals é um padrão dentro do Java e serve justamente para comparar conteúdos, não é obrigatório implementar o método equals para todas as classes, mas é uma convenção para aquelas classes que faça sentido a comparação entre objetos. Essa padronização garante a compatibilidade com certas classes do sistema também.Diversas IDE Java, incluindo o Eclipse, conseguem gerar o código do equal automaticamente naopção Source/Generate hashCode() and equals()…Métodos especiais: toString()Como já foi discutido anteriormente, todo o objeto Java é diretamente ou indiretamente subclasse de Object. E a classe Object possui o método toString() que, por padrã,o retorna uma String com o endereço na memória daquele objeto. Esse método toString() é implicitamente acessado sempre que tentamos ler o objeto no formato de uma string.Temos o comando @Override, que serve para indicar que o método está sobrescrevendo outro de sua superclasse, esse comando não é necessário, no entanto, ele possui dois papéis: indicar aos programadores que lerão o código que aquele é um método sobrescrevendo outro e fazer com que o compilador verifique a adequação da assinatura do método. Também é possível em diversas IDEs Java, incluindo eclipse, gerar o código automaticamente para o método toString, indo na opção Source/Generate toString().Modificadores Java (Singleton)Um problema recorrente é a necessidade de termos um objeto que seja instanciado uma única vez e sempre que seja solicitado pelas classes de um projeto seja direcionado ao mesmo objeto. Um conceito semelhante ao de uma variável global, porém, utilizando uma instância.Dentro da literatura de design pattern, a solução para essa situação é a utilização do que chamamos de Singleton. Alguns exemplos comuns de uso do padrão Singleton é quando temos algum tipo de recurso compartilhado. Por exemplo, diversas classes requisitando acesso a uma impressora, banco de dados ou um mesmo arquivo não é interessante que esses recursos sejam acessados paralelamente por múltiplas instâncias, poderia causar conflitos entre as requisições, nesse tipo de situação, Singleton seria bem aplicado. Outro exemplo comum é a classe responsável por efetuar log de atividades. Essa tarefa é constantemente invocada em diferentes etapas de um sistema e ter uma única instância realizando-a minimiza o overhead (trabalho extra de gestão) da classe, visto que essa operação é realizada de forma constante e relativamente independentemente do restante do projeto. Na prática, para criar uma classe Singleton, são necessários dois passos: Ter um construtor privado. Criar um método estático que retorna um objeto da classe em questão instanciado. Conceito conhecido como Lazy initialization (inicialização preguiçosa), em que o objeto é criado depois de declarado." }, { "title": "Tipos de firewalls e suas facilidades", "url": "/posts/firewalls/", "categories": "Estudos-faculdade", "tags": "segurança", "date": "2020-02-28 09:00:00 -0300", "snippet": "Tipos de Firewalls•\t(Stateless) Packet filtering – PFO PF é um firewall que realiza a filtragem de pacotes IP individuais baseado em regras que determinam se cada pacote será transmitido ou descartado. Algumas das regras mais comuns de filtragem são os endereços IP de origem e destino, os endereços da camada de transporte (porta), o campo IP de protocolo e a interface (STALLINGS; BROWN, 2014).•\tStateful packet filtering – SPFFirewalls de filtragem de pacotes com estado verificam as mesmas informações que um filtro de pacotes IP individual, mas vai além monitorando o estado das conexões, criando um diretório de conexões TCP de saída. Com o conhecimento do contexto (a sessão por onde transitam os pacotes IP) e informações das outras camadas do protocolo TCP/IP, o filtro de pacotes com estado consegue cobrir algumas brechas de segurança deixadas pelo filtro de pacotes que não monitora o estado das conexões e torna mais rígidas as regras aplicadas (STALLINGS; BROWN, 2014).•\tApplication gateways - AGAtuando no nível da aplicação, e por isso também chamado de proxy de aplicação, o firewall do tipo application gateway retransmite segmentos TCP seguindo uma implementação específica da aplicação. Assim, conexões que não são compatíveis com a implementação do gateway não conseguem permissão para trafegar dados. Além disso, o gateway pode implementar funções específicas e códigos de proxy diferentes para aplicações específicas, garantindo mais segurança e especificidade na filtragem de conexões do firewall (STALLINGS; BROWN, 2014).Facilidades de Firewalls•\tAccess Control Lists – ACLsAs listas de controle de acesso são facilidades dos firewalls que permitem criar regras específicas para permitir ou negar o acesso a usuários ou conexões. Podem ser do tipo White lists, onde apenas os usuários ou conexões listados e identificados podem acessar os recursos do sistema ou trafegar dados pelo firewall, rejeitando qualquer origem desconhecida. Ou podem ser do tipo Black lists, que aceitam todos os acessos desconhecidos, barrando apenas os conhecidos e identificados na lista (STALLINGS; BROWN, 2014).•\tIntrusion Detection System (IDS)O Sistema de detecção de intrusos é uma facilidade de firewall que visa detectar acessos não autorizados ao sistema. Existem diversos tipos, que partem da premissa de que o comportamento de um invasor é diferente de um usuário autorizado. Para monitorar esse comportamento, os IDS verificam constantemente quais conexões estão sendo estabelecidas, quais usuários estão autenticados, quais as ações que eles estão realizando, quais falhas de conexão ou de autenticação estão sendo lançadas. Comparando esse registros com logs e históricos do próprio sistema ou com registros de invasões conhecidas, o IDS pode sinalizar acessos suspeitos e interromper conexões para proteger o sistema (STALLINGS; BROWN, 2014).Comparação entre Firewalls baseados em Software e em Hardware ** SW - (ex: Windows Firewall) HW - (ex: Fortiner) Custo Baixo considerando que existem opções gratuitas. Altos em caso de licenciamento de muitas cópias. Alto para implantação e para poucas máquinas. Baixo se um único dispositivo protegerá muitas máquinas. Facilidade de implementação e manutenção Fácil, pode ser utilizado por usuários comuns. Difícil, requer profissional especializado. Desempenho Limitado aos recursos da máquina onde está instalado. Memória e processador dedicados, liberando recursos das máquinas principais. Vantagens específicas Mais opções de controle e configuração. Mais versátil. Esconde as máquinas da rede local, representando para um observador externo um único dispositivo (NAT). Um único dispositivo pode proteger uma rede interna inteira. Desvantagens específicas O software precisa ser instalado e configurado em muitas máquinas, se houverem. Consome recursos (memórias, processamento…) do usuário. Não é apropriado para rastreamento de tráfego de saída. Ocupa espaço físico para instalação. Fonte: ABHILASH(2015), FORTINET(s. d.), TECHSAA(2021).ReferênciasABHILASH, C. R. Hardware vc Software firewall: a brief comparison. Bobcares. 13 set. 2015. Disponível em: https://bobcares.com/blog/hardware-vs-software-firewall-a-brief-comparison/ Acesso em: 19/08/2021.FORTINET. Hardware Firewalls vs. Software Firewalls. Sem data. Disponível em: https://www.fortinet.com/resources/cyberglossary/hardware-firewalls-better-than-software#:~:text=Hardware%20vs.%20Software%20Firewalls%20At%20the%20most%20basic,ways%2C%20giving%20them%20their%20own%20set%20of%20advantages%3A Acesso em: 19/08/2021.STALLINGS, W.; BROWN, L. Segurança de computadores: princípios e práticas. Tradução de Arlete Simille Marques. 2. ed. Rio de Janeiro: Elsevier, 2014.TECHSAA. Firewall Hardware And Software: Differences Everybody Needs To Know. Hackernoon. 24 mar. 2021. Disponível em: https://hackernoon.com/firewall-hardware-and-software-differences-everybody-needs-to-know-pxx3339 Acesso em: 19/08/2021." }, { "title": "Anotações sobre Matemática Computacional", "url": "/posts/matematica-computacional/", "categories": "Estudos-faculdade", "tags": "matemática", "date": "2020-02-21 08:00:00 -0300", "snippet": "1 Sistemas de Numeração, Lógica e Aritmética Binária, Conversão de BaseSistemas de numeração· Sistema de numeração decimal: posicionalN = {0,1,2,3,4,5,6,7,8,9}$\\beta =10$A posição do símbolo no número refere-se ao expoente da base do sistema. Ex: $(153)_{10}=153=(1\\times10^2)+(5\\times10^1)+(3\\times10^0)$· Sistema de numeração octalN = {0,1,2,3,4,5,6,7}$\\beta =8$Ex: $(153)8= (107){10} = (1\\times8^2)+(5\\times8^1)+(3\\times8^0)$· Sistema de numeração hexadecimalN = {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}$\\beta =16$Ex: $(153){16}=(339){10}=(1\\times16^2)+(5\\times16^1)+(3\\times16^0)$· Sistema de numeração binárioN = {0,1}$\\beta =2$Ex: $(1001 1001)2= (153){10}$Conversão entre sistemas$(abc,de)\\beta=(a\\beta^2+b\\beta^1+c\\beta^0+d\\beta^{-1}+e\\beta^{-2}){10}$Para convertermos um valor expresso no sistema decimal (base 10) para um sistema de base β fazemos divisões sucessivas do número na base 10 pela base β, até que o quociente seja menor que β. Isto se aplica à conversão da parte inteira do valor. Já para o valor fracionário devemos fazer multiplicações sucessivas pela base β até obtermos um valor exclusivamente inteiro. Ao efetuarmos cada multiplicação devemos descartar a parte inteira da multiplicação anterior.$(0,828125){10}=(?)_2$$0,828125\\times2=\\textbf{1},65625$$0,65625\\times2=\\textbf{1},3125$$0,3125\\times2=\\textbf{0},625$$0,625\\times2=\\textbf{1},25$$0,25\\times2=\\textbf{0},50$$0,50\\times2=\\textbf{1}$$(0,828125){10}=(0,110101)_2$Uma opção para fazer a conversão entre sistemas é a substituição direta, que é possível nos casos da conversão dos sistemas hexadecimal e octal para binário, ou vice-versa. Isso porque as bases destes sistemas, 16 e 8, são potências de 2.Três dígitos binários para cada dígito octal, já que 23 = 8Quatro dígitos binários para cada digito hexadecimal, já que 24 = 16Erros de conversão1. Os erros de precisão, que ocorrem em função da quantidade insuficiente de dígitos para representar o valor. Nos sistemas de computação digital o número de dígitos binários usados para representar os números é geralmente pré-definido e limitado: caso haja a necessidade de representar um valor com uma quantidade de dígitos maior que o limite, ocorrerá um erro de precisão. Esta ocorrência é típica das variáveis em programas de computador.2. Os erros de exatidão ocorrem quando há a aproximação, o arredondamento ou a ocorrência de dízimas periódicas. Neste caso, devido à limitação do número de dígitos ou da capacidade de cálculo, geralmente há uma interrupção inesperada da representação.O limite de precisão resulta em truncamento, e afeta principalmente os cálculos com os números irracionais, com o número π (Pi). Em geral este número é representado com duas casas decimais, como 3,14, porém as calculadoras podem representá-lo com oito casas decimais (3,1415926), o que é razoável para maioria dos cálculos. Porém, em cálculos mais extensos é necessário usar uma maior precisão, tal como a representação do Pi com cinquenta e duas casas decimaisO erro absoluto é a diferença entre o valor real e a forma na qual foi expresso. Calculamos o erro absoluto pela seguinte fórmula: $EA_x=x-\\overline{x}$O erro relativo é a razão entre o erro absoluto EA e o valor real x, isto é: $ER_x=\\frac{EA_x}{x}$Lógica binária· NOT: “não” ou “negação” $\\sim A$ ou $\\overline{A}$· AND: “e” &amp; (Ampersand) ^· OR: “ou” + v· XOR: “ou exclusivo” $\\oplus$· SHIFT: “deslocamento”A operação binária de deslocamento (ou rotação) de bits efetua a divisão ou multiplicação por 2 (e por seus múltiplos). Dado um número binário, ao deslocarmos os bits da direta para a esquerda em uma posição (operação representada pelo sinal &lt;&gt;), dividimos o valor por 2, com o resultado inteiro.Aritmética BináriaA adição ou soma binária assemelha-se à soma decimal, incluindo a operação de “vai-um” – que aqui denominamos Carry Out, porém utilizando somente os dígitos do sistema de numeração binário (zero e um).$0+0=0$$0+1=1$$1+0=1$$1+1=0$ e “vai um” (Carry Out=1)$1+1+1=1$ e “vai um” (Carry Out=1)$0\\times0=0$$0\\times1=0$$1\\times0=0$$1\\times1=1$$0-0=0$$0-1=1$ e “pede emprestado” 1 ao dígito da esquerda$1-0=1$$1-1=0$O modelo da divisão binária segue o mesmo processo da divisão em decimal, operando inclusive com os mesmos componentes.2 Estrutura de Dados, Ponto Flutuante, Grafos, ContagemEstruturas de dados· Vetores: Os vetores têm seus elementos posicionados em sequência, e esses elementos são acessados usando-se uma chave, o índice do vetor. Os vetores integram os elementos de dados que são fundamentais para a resolução de problemas por meio da organização dos dados em programas de computador. Vetores também representam segmentos de reta na geometria – uma sequência de pontos que forma a reta, sendo dessa forma um elemento gráfico. Em ambientes de computação, os vetores fazem parte das estruturas de dados homogêneas, por conter somente dados de um único tipo.· Matrizes: Em computação as matrizes são um tipo de arranjo de vetores com duas ou mais dimensões, cujos dados contêm características comuns. Esses dados são organizados sequencialmente e, tal como os vetores, acessados por meio da chave – ou índice – da matriz. As matrizes também fazem parte das estruturas de dados essenciais para o tratamento de problemas matemáticos em ambientes computacionais, especialmente os de computação gráfica. As matrizes também são um tipo de estrutura de dados homogêneas, ou, como já dissemos, um tipo de arranjo de vetores, em que cada vetor corresponde à uma dimensão da matriz. As aplicações de planilhas de dados, como o Microsoft Excel, por exemplo, são a representação mais típica das matrizes. Também os elementos de imagens, tais como os desenhos, as fotografias e os filmes, são compostos por matrizes multidimensionais. A tela do computador que você está usando neste momento é uma matriz visível, na qual cada minúsculo ponto (ou pixel) representa um elemento com várias dimensões, tais como cor, posição e intensidade luminosa (brilho/contraste).· Conjuntos: Os conjuntos são agrupamentos ou coleções de objetos – denominados elementos ou membros do conjunto –, cujas características são comuns entre si. Os conjuntos são geralmente representados por uma letra maiúscula, e os seus elementos são expressos entre chaves. Podemos também representar os conjuntos em sua forma gráfica com o diagrama de Venn.Aritmética de ponto flutuanteOs computadores representam os números reais, com a Aritmética de Ponto Flutuante, formulada por F[β, t, -p, p], representando o sistema F do sistema de numeração de base β com a quantidade t de dígitos na mantissa – ou dígitos significativos, e limites de expoente de -p até p. Os números desse sistema são então expressos no seguinte formato:± (0,𝒅𝟏𝒅𝟐 … 𝒅𝒕 )$β^e$No qual:β é a base do sistema de numeração com o qual o computador opera (geralmente 2, ou binária, para a computação digital);d é um dos dígitos da mantissa, cuja quantidade máxima é definida por t;e representa o expoente, cujo intervalo é definido por p, variando de -p até p.Por exemplo: Dado o sistema de representação F[10, 3, -5, 5], que significa β = 10, t = 3 e e ∈ [-5,5], temos então:O menor número, em valores absolutos (m), é 0,001 x 10-5 , ou seja, 10-8 ;O maior número, em valores absolutos (M), é 0,999 x 105 , ou seja, 99900.Se usarmos esse sistema para representar um dado número, como por exemplo N = 227,68 ou seja, N = 0,22768 x 103, será representado como 0,227 x 103 – caso a opção seja o truncamento ou corte – ou 0,228 x 103 , caso a opção seja o arredondamento.Tabela - A precisão numérica definida pela norma IEEE 754 Propriedade Precisão Precisão Precisão Propriedade Simples Dupla Estendida Total de bits 32 64 80 Bits da mantissa 23 52 64 Bits do expoente 8 11 15 Base 2 2 2 Exp. Máximo 127 1023 16383 Exp. Mínimo -126 -1022 -16382 Maior nº $\\cong3,40\\times10^{38}$ $\\cong1,80\\times10^{308}$ $\\cong1,19\\times10^{4932}$ Menor nº $\\cong1,18\\times10^{-38}$ $\\cong2,23\\times10^{-308}$ $\\cong3,36\\times10^{-4932}$ Decimais 7 16 20 · Adição e subtração: 1. Comparamos a magnitude dos expoentes dos operadores e nivelamos esses expoentes, ajustando o do número de menor valor (alinhamento); 2. Realizamos a operação (adição ou subtração); 3. Ajustamos a mantissa e o expoente do número resultante (normalização).· Multiplicação: multiplicam-se as bases e somam-se os expoentes. Nesse caso, a base é a mantissa.· Divisão: dividem-se as bases e subtraem-se os expoentes, lembrado que a base é a mantissa.ErrosTemos erros de precisão, decorrentes da limitação de dígitos usados para representar os valores – o número de dígitos é geralmente pré-definido em decorrência da utilização do sistema binário e da constituição do hardware. Este tipo de erro é comum em programação, no caso das variáveis utilizadas nos programas de computador. Por outro lado, a aproximação, o arredondamento ou a ocorrência de dízimas periódicas geram os erros de exatidão, devido à interrupção abrupta ou forçada da representação.Nos ambientes computacionais, as operações com ponto flutuante podem resultar em interrupção do processamento, o que não é algo esperado. Essas operações são decorrentes basicamente de cinco tipos de operações – ou exceções:1. O overflow é um resultado apresentado quando é gerado um resultado infinito ou muito além da capacidade de representação do sistema.2. O underflow ocorre quando é obtido um resultado zero após um arredondamento de um valor diferente de zero, ou seja, um valor muito menor do que a capacidade de representação do sistema.3. A divisão por zero geralmente é o resultado de um cálculo com um underflow ou valor pouco significativo para o sistema. Uma divisão por zero não possibilita qualquer solução matemática.4. Um resultado inexato, apesar de ser algo que pode acontecer com relativa frequência, pode resultar tanto de um cálculo que gere overflow quanto de arredondamentos. Geralmente, essas ocorrências não geram uma interrupção do processo, porém podem, caso façam parte de um processo recorrente ou recursivo, se transformar em algo mais crítico, e por isso pode ser tratado como uma exceção.5. Um número inválido é o resultado de uma operação que não pode ser considerado um número, conhecido pela sigla em inglês NaN – Not a Number, como por exemplo a raiz quadrada de um número negativo, uma divisão de zero por zero ou de infinito por infinito.O cancelamento catastrófico é o nome que se dá ao efeito que ocorre quando um cálculo atinge o épsilon ε do sistema computacional. O épsilon do sistema é o menor número que, somado a 1, resulta em um número diferente de 1; ou seja, não é arredondado. O épsilon representa a precisão aritmética relativa da máquina, e é consequência da precisão finita da aritmética de ponto flutuante.Elementos matemáticos computacionais· Grafos: A estrutura gráfica utilizada em matemática para apresentar as relações entre os elementos ou objetos de um conjunto é denominada grafo. Grafos são expressos na forma de equação como G (V,A), na qual são representados seus dois elementos: os vértices e as arestas. Os elementos do conjunto – ou componentes, objetos – são representados por círculos ou pontos e denominados vértices. Já as relações, ligações, dependências ou “caminhos” entre os vértices são representados por segmentos de reta ou linhas, as arestas.· Os grafos que têm suas arestas direcionadas são denominados grafos orientados (ou ainda grafos dirigidos, direcionados ou dígrafos). Um vértice pode ser ligado a ele próprio, formando um laço ou loop. As arestas podem conter rótulos de identificação, de peso ou valor numérico. Um grafo G é um grafo dirigido G = (V, A), tal que V = {A, B, C, D, E, F, G} e A = {(A,B), (B,C), (B,D), (B,E), (C,E), (D,E), (E,F), (G,D)}. Neste exemplo, é possível identificar rotas ou fluxos entre os vértices, traçando caminhos entre eles.A representação de um grafo finito com n vértices pode ser feita por uma matriz de adjacência. Essa matriz tem as dimensões definidas pelo número de vértices (n-por-n), e o valor na linha i e coluna j fornece o número de arestas que conectam o i-ésimo ao j-ésimo vértices.Um Grafo dirigido rotulado:graph LR A((A)) --&gt;|9| B((B)) A --&gt;|4| B B --&gt;|3| B B --&gt;|6| E((E)) E --&gt;|8| D((D)) D --&gt;|7|E D--&gt;|7| A E--&gt;|5| F((F)) C((C))Uma matriz de adjacência com o respectivo grafo:$A=\\begin{vmatrix} 1 1 0 0 1 0 1 0 1 0 1 0 0 1 0 1 0 0 0 0 1 0 1 1 1 1 0 1 0 0 0 0 0 1 0 0\\end{vmatrix}$graph LR 1((1)) ---1 1---2((2)) 1---5((5)) 2---5 2---3((3)) 5---4((4)) 3---4 4---6((6))· Em um dígrafo, contemplamos os graus de saída (o número de arestas saindo de um vértice) e de entrada (o número de arestas entrando em um vértice);· O grau de um vértice de um dígrafo é igual à soma dos graus de saída e de entrada.· Árvores: Uma árvore é um grafo conexo, aquele no qual sempre existe uma aresta entre dois quaisquer de seus vértices, e que é também acíclico, isto é, não existem ciclos ou loops. As árvores correspondem a uma das mais importantes estruturas de dados não lineares da computação.Com relação à definição de árvores, podemos afirmar que nem todo grafo é uma árvore, mas que toda árvore é um grafo. Além disso, é um grafo bipartido, isto é, apresenta pelo menos dois níveis. Toda árvore também é um grafo planar, que é representado em um plano, em apenas duas dimensões. Por outro lado, todo grafo conexo inclui ao menos uma árvore de extensão associada a si, composta de todos os seus vértices e de algumas de suas arestas.Para considerarmos um grafo G com n vértices como uma árvore, devemos verificar se esse grafo: · É conexo, e há um único caminho entre dois vértices quaisquer; deixará de ser conexo se qualquer aresta for removida; · É acíclico, tem n – 1 arestas, e ao se incluir uma nova aresta fecha-se um novo ciclo.Se um determinado vértice da árvore é escolhido como especial, a árvore é denominada enraizada, e o vértice escolhido é denominado raiz. Uma árvore livre é aquela que não tem raiz. O número máximo de arestas – ou ramos – em um vértice – ou elemento – é chamado de ordem ou grau, e a máxima sequência de vértices de grau um ou maior define a quantidade de níveis de uma árvore.· Árvore binária: A árvore binária é o tipo de árvore que a computação mais utiliza, e é definida como um grafo acíclico, conexo, dirigido. Cada nó tem grau (ou ordem) menos ou igual a. Cada ramo da árvore é um vértice dirigido, sem peso, que chega ao próximo (sucessor ou filho) a partir do seu anterior (antecessor ou pai), formando uma hierarquia, e fazendo com que só exista um único caminho entre dois nós distintos.Os percursos possíveis em uma árvore binária são a leitura em pré-ordem, em ordem e em pós-ordem. Em “pré-Ordem” (ou RED = raiz, esquerda, direita) é acessado um nó raiz, depois seu sucessor da esquerda e em seguida o da direita. No acesso “em ordem” (In-Order ou ERD = esquerda, raiz, direita) é acessada uma folhada esquerda, sua raiz (ou predecessor), e depois o nó da direita. Já no acesso em “pós-ordem” (ou EDR = esquerda, direita, raiz), o acesso inicia-se pelo nó da esquerda, desloca-se para o da direita e então segue à raiz deles. A Figura 14 apresenta uma árvore binária com o acesso em pré-ordem (RED): F,B,A,D,C,E,G,I,H. Nessa mesma árvore, podemos ter o acesso em pósordem (EDR): A,C,E,D,B,H,I,G,F ou em ordem (ERD): A,B,C,D,E,F,G,H,I.ContagemExiste um princípio, denominado princípio fundamental da contagem, ou também princípio multiplicativo, que estabelece o seguinte: “quando um evento é composto por n etapas sucessivas e independentes, de tal modo que as possibilidades da primeira etapa é x e as possibilidades da segunda etapa é y, resulta no número total de possibilidades de o evento ocorrer, dado pelo produto (x) . (y)”· Arranjo: Os arranjos são subconjuntos nos quais a ordem e a natureza fazem a diferença. Considerando um conjunto de n elementos, organizados em subconjuntos de p elementos, sendo p ≤ n, utilizamos a seguinte fórmula para o arranjo: $A_{n,p}=\\frac{n!}{(n-p)!}$Permutação: A permutação nada mais é do que um caso específico de arranjo, no qual o número de elementos do conjunto (n) é igual ao número total de elementos. Isso resulta em que o denominador, na fórmula do arranjo, seja igual a uma unidade (1). A consequência é que a permutação é representada pela seguinte fórmula: $P_n=n!$Combinação: Diferentemente dos arranjos, as combinações são subconjuntos para os quais a ordem dos elementos não importa, porém, a sua natureza, sim. Deste modo, para obtermos uma combinação simples de n elementos combinados p a p, sendo ($p\\le n$), recorremos à seguinte fórmula: $C_{n,p}=\\frac{n!}{p!(n-p)!}$3 ProbabilidadeDenomina-se probabilidade o processo pelo qual conseguimos estimar as chances de ocorrência de determinado fato determinado ou evento. É também a denominação de um ramo ou área da matemática que usa modelos para o estudo de experimentos ou ocorrências dos fenômenos ditos aleatórios. Estes eventos são aqueles nos quais há incerteza no que se refere às possibilidades de ocorrerem, ou seja, são prováveis ou improváveis.O conjunto de resultados possíveis é denominado Espaço Amostral, e é representado pela letra S ou por Ω, a letra grega ômega.Quando todos os elementos têm a mesma chance de ocorrência, são denominados equiprováveis.Eventos· Denominamos Evento qualquer elemento ou subconjunto, mesmo um unitário – que faz parte do espaço amostral.Caso um evento coincida com a totalidade do espaço amostral, é chamado de evento certo, e o oposto, que resulta em um conjunto vazio, é dito evento impossível. Quando dois eventos não podem ocorrer de modo simultâneo, ou quando a ocorrência de um elimina a possibilidade da ocorrência de outro, então são chamados de eventos mutuamente exclusivos.· Eventos complementares, isto é, a união deles resulta no espaço amostral e a interseção resulta em um conjunto vazio.· Eventos mutuamente exclusivos: quando interseção de dois eventos resulta em um conjunto vazio isto significa que a ocorrência de um implica na impossibilidade da ocorrência do outro. $P(A)=\\frac{n(A)}{n(S)}$Dois eventos são ditos independentes quando a ocorrência ou a não ocorrência de um deles não influi na probabilidade da ocorrência do outro, e vice-versa.União de eventos: $n(A\\cup B)=n(A)+n(B)-n(A\\cap B)$Probabilidade de eventos complementares: $A\\cup\\overline{A}=S; A\\cap\\overline{A}=\\emptyset$4 Modelagem Matemática, Máquinas de Estado, Autômatos, Máquinas de Mealy e TuringMáquina de estados· As máquinas de estado são uma forma matemática de abstrair processos ou o funcionamento de equipamentos reais, sejam eletrônicos ou mecânicos, e ainda dos softwares. Em outras palavras, as máquinas de estado são um modelo matemático de sistemas que possuem entradas e saídas discretas e a capacidade de representar, em um certo momento, um estado preestabelecido.· As máquinas de estado também são chamadas autômatos, ou máquinas de estado finito (FSM – Finite State Machine, em inglês). Apesar de possuir a capacidade de representar múltiplos estados, uma FSM só pode apresentar-se em um estado por vez, denominado estado atual, sendo esta é principal característica de uma máquina de estados.· Uma FSM pode ser representada por uma quíntupla (Q, ∑, δ, q0, F):a. Q é um conjunto finito de estados;b. ∑ é conjunto finito de símbolos, chamado de alfabeto da FSM;c. δ é a função de transição, na qual δ: Q × ∑ → Q;d. q0 é o estado inicial no qual qualquer entrada é processada (q0 ∈ Q);e. F é um conjunto de estado/estados finais de Q (F ⊆ Q).· A terminologia aplicada às FSM inclui os seguintes termos:a. Alfabeto é um conjunto finito de símbolos. Por exemplo: ∑ = {a, b, c, d} é um conjunto do alfabeto no qual ‘a’, ‘b’, ‘c’, e ‘d’ são símbolos.b. String é uma sequência finita de símbolos obtidos de ∑. Por exemplo, a string ‘cabcad’ é uma string válida do conjunto do alfabeto ∑ = {a, b, c, d}. c. Comprimento de uma string é o número de elementos presentes na string, denotado por S . Por exemplo, se S = ‘cabcad’, S = 6. Se S = 0, então a string é chamada string vazia, denotada por λ or ε). d. Fecho de Kleene ou Operador de Kleene, ∑*, é um operador unário ou um conjunto de símbolos ou strings ∑, dado um infinito conjunto de todas as possíveis strings de todos os possíveis comprimentos sobre ∑ incluindo λ. A representação: ∑* = ∑0 ∪ ∑1 ∪ ∑2 ∪……. ∑p é o conjunto de todas as strings possíveis de comprimento p. Por exemplo, se ∑ = {a, b}, ∑* = {λ, a, b, aa, ab, ba, bb, ………..}.e. Fecho de Kleene / Mais, ∑+ é um conjunto infinito de possíveis strings de todos os possíveis comprimentos sobre ∑ excluindo λ. A representação é: ∑+ = ∑1 ∪ ∑2 ∪ ∑3 ∪……. ∑+ = ∑* − { λ }. Por exemplo, se ∑ = { a, b }, então ∑+ = { a, b, aa, ab, ba, bb, ………..}.f. Linguagem é um subconjunto de ∑* para algum alfabeto ∑, que pode ser finito ou infinito. Por exemplo, se a linguagem L compreende todas as strings possíveis de comprimento 2 sobre ∑ = {a, b}, então L = { ab, aa, ba, bb}.· A base do funcionamento de uma FSM é justamente isso: considerar que um estado armazena informações sobre as etapas anteriores, isto é, o passado do processo. Além disso, o estado reflete as mudanças ocorridas desde a entrada neste estado até o momento presente. Uma mudança de estado - geralmente descrita ou especificada por uma condição que precisa ser atendida ou ocorrer – refere-se à uma transição. Uma ação refere-se à uma atividade a ser realizada para gerar a transição, ou mesmo à uma atividade que ocorre em função de uma transição.· Um diagrama de estado é a forma gráfica que utilizamos para representar o funcionamento de uma máquina de estado. As tabelas de transição de estado também podem representar as FSM - máquinas de estado.stateDiagram-v2 [*] --&gt; No_Térreo No_Térreo--&gt;Subindo: subir (andar) Subindo--&gt;Parado: subir (andar) Subindo--&gt;Parado: Chegar no andar Parado--&gt;Descendo: descer(andar) Descendo--&gt;Parado: Chegar no andar Parado--&gt;Indo_para_o_térreo: tempo de espera Indo_para_o_térreo--&gt;No_Térreo: Chegar no térreoTabela de Transição de Estados: Condição Estado A Estado B Estado C 1 … … … 2 … Estado C … 3 … … … · As máquinas de estado podem ser de dois tipos: as do tipo aceitadoras (ou reconhecedoras), que produzem uma saída binária, restrita a sim ou não, para informar se a entrada é aceita pela máquina ou não, e as do tipos transdutoras que produzem uma informação na saída baseada em um estímulo ou informação de entrada e/ou um estado utilizando ações, e que geralmente são utilizadas para aplicações de controle.· Máquina de Estado Finito M = [E, I, O, fE, fO] é uma máquina de estado finito se E é um conjunto finito de estados, I é um conjunto finito de símbolos de entrada (o alfabeto de entrada), O é um conjunto finito de símbolos de saída (o alfabeto de saída) e fE, fO são funções, onde: fE: E x I →E e fO : E → O A máquina sempre começa inicializada por um estado inicial fixo e0 .· os exemplos utilizados até aqui tratam de um tipo de FSM que denominamos AFD – Autômato Finito Determinístico, ou seja, uma estrutura matemática constituída por três tipos de elementos: um conjunto de estados, um alfabeto (com os símbolos reconhecidos como entrada e saída) e um conjunto de transições. Entre os estados destacamos um único estado inicial e um subconjunto composto dos estados finais.· Ex: Q = {a, b, c}; ∑ = {0, 1}; q0 = {a}; F = {c}. Estado atual Próximo estado para uma entrada 0 Próximo estado para uma entrada 1 a a b b c a c b c stateDiagram-v2 [*] --&gt; a a--&gt;a: 0 a--&gt;b: 1 b--&gt;a: 1 b--&gt;c: 0 c--&gt;b: 0 c--&gt;c: 1· Em um AFD, para cada par (estado, símbolo) há uma transição para um único estado, o que confere um caráter determinístico ao funcionamento deste autômato. Caso eliminemos essa restrição, ou seja, se para um determinado par (estado, símbolo) for possível haver transições para dois ou mais estados, passamos a denominar a FSM como AFN – Autômato Finito não Determinístico. Ou seja, em um AFN é possível haver um conjunto com várias operações possíveis para a mesma palavra ou símbolo de entrada em um estado. Os componentes de um AFN são basicamente os mesmos de um AFD, porém um AFN contempla as seguintes definições:a. Um AFN pode ter mais que um estado inicial;b. A função de transição apresenta, para cada par (estado, símbolo), um conjunto de estados.· Um AFN - Autômato Finito Não-Determinístico é representado por uma quíntupla (Q, ∑, δ, q0, F), na qual:a. Q é um conjunto finito de estados;b. ∑ é um conjunto finito de símbolos chamado alfabeto;c. δ é a função de transição, na qual δ: Q × ∑ → 2 Q (2 elevado a Q deve-se ao fato de que a transição de um estado pode para qualquer combinação de Q);d. q0 é o estado inicial a partir do qual qualquer entrada é processada (q0 ∈ Q);e. F é um conjunto de estado/estados finais de Q (F ⊆ Q).· Ex: Q = {a, b, c}; ∑ = {0, 1}; q0 = {a}; F = {c}; Estado atual Próximo estado para uma entrada 0 Próximo estado para uma entrada 1 a a,b b b c a,c c b,b c stateDiagram-v2 [*] --&gt; a a--&gt;a: 0 a--&gt;b: 0,1 b--&gt;a: 1 b--&gt;c: 0,1 c--&gt;b: 0 c--&gt;c: 0,1· Comparativo entre AFD e AFN AFD AFN A transição de um estado ocorre para um único estado próximo particular, para cada símbolo de entrada. Por isso, é chamado determinístico. A transição de um estado pode ocorrer para vários estados seguintes, para cada símbolo de entrada. Por isso, é chamado de não-determinístico. Transições de strings vazias não existem. Transições de strings vazias podem ocorrer. O retrocesso é permitido. O retrocesso nem sempre é possível. Requer mais espaço. Requer menos espaço. Uma string é aceita se passar para um estado final. Uma string é aceita se pelo menos uma das transições possíveis terminar em um estado final. · Um AFD pode ser representado pela arquitetura mostrada na figura: uma máquina que opera com uma leitura sequencial – em uma fita – e em apenas uma direção: para a direita. Esta fita contém os símbolos distribuídos em células, sendo um único símbolo em cada célula. A máquina também tem um registrador para armazenar o estado atual, um conjunto de instruções – a função de transição do AFD – e uma unidade de controle. É possível também que se possa fazer a leitura bidirecional da fita, permitindo que a transição possa avançar ou retroceder na leitura dos símbolos. Nesse caso, para evitar que a leitura avança para além do final, ou retroceda para antes do começo, é necessário que existam mais duas células com símbolos especiais &lt; e &gt;, que, na prática, limitam as transições.Autômatos de pilhaApesar da sua extensa aplicação, as máquinas de estado finito – FSM, ou autômatos finitos, não atendem à totalidade dos problemas. É o caso, por exemplo, de aplicações para as quais é necessário usar expressões aritméticas. Nesses casos, falta aos autômatos uma memória que permita registrar todos os valores – ou as ocorrências dos símbolos. Para atender à essa necessidade são utilizados os AP – Autômatos de Pilha (pushdown automata, em inglês).· Diferentemente dos autômatos finitos, um autômato de pilha não determinístico tem uma abrangência muito superior a dos AP determinísticos. Um autômato de pilha é uma máquina de estados bastante semelhante à um AFD, porém com o adicional de uma pilha.· A pilha, tal como uma fita, compõe-se de células que são capazes de receber apenas um símbolo por vez. A leitura, porém, é feita apenas na célula do topo da pilha. No início do processo, o registrador contém o estado inicial do AP. A fita então recebe a palavra de entrada da sua primeira célula, pois o cabeçote de leitura está posicionado na primeira célula da fita. Neste momento, a pilha está vazia. À medida em que a leitura da fita prossegue e as transições resultam em um uso da pilha, um símbolo de fim de pilha (F) é inserido na pilha, de modo a identificar esse status novamente quando a pilha for lida.· A principal diferença entre um APD – Autômato de Pilha Determinístico e um APN – Autômato de Pilha Não-Determinístico reside no fato de que o APN pode contemplar transições compatíveis entre si.Máquina de Mealy· Uma máquina de Mealy é uma FSM cuja saída depende do estado atual, bem como da entrada. Pode ser descrita por uma sêxtupla (Q, ∑, O, δ, X, q0) em que:a. Q: conjunto finito de estados;b. ∑: conjunto finito de símbolos denominado alfabeto de entrada;c. O: conjunto finito de símbolos denominado alfabeto de saída;d. δ: função de entrada de transição em que δ: Q × ∑ → Q;e. X: função de saída da transição em que X: Q × ∑ → O;f. q0: estado inicial a partir do qual qualquer entrada é processada (q0 ∈ Q). Próximo estado$\\rightarrow$ Entrada=0 Entrada=0 Entrada=1 Entrada=1 Estado atual$\\downarrow$ Estado Saída Estado Saída -&gt;a b x1 c x1 b b x2 d x3 c d x3 c x1 d d x3 d x2 stateDiagram-v2 [*] --&gt; a a--&gt;b: 0 a--&gt;c: 1 b--&gt;b: 0 b--&gt;d: 1 c--&gt;d: 0 c--&gt;c: 1 d--&gt;d: 0, x3, 1Máquina de Moore· Uma máquina de Moore é uma FSM cujas saídas dependem apenas do estado atual. Pode ser descrita por uma sêxtupla (Q, ∑, O, δ, X, q0) em que:a. Q: conjunto finito de estados;b. ∑: conjunto finito de símbolos denominado alfabeto de entrada;c. O: conjunto finito de símbolos denominado alfabeto de saída;d. δ: função de entrada de transição em que δ: Q × ∑ → Q;e. X: função de saída da transição em que X: Q → O;f. q0: estado inicial a partir do qual qualquer entrada é processada (q0 ∈ Q). Estado atual Entrada=0 Entrada=1 Saída -&gt;a b c x2 b b d x1 c c d x2 d d d x3 stateDiagram-v2 [*] --&gt; a/x2 a/x2--&gt;b/x1: 0 a/x2--&gt;c/x2: 1 b/x1--&gt;b/x1: 0 b/x1--&gt;d/x3: 1 c/x2--&gt;d/x3: 0 c/x2--&gt;c/x2: 1 d/x3--&gt;d/x3: 0, 1Máquina de Turing· A Máquina de Turing é um dispositivo inventado em 1936 por Alan Turing, matemático inglês, que aceita as linguagens (conjunto recursivamente enumerável) geradas por gramáticas tipo 0. Uma máquina de Turing é um modelo matemático que consiste em uma fita de comprimento infinito, dividida em células, pelas quais a entrada é dada, e de uma cabeça de leitura que lê a fita de entrada. Um registrador de estado armazena o estado da máquina de Turing. Depois de ler um símbolo de entrada, este é substituído por outro símbolo, o estado interno da máquina é alterado, e a cabeça de leitura se move uma célula, para a direita ou para a esquerda. Se a máquina atingir o estado final, a string de entrada será aceita; caso contrário, será rejeitada.· Uma máquina de Turing pode ser formalmente descrita com uma sétupla (Q, X, ∑, δ, q0, B, F), em que:a. Q é um conjunto finito de estados;b. X é o alfabeto da fita;c. ∑ é o alfabeto de entradad. δ é a função de transição δ: Q × X → Q × X × {deslocamento à esquerda, deslocamento à direita}.e. q0 é o estado inicial;f. B é o símbolo de ‘Espaço em Branco’;g. F é o conjunto de estados finais.· Comparação: Tipo de Máquina Estrutura de Pilha de Dados Determinística? Autômatos Finitos N/A Sim Autômato de Pilha Último a entrar, primeiro a sair (LIFO) Não Máquina de Turing Fita infinita Sim · Ex: Q = {q0, q1, q2, qf}; X = {a, b}; ∑ = {1}; q0 = {q0}; B = espaço em branco; F = {qf} Símbolo do Alfabeto da Fita Estado atual ‘$q_0$’ Estado atual ‘$q_1$’ Estado atual ‘$q_2$’ a $1Rq_1$ $1Lq_0$ $1Lq_f$ b $1Lq_2$ $1Rq_1$ $1Rq_f$ · A complexidade do tempo pode ser representada por T (n) = O 16 (n log n). A complexidade do espaço da máquina de Turing pode ser representada por S (n) = O (n).· Quanto à linguagem, uma máquina de Turing aceita uma linguagem se entrar em um estado final para qualquer string de entrada escrita. Uma linguagem é dita recursivamente enumerável (gerada pela gramática Tipo 0) se for aceita por uma máquina de Turing. Uma MT decide por uma linguagem se o aceita e entra em um estado de rejeição para qualquer entrada que não esteja nessa linguagem. Uma linguagem é recursiva se for decidida por uma máquina de Turing. Podem haver alguns casos em que uma máquina de Turing não para. Então essa máquina de Turing aceita a linguagem, mas não a decide.5 CriptografiaIntrodução à Criptografia· Criptografia é a ciência de transformar a informação para restringi-la, de forma que possa ser armazenada e transportada de maneira segura, e, assim, torne-se imune a modificações e acesso indevido. Forouzan (2008) acrescenta que “a criptografia também pode ser usada para autenticação do emissor e do receptor da mensagem entre si”, ou seja, quando emissores e receptores precisam de reconhecimento mútuo.· A criptografia é uma ciência que pertence ao domínio da Matemática, destinada ao estudo de técnicas e princípios de transformação da informação de sua forma original para outra, ininteligível, de forma que possa ser conhecida e utilizada apenas quando autorizado. Esse processo de transformação da informação em seu estado original, chamado de texto plano (plain text), para um formato protegido pela ocultação de seu significado, chamado de texto cifrado ou codificado, é denominado cifragem (ou também criptografia, encriptação). O processo oposto é denominado decifragem (ou descriptografia, descriptação). Quando é feito à revelia dos interessados ou proprietários da informação – de forma maliciosa ou não – é chamado de quebra da criptografia ou do código.· A criptografia emprega os termos texto claro (ou texto plano), que se refere à mensagem original, não modificada pelo processo criptográfico. Já o texto cifrado é a mensagem submetida a um algoritmo criptográfico, isto é, o código ou o programa de computador que transforma o texto plano em texto cifrado. Esse algoritmo criptográfico é também chamado de cifra, e geralmente faz uso de uma chave, um valor numérico que será aplicado à mensagem para produzir uma modificação controlada e reversível. Uma chave pode ser usada para criptografar (cifrar) ou para descriptografar (decifrar).· O processo de criptografia pode ser realizado por meio de dois tipos básicos de cifragem/decifragem: a criptografia simétrica, de chave única ou de chave secreta, e a criptografia assimétrica ou de chave pública. Na criptografia simétrica a mesma chave é utilizada para a cifragem e a decifragem da mensagem, e o algoritmo de cifragem e decifragem é o mesmo.· Já na criptografia de chave assimétrica são utilizadas duas chaves no processo de cifragem/decifragem, a chave pública e a chave privada. A chave pública, usada para cifrar a mensagem, é compartilhada com os possíveis emissores de mensagem para o receptor, que guarda consigo a chave privada para decifrar a mensagem recebida. Essas chaves são diferentes entre si.Criptografia Simétrica· Os algoritmos utilizados para a criptografia simétrica apresentam desempenho muito superior, razão pela qual são preferidos em processos de criptografia de bloco e de fluxo.· Data Encryption Standard (DES), criado pela IBM em 1974. Mais tarde ele evoluiu para o 3DES ou Triple DES. O algoritmo RC4, desenvolvido por Ronald Rivest, é utilizado no SSL e é um dos mais empregados na criptografia de fluxo de dados. Já o RC5, do mesmo autor, é empregado para cifragem de blocos de extrema facilidade. Ambos têm a chave de tamanho fixo.· O Blowfish é um algoritmo de criptografia de blocos com chave de tamanho variável, desenvolvido em 1993 por Bruce Schneier. O International Data Encryption Algorithm (IDEA) foi criado em 1991 por James Massey e Xuejia Lai. É também um algoritmo de bloco semelhante ao DES e de fácil implementação.· O algoritmo Advanced Encryption Standard (AES) é um algoritmo de criptografia de bloco padronizado pelo NIST em 2001. É usado pelo governo dos Estados Unidos em substituição ao DES/3DES, sendo um dos mais populares algoritmos da atualidade, por combinar características de segurança, desempenho, facilidade de implementação e flexibilidade.· As cifras simétricas são utilizadas desde os primórdios da história, quando a humanidade passou a utilizar a comunicação escrita, e continuam populares. Essas cifras compreendem as cifras de substituição e as cifras de transposição.· Nas cifras de substituição um símbolo da mensagem – uma letra, sinal ou número – é substituído por um outro símbolo. Na cifragem monoalfabética essa troca é constante, ou seja, em qualquer posição da mensagem acontece a mesma troca. A chave criptográfica, nesse caso, contempla uma simples tabela de equivalência, que é usada em ambos os processos – cifragem e decifragem.· Já em uma cifra polialfabética a substituição de símbolos é variável, sendo um mesmo símbolo substituído por vários outros no decorrer da cifragem, configurando uma relação de um-para-muitos. Nesse caso a chave e o processo de cifragem devem tratar das possibilidades de substituição. Uma forma de fazer isso é a divisão do texto em blocos de tamanho fixo, e a repetição da chave para completar o tamanho desses blocos.· Cifras de transposição: Nesse processo a chave é uma relação entre as posições dos símbolos no texto plano e no texto cifrado. A cifragem consiste em uma transposição com base em uma tabela DePara, na qual a chave numérica representa as posições dos símbolos e a sequência na qual serão transpostas.· Cifras modernas simples:a. XOR: A cifra XOR é um processo que aplica a operação aritmética lógica OuExclusivo (XOR), comparando os bits do texto plano com os da chave para gerar o texto cifrado. Além da elevada velocidade, por tratar-se de uma operação muito simples, essa cifra tem a vantagem de que o processo de cifragem e decifragem é exatamente o mesmo, ou seja: M Ꚛ K = C tanto quanto C Ꚛ K = M.b. Rotação: Na cifra de rotação os bits de um símbolo ou bloco são deslocados para a esquerda ou para a direita. Esse processo pode ser fixo, com o número de posições do deslocamento sendo constante, ou variável, em função do valor da chave. Uma característica interessante desse processo é que, se aplicarmos um deslocamento idêntico ao número de bits do fluxo de entrada (N), o resultado é inócuo. Portanto o número de deslocamentos deve ficar entre 1 e N-1. Para a decifragem, é necessária a chave, se houver, e uma operação de deslocamento no sentido contrário ao da cifragem.c. Substituição S-Box: Esse processo é semelhante à cifra de substituição de símbolos ou caracteres, porém realizado com bits. Não são utilizadas chaves, e o processo geralmente serve como um estágio intermediário para outros tipos de cifragens mais complexas.d. Transposição P-Box: A caixa de permutação (Permutation Box) é a correspondente, para bits, da cifra de transposição. Geralmente implementado por hardware, por ser mais ágil, esse processo não requer chave, e realiza a permutação direta, por expansão ou por compressão.· Cifras modernas cíclicas: O uso da computação na aplicação de cifragem possibilitou o surgimento de cifras complexas, nas quais o processo de cifragem simples é repetido inúmeras vezes, usando toda a chave, partes ou variações dela de forma cíclica, até produzir o resultado cifrado.a. DES: O Data Encryption Standard (DES), ou Padrão de Criptografia de Dados, é uma cifra de bloco de chave simétrica publicada pelo Instituto Nacional de Padrões e Tecnologia (NIST). O DES é uma implementação de uma Cifra Feistelque utiliza 16 ciclos da estrutura de Feistel. O tamanho do bloco de dados a ser criptografado é de 64 bits. Embora o tamanho da chave seja de 64 bits, o DES usa um comprimento de chave efetivo de 56 bits, pois 8 dos 64 bits da chave não são usados pelo algoritmo de criptografia, e funcionam apenas como bits de verificação. O DES satisfaz ambas as propriedades desejadas da cifra de bloco. Duas propriedades tornam a cifra muito forte: o efeito avalanche – uma pequena mudança no texto simples resulta na grande mudança no texto cifrado; e a completude – cada bit de texto cifrado depende de muitos bits de texto simples. A criptoanálise já encontrou alguns pontos fracos no DES, especialmente quanto ao tamanho da chave, considerada muito curta.a. 3DES (Triple DES) : existem duas variantes do Triple DES, conhecidas como 3- chave Triple DES (3TDES) e 2-chave Triple DES (2TDES).a. AES: O algoritmo de criptografia simétrica mais popular e mais adotado atualmente é o Advanced Encryption Standard (AES) – Padrão Avançado de Criptografia, cujo desempenho é cerca de seis vezes mais rápido que o do 3DES. Com o aumento do poder de computação, um substituto para o DES tornou-se necessário, pois a chave do DES era muito pequena, o que o tornava vulnerável a ataques de busca de chave exaustivos. O 3DES foi projetado para superar essa desvantagem, mas foi considerado lento. Então, em função de uma solicitação do governo americano, foi desenvolvido o AES, cujas características principais são as seguintes: · Chave simétrica de bloco simétrico; · Dados de 128 bits, chaves de 128/192/256 bits; · Mais forte e mais rápido que o 3DES; · Fornece detalhes completos de especificação e design; · Software implementável em C e Java.b. O algoritmo AES é uma cifra iterativa que, em vez de Feistel, baseia-se na “rede de substituição-permutação”. É composto por uma série de operações vinculadas, algumas das quais envolvem a substituição de entradas por saídas específicas (substituições) e outras envolvem a divisão aleatória de bits (permutações). Porém, o AES executa todos os seus cálculos em bytes, em vez de bits. O AES trata os 128 bits de um bloco de texto simples como 16 bytes. Esses 16 bytes são organizados em quatro colunas e quatro linhas para processamento como uma matriz.c. Ao contrário do DES, o número de rodadas no AES é variável e depende do tamanho da chave. O AES usa 10 rodadas para chaves de 128 bits, 12 rodadas para chaves de 192 bits e 14 rodadas para chaves de 256 bits. Cada uma dessas rodadas usa uma chave redonda de 128 bits diferente, que é calculada com base na chave AES original. O esquema da estrutura AES é mostrado abaixo.· Cifras de bloco: Uma cifra de bloco processa os blocos de dados de tamanho fixo. Geralmente o tamanho de uma mensagem é maior que o tamanho do bloco. Portanto, a mensagem longa é dividida em uma série de blocos de mensagens sequenciais, e a cifra opera nesses blocos, um de cada vez. As principais cifras de bloco são: · Livro de Código Eletrônico (ECB – Electronic Code Book); · Encadeamento de Blocos de Cifras (CBC - Cipher Block Chaining); · Codificação com feedback (CFB - Cipher Feedback); · Feedback de Saída (OFB - Output Feedback); · Contador (CTR - Counter).Criptografia assimétrica Chaves diferentes são usadas para criptografia e descriptografia, propriedade que a diferencia da criptografia simétrica; Cada receptor possui uma chave de descriptografia exclusiva, geralmente referida como sua chave privada; O receptor precisa publicar uma chave de criptografia, conhecida como sua chave pública; Alguma garantia da autenticidade de uma chave pública é necessária neste esquema para evitar a falsificação do adversário como receptor; A criptografia assimétrica pode envolver terceiros confiáveis, que certificam que uma determinada chave pública pertence apenas a uma pessoa ou entidade específica; O algoritmo de criptografia é complexo o suficiente para impedir que o invasor consiga produzir um texto simples com base no texto cifrado e a chave de criptografia (pública). Embora as chaves pública e privada estejam relacionadas matematicamente, não é possível calcular a chave privada com base na chave pública. Na verdade, a parte inteligente de qualquer sistema criptográfico de chave pública está no projeto da relação entre as duas chaves.· Criptografia RSA: A criptografia RSA é um dos primeiros sistemas criptográficos de chave pública e o mais empregado atualmente.o Geração de par de chaves:· Selecione dois primos grandes, p e q;· Calcule n = p * q. Para criptografia forte e inquebrável, deve ser um número grande, normalmente um mínimo de 512 bits.· Encontre o Número Derivado (e): O número e deve ser maior que 1 e menor que (p - 1) (q - 1);· Não deve haver nenhum fator comum para e e (p - 1) (q - 1), exceto para 1. Em outras palavras, dois números e e (p - 1) (q - 1) são primos;· Forme a chave pública: O par de números (n, e) forma a chave pública RSA e é tornada público.o Embora n seja parte da chave pública, a dificuldade em fatorar um grande número primo assegura que um atacante não encontre em tempo finito os dois primos (p &amp; q) usados para obter n. Essa é a força do RSA. Para a geração da chave privada, eis os passos:· A chave privada d é calculada com base em p, q e e. Para dado n e e, existe um número único d;· O número d é o inverso de e módulo (p - 1)(q - 1). Isso significa que d é um número menor que (p - 1)(q - 1), tal que, quando multiplicado por e, é igual a 1 módulo (p - 1) (q - 1);· Essa relação é escrita matematicamente da seguinte maneira: e . d = 1 mod (p - 1) (q - 1)· O Algoritmo Euclidiano Estendido toma p, q e e como entrada e fornece d como saída.o Cifragem RSA: Um emissor que deseje enviar uma mensagem de texto para alguém cuja chave pública seja (n, e) representa o texto simples como uma série de números menor que n. Para criptografar o primeiro texto simples P, que é um número módulo n, o processo de criptografia é simples, representado matematicamente como: C = Pe mod n Ou seja, o texto cifrado C é igual ao texto simples P multiplicado por si mesmo e vezes e depois reduzido ao módulo n. Isso significa que C também é um número menor que n.o Decifragem RSA: O processo de descriptografia do RSA é igualmente simples. Considerando que o receptor, que gerou o par de chaves públicas (n, e), recebeu o texto cifrado C, basta então que eleve C à potência de sua chave privada d. O resultado no módulo n será o texto claro P, originalmente transmitido. Representando matematicamente: P = Cd mod no A segurança do RSA depende da complexidade de duas funções separadas. O sistema de criptografia RSA é o mais popular sistema criptográfico de chave pública, baseado na dificuldade prática de fatorar números primos muito grandes. Sua função de criptografia é considerada uma função unidirecional de conversão de texto simples em texto cifrado que pode ser revertida somente com o conhecimento da chave privada d. A geração da chave é baseada na dificuldade de determinar uma chave privada de uma chave pública RSA, o que é o equivalente a fatorar o módulo n. Portanto, não se pode usar o conhecimento de uma chave pública RSA para determinar uma chave privada RSA, a menos que se consiga fatorar n.o Também é uma função unidirecional: passar dos valores de p e q para o módulo n é fácil, mas o inverso é praticamente impossível. Se qualquer uma dessas duas funções for provada não unidirecional, o RSA será quebrado. De fato, se uma técnica de fatoração eficiente for desenvolvida, o RSA não será mais seguro. A força da criptografia RSA é reduzida drasticamente se os números p e q não forem primos grandes, mas também se a chave pública escolhida e for um número pequeno.· Criptografia ElGamal: Existem diversos modelos de criptografia baseados em diferentes versões do Problema do Logaritmo Discreto. O ElGamal, chamado de Variante de Curva Elíptica, é um deles, e a sua força vem do pressuposto de que os logaritmos discretos não podem ser encontrados em um período curto, para determinado número, ao passo que a operação inversa de potenciação pode ser calculada eficientemente.o Geração do par de chaves ElGamal :· Escolhe um grande primo p. Geralmente, um número primo de 1024 a 2048 bits de comprimento é escolhido;· Escolhe um elemento gerador g. Esse número deve estar entre 1 e p - 1, mas não pode ser qualquer número: é um gerador do grupo de múltiplos inteiros de módulo p. Isto significa que para todo inteiro m co-primo para p, existe um inteiro k tal que g k = a mod n. Por exemplo, 3 é gerador do grupo 5 (Z5 = {1, 2, 3, 4}), como podemos ver na tabela a seguir: n $3^n$ $3^n mod5$ 1 3 3 2 9 4 3 27 2 4 81 1 · Escolhe a chave privada: a chave privada x é qualquer número maior que 1 e menor que p – 1;· Calcula parte da chave pública: o valor y é calculado com base nos parâmetros p, g e da chave privada x pela seguinte fórmula: y = gx mod p· Obtém a chave pública: a chave pública ElGamal consiste nos três parâmetros (p, g, y).o Cifragem ElGamal : A geração de um par de chaves ElGamal é comparativamente mais simples que o processo equivalente para RSA, porém a criptografia e a descriptografia são um pouco mais complexas que o RSA. Vamos supor que um emissor deseja enviar um texto simples para alguém, cuja chave pública ElGamal seja (p, g, y). Ele representa o texto plano como uma série de números módulo p. Para criptografar o primeiro texto simples P – que é representado como um número módulo p – de modo a obter o texto cifrado C, ele faz o seguinte:· Gera aleatoriamente um número k;· Calcula dois valores C1 e C2, de modo que: C1 = gk mod p C2 = (P*yk) mod p· Envia o texto cifrado C, consistindo nos dois valores separados (C1, C2), enviados juntos.o Decifragem ElGamal: Para descriptografar o texto cifrado (C1, C2) usando a chave privada x, devemos:· Calcular o inverso modular de (C1) x módulo p, que é (C1) -x, chamado de fator de decodificação.· Obter o texto original (texto plano P) com base no seguinte cálculo: P = C2 × (C1)-x mod p· Criptografia de curva elíptica (ECC) : conjunto de ferramentas e protocolos criptográficos cuja segurança é baseada em versões especiais do problema do logaritmo discreto. Não usa números módulo p. O ECC é baseado em conjuntos de números associados a objetos matemáticos chamados curvas elípticas.Assinatura DigitalAs assinaturas digitais são as formas primitivas de chave pública de autenticação de mensagens. Assinatura digital é um valor criptográfico calculado com base em dados e uma chave secreta conhecida apenas pelo signatário. O receptor da mensagem precisa ter certeza de que a mensagem pertence ao remetente, sem poder negar a origem dessa mensagem. Esse requisito é crucial no mundo dos negócios para manter a confiança nas negociações.A chave privada usada para assinatura é referida como chave de assinatura e a chave pública, como chave de verificação.Deve-se notar que, em vez de assinar os dados diretamente com o algoritmo da assinatura, isso é feito com o hash dos dados. Como o hash de dados é uma representação única de dados, basta assinar o hash no lugar dos dados. A razão mais importante do uso de hash em vez de dados diretamente para assinatura é a eficiência do processo.· Os objetivos da assinatura digital: Autenticação da mensagem; Integridade de dados; Não repúdio; Privacidade.Infraestrutura de Chaves PúblicasA principal característica da Infraestrutura de Chave Pública (ICP) – ou Public Key Infrastructure (PKI) – é que ela usa um par de chaves para prover os serviços de segurança subjacentes. Como já vimos, o par de chaves é composto por chave privada e chave pública. Como as chaves públicas estão em domínio aberto e podem ser violadas, é necessário estabelecer e manter algum tipo de infraestrutura confiável para gerenciar essas chaves.Além disso, existem dois requisitos específicos de gerenciamento de chaves para criptografia de chave pública: 1. O segredo das chaves privadas; 2. A garantia das chaves públicas.· A PKI fornece garantia de chave pública. Ela fornece a identificação de chaves públicas e sua distribuição. Uma estrutura de PKI compreende os seguintes componentes:o Certificado de chave pública, comumente chamado de “certificado digital”;o Tokens de chave privada;o Autoridade Certificadora;o Autoridade de Registro;o Sistema de Gerenciamento de Certificados.· Certificados digitais: Por analogia, um certificado pode ser considerado como a carteira de identidade de uma pessoa. Os certificados digitais são baseados no padrão X.509 da ITU, que define um formato de certificado padrão para certificados de chave pública e validação de certificação. A chave pública referente ao cliente do usuário é armazenada em certificados digitais pela Autoridade Certificadora (CA – Certification Autority), juntamente com outras informações relevantes, como informações do cliente, data de validade, uso, emissor etc. A CA assina digitalmente toda essa informação e inclui uma assinatura digital no certificado. Qualquer pessoa que precise da garantia sobre a chave pública e as informações associadas do cliente pode realizar o processo de validação de assinatura usando a chave pública da CA.· Autoridade certificadora (CA): a CA emite o certificado para um cliente e ajuda outros usuários a verificar o certificado. A CA assume a responsabilidade de identificar corretamente a identidade do cliente que está solicitando a emissão de um certificado, garante que as informações contidas no certificado estejam corretas e as assina digitalmente.· Classes de certificadoso Classe 1: Podem ser facilmente adquiridos pelo fornecimento de um endereço de e-mail;o Classe 2: Exigem informações pessoais adicionais;o Classe 3: Só podem ser adquiridos após a verificação da identidade do solicitante;o Classe 4: Usados por governos e organizações financeiras que precisam de níveis muito altos de confiança.· Autoridade de registro (RA) : A CA pode usar uma Autoridade de Registro (Registration Authority – RA) terceirizada para executar as verificações necessárias da pessoa ou organização que solicita o certificado, para confirmar sua identidade. A RA pode parecer uma autoridade certificadora para o cliente, porém não assina o certificado emitido. O Sistema de Gerenciamento de Certificados (Certificate Management System – CMS) é o sistema de gestão pelo qual os certificados são publicados, temporariamente ou permanentemente suspensos, renovados ou revogados.· Token de chave privada: Enquanto a chave pública de um cliente é armazenada no certificado, a chave privada secreta associada pode ser armazenada no computador do proprietário da chave. Esse método geralmente não é adotado. Se um invasor obtiver acesso ao computador, ele poderá obter acesso à chave privada com facilidade. Por esse motivo, uma chave privada é armazenada em um acesso seguro, vinculado ao token de armazenamento removível protegido por uma senha. Diferentes fornecedores costumam usar formatos de armazenamento diferentes e, por vezes, proprietários, para armazenar chaves. Por exemplo, o Entrust usa o formato proprietário .epf, ao passo que a Verisign, GlobalSign e Baltimore usam o formato padrão .p12.· Hierarquia de Cas: A CA Raiz está no topo da hierarquia da CA e o certificado da CA raiz é um certificado auto assinado. As autoridades certificadoras secundárias, subordinadas diretamente à autoridade certificadora raiz, possuem certificados de autoridade certificadora assinados pela autoridade certificadora raiz.· No Brasil, a Infraestrutura de Chaves Públicas ICP-Brasil, vinculada ao Instituto Nacional de Tecnologia da Informação da Casa Civil da Presidência da República, é quem responde pela AC-Raiz. A ela estão vinculadas todas as Autoridades Certificadoras (ACs) de 1º e 2º nível, e as Autoridades de Registro (ARs), da ICP-Brasil (ITI, 2018).6 Ferramentas de Computação Matemática, Algoritmos de Euclides, Teorema de EulerAritmética Modular· Seja um número n inteiro e positivo, que faz parte de um conjunto {0,…,n1}, o qual representamos como ℤn. Podemos considerar que dois inteiros desse conjunto, x e y, são os mesmos se x e y diferem por um múltiplo de n, o que escrevemos assim:o x = y (mod n)· E dizemos que x e y são congruentes módulo n. Quando o mod n está claramente definido pelo contexto, então pode ser omitido. Todo inteiro x é congruente para determinados y em ℤn. Quando somamos ou subtraímos múltiplos de n de um inteiro x para determinar y ∈ ℤn, então dizemos que estamos reduzindo x módulo n e y é o resto (ou residual).· A aritmética com elementos de ℤn é a mais natural possível. Dados dois elementos x e y ∈ ℤn podemos realizar somas, subtrações e multiplicações e o resultado será congruente com um elemento de ℤn., como nos exemplos a seguir: 6 + 7 = 1 (mod 12) 3 x 20 = 10 (mod 50) 12 – 14 = 16 (mod 18)· Entretanto não há nenhuma noção de grandeza ou proporção.· A divisão, porém, é um caso à parte, posto que está fora dessa constatação.· Caso esse resultado não seja obtido, concluímos que y não tem um inverso. De certa forma, a aritmética modular é mais fácil do que a aritmética com inteiros, posto que existem apenas muitos elementos finitos. Então, para encontrar uma solução de um problema, podemos sempre tentar todas as possibilidades. Agora temos uma boa definição para divisão: x dividido por y é x multiplicado por y-1, se o inverso de y existe. Caso contrário a resposta é indefinida.· Para evitar confusão com a divisão de números inteiros, é comum evitar o uso da barra “/” como símbolo de divisão na aritmética modular: para expressar a divisão de x por y escreve-se xy-1. Como exemplo, temos a seguinte equação: 2 x 3 + 4(5-1) = 2 (mod 6)Algoritmo de EuclidesO algoritmo de Euclides é uma forma eficiente e simples para encontrar o MDC (Máximo Divisor Comum) para dois inteiros diferentes de zero, sem exigir a fatoração.· mdc (x, y) = mdc (y, r) Onde r é o resto da divisão de x por y· Primeiro, se d divide x e d divide y então d divide também a soma de x e y. De modo semelhante, divide também a diferença entre eles, (x – y), considerando que x é o maior dos dois números. E isso significa que diminuímos o tamanho do problema inicial. Agora só precisamos calcular mdc (x, x – y), e o processo pode repetir-se até zerar o resto, e obter o resultado.Logaritmos Discretos· Seja p um número primo, e g, h dois elementos de ℤ𝐩𝐩 ∗ (ou seja, números inteiros menores que p). Suponhamos que saibamos que gx = h (mod p). Então, qual é o valor de x?· O algoritmo de Euclides nos fornece uma maneira mais efetiva de computar inversos, porém não conhecemos nenhum algoritmo rápido para encontrar os logaritmos discretos. Os melhores algoritmos conhecidos para calcular logaritmos discretos são muito mais rápidos do que tentar todos os elementos, mas mesmo assim não são equivalentes ao tempo do cálculo polinomial.· Esse conceito de logaritmos discretos é de fundamental importância, na atualidade, para os mecanismos de chave pública e assinatura digital. O entendimento desse conceito e de sua aplicação no contexto computacional passa pelos conhecimentos básicos da teoria dos números que estamos apresentando. Em função desse entendimento, dizemos que dois números são relativamente primos se não tiverem fatores primos em comum, isto é, se seu máximo divisor comum for 1.Teoremas de Euler e Fermat· Como já dissemos, o problema do logaritmo discreto pode ser complexo, porém temos a nosso favor alguns pontos sobre a potência de uma unidade a ∈ ℤ𝒏 ∗ . Primeiramente, $a^k = 1$ para algum valor de k: uma vez que existem diversas unidades, em quantidade finita, é possível que devamos ter $a^x = a^y$ para algum x &lt; y eventualmente, e uma vez que existe um a − 1 podemos encontrar $a^{x – y} = 1$.· Os teoremas apresentados a seguir reduzem drasticamente o conjunto dos valores possíveis para a ordem de uma unidade.· Pequeno Teorema de Fermat:o Então, em resumo, o pequeno teorema de Fermat afirma que se p é um número primo, então para qualquer inteiro a, o número ap - a é um inteiro múltiplo de p. Em notação aritmética modular escrevemos deste modo: $a^p ≡ a (mod p)$o $a^{p-1} ≡ 1 (mod p)$· Teorema de Euler: é, de certa forma, um modo genérico do pequeno teorema de Fermat, que vimos antes. O modo formal de expressar o teorema de Euler é o seguinte: se a ∈ ℤ𝒏 ∗ então $a^{ϕ(n)} = 1 (mod n)$. Isso reduz o pequeno teorema de Fermat quando n é primo.· Teorema de Euler e o problema do logaritmo discreto: Uma vez que já fomos apresentados ao Teorema de Euler, vamos retomar o problema do logaritmo discreto. Se t e n são números relativamente primos, então: $t^{Φ(n)} = 1 ( mod n)$ Vamos considerar a seguinte equação: $t^x = 1 ( mod n)$· Cálculo do logaritmo discreto: O cálculo do logaritmo discreto consiste em solucionar o seguinte problema: “Dados três números primos, b, t e p, encontrar x de modo que b = t x mod p”.· Multiplicação e Ordem: “para os elementos com ordens de coprimos, a ordem de seu produto é igual ao produto de suas ordens”.Testes de Fermat e Miller-RabinO uso de números primos grandes é essencial para alguns algoritmos de criptografia. Porém um dos complicadores do uso desses números é exatamente a identificação deles. Por definição, um número primo é aquele divisível apenas por 1 e por ele mesmo. Imaginemos um inteiro qualquer n: como podemos afirmar que n é primo? Vamos assumir que n seja ímpar, já que o único caso de número par e primo é o do número 2. A forma mais corriqueira de verificar se n é primo seria procurar os fatores de n, entretanto, como já sabemos, ainda não conhecemos nenhum algoritmo de fatoração eficiente para essa operação.· Teste de Fermat: Conhecemos como teste de Fermat ou teorema de Fermat o seguinte enunciado: se o número n é primo, então para qualquer a temos que $a^{n-1} = 1 (mod n)$.· Teste de Miller-Rabin:o Dado n, encontramos s de modo que $n − 1 = 2^sq$ para algum q ímpar.o Escolhemos um valor aleatório para a de tal modo que a ∈ {1, …, n − 1}o Se $a^q = 1$, então n passa no teste, e finalizamos o teste.Para toda iteração i=0,…,s-1 verificamos se $a^{2^{i}q}=-1$. Caso seja, n passa no teste, e finalizamos o teste.o Caso contrário, n é um número composto, e, portanto, não é primo." }, { "title": "Anotações sobre Inteligência Artificial Aplicada", "url": "/posts/inteligencia-artificial-aplicada/", "categories": "Estudos-faculdade", "tags": "ia", "date": "2020-02-14 08:00:00 -0300", "snippet": "Aula 1INTRODUÇÃO À INTELIGÊNCIA ARTIFICIALA IA surgiu em meados da década de 1950.A tecnologia conta, a partir da IA, com a simulação de processos inteligentes que auxiliam no reconhecimento de padrões, na tomada de decisão ou na execução de tarefas repetitivas.DEFINIÇÕES DE INTELIGÊNCIA ARTIFICIAL   Ser humano Racionalidade Pensar Sistemas que pensam como seres humanos Sistemas que pensam racionalmente Agir Sistemas que agem como seres humanos Sistemas que agem racionalmente Fonte: adaptado de Russel e Norvig (2005, p. 5) Quadrante Definições Pensar como ser humano “O novo e interessante esforço para fazer os computadores pensarem…máquinas com mentes, no sentido total e literal”. (HAUGELAND, 1985). “[Automatização de] atividades que associamos ao pensamento humano, atividades como a tomada de decisões, a resolução de problemas, o aprendizado”. (BELLMAN, 1978). Pensar racionalmente “O estudo das faculdades mentais pelo uso de modelos computacionais”. (CHARNIAK; MCDERMOTT, 1985). “O estudo das computações que tornam possível perceber, raciocinar e agir”. (WINSTON, 1992). Agir como ser humano “A arte de criar máquinas que executam funções que exigem inteligência quando executadas por pessoas”. (KURZWEIL, 1990). Agir racionalmente “A Inteligência Computacional é o estudo do projeto de agentes inteligentes”. (POOLE et al., 1998). Fonte: adaptado de Russel e Norvig (2004, p. 5)O comportamento inteligente requer que exista uma ação sobre o ambiente, sendo característico da automação e da robótica.No caso de robôs que executem alguma atividade no ambiente, de forma diferente de como um ser humano faria, caracteriza a definição do “agir racionalmente”.LINHAS DE PESQUISATemos uma linha de pesquisa dentro da IA que se denomina conexionista, a qual está interessada na arquitetura de dispositivos que simulem as células biológicas que interagem para o surgimento de processos inteligentes. Dentro da linha conexionista, temos como exemplo as redes neurais artificiais e os sistemas imunológicos artificiais. As redes neurais artificiais (RNA) constituem um campo de pesquisa em que a preocupação é lidar com tarefas tais como o reconhecimento de padrões, a previsão e a tomada de decisão utilizando redes de unidades conectadas, treinadas a partir de algoritmos que funcionam baseados em amostras do mundo real e podem assim aprender a classificar padrões (HAYKIN, 2001). Os sistemas imunológicos artificiais são baseados no funcionamento do sistema imunológico que aprende de uma forma muito rápida sobre elementos estranhos (antígenos) que entram em um sistema vivo e que desencadeiam uma reação contrária, com a produção de anticorpos para eliminar os antígenos (MEDEIROS et al., 2008).Temos a linha de pesquisa denominada simbólica. A linha simbólica busca lidar com processos inteligentes, utilizando linguagens baseadas em lógica e construção de redes semânticas para solucionar problemas e simular conhecimento especialista para contextos de diagnóstico. Os sistemas derivados desta linha de pesquisa se denominam ainda de sistemas baseados em conhecimento. Nessa linha são derivadas as pesquisas sobre a linguagem LISP (BITTENCOURT, 1998, p.169), que trabalha com representação de conhecimento na forma de listas, e a linguagem de programação lógica PROLOG, (PALAZZO, 1997, p. 2), que permite a manipulação de símbolos por meio de representação de conhecimento na forma de fatos e regras.Os sistemas especialistas (RUSSELL; NORVIG, 2004, p. 24) são uma das áreas mais relevantes dentro da linha simbólica, referindo-se a sistemas em que o conhecimento de um especialista humano em uma área bem delimitada é representado em uma linguagem, de forma a permitir o diagnóstico de situações e a execução de ações que seriam feitas como se fosse por um ser humano. Portanto, é importante salientar que na linha simbólica, a preocupação se volta à forma como a mente pensa, e não como o cérebro nas suas partes e divisões funciona.Ainda na área simbólica, temos as pesquisas que são feitas na área de ontologias. As ontologias se referem a representações de conhecimento alcançadas por consenso, em áreas específicas de domínio do conhecimento humano, que podem ser manipuladas tanto por seres humanos quanto por agentes inteligentes. As ontologias permitem tanto a representação quanto os procedimentos para inferência e raciocínio sobre tal representação, possibilitando o desenvolvimento da Web Semântica (CORCHO et al., 2008).Outra linha de pesquisa que se soma às linhas simbólica e conexionista e que foge do esquema mente-cérebro é a denominada linha evolucionária. As pesquisas da IA na linha evolucionária se baseiam na forma como se processa a evolução biológica sobre o planeta, e busca simular tais processos evolucionários em sistemas de computador para a resolução de problemas. Dentro desta linha de pesquisa, podemos encontrar uma das áreas mais exploradas que são os algoritmos genéticos. Os algoritmos genéticos são caracterizados como uma classe de algoritmos de busca. Eles implementam o conceito de uma solução inicial, a qual evolui ao longo da execução do algoritmo, em que são aplicados operadores que simulam a seleção natural biológica, o cruzamento de cromossomos e a mutação genética, produzindo soluções melhores ao longo de várias gerações (LINDEN, 2012). Outra área bastante estudada é a programação genética. Aqui não há a preocupação de se fazer programas, mas o próprio algoritmo cria programas iniciais e blocos de programas que vão se combinando e evoluindo de acordo com o objetivo a ser alcançado, até chegar em programas capazes de executar a tarefa. Também são aplicados à programação genética processos equivalentes à seleção natural biológica e à mutação genética (KOZA,1992).BREVE HISTÓRICOLinha do tempo com alguns eventos relativos à linha conexionista da Inteligência ArtificiaLinha do tempo com alguns eventos relativos à linha simbólica da Inteligência ArtificialA história da IA simbólica é dividida em três períodos: clássica, romântica e moderna. A era clássica (1956-1970) tinha como objetivo a simulação da inteligência humana, utilizando solucionadores gerais de problemas e sistemas baseados em lógica proposicional e de primeira ordem. O principal motivo do fracasso foi a subestimação da complexidade computacional dos problemas.Na era romântica (1970-1980), o objetivo já era o de simular a inteligência humana em situações predeterminadas, utilizando formalismos de representação do conhecimento adaptados ao problema, e não mais gerais como proposto na era anterior. Mesmo assim, o motivo do fracasso foi a subestimação da quantidade de conhecimento necessária para resolver mesmo o problema mais banal do cotidiano. Entretanto, surgiram vários conceitos que impulsionaram algumas áreas da ciência da computação como a orientação a objeto, os ambientes de desenvolvimento e software e o processamento de tempo compartilhado.Na era moderna (1980 até este momento), o objetivo foi o de simular o comportamento de um especialista humano ao resolver problemas em domínios bem específicos. Como metodologias, utilizavam-se sistemas de regras de produção, modelos de representação de conhecimento com incerteza e também algumas abordagens conexionistas. Ainda assim, o motivo do fracasso continuou sendo o das subestimações do problema de aquisição de conhecimento. Porém outras áreas da computação foram beneficiadas com as pesquisas, tais como a engenharia de software e bancos de dados.Linha do tempo com alguns eventos relativos à linha evolucionária da Inteligência ArtificialAula 2AGENTES INTELIGENTESPodemos definir um agente como sendo um artefato equipado com sensores com capacidade de perceber o ambiente e com capacidade de ação sobre o ambiente por meio de atuadores. Mas um agente precisa também processar os sinais provenientes dos sensores para efetuar alguma ação que seja caracterizada como inteligente sobre o seu ambiente. Contudo um agente não deve considerar apenas o que está sendo percebido no momento, mas também considerar a memória do que já foi percebido por ele, o que podemos definir como uma sequência de percepções. Em matemática, diz-se que o comportamento de um agente é definido pela função do agente. A função do agente tem o objetivo de mapear as possíveis ações com as sequências de percepções disponíveis no armazenamento do agente.Uma das dificuldades de construção de agentes inteligentes está em quão completa pode ser a descrição do comportamento de um agente. Dessa forma, entende-se a função do agente como uma descrição matemáticaabstrata, enquanto que um programa de agente é uma implementação concreta, ligada à forma que o agente é construído, ou seja, à sua arquitetura.Agente racional: o agente que, a partir das suas ações, obterá o maior sucesso. Assim, é necessário algum método para quantificar o sucesso de um agente. Por meio de medidas de desempenho, pode-se verificar se um agente teve sucesso na execução da sua tarefa.Para cada sequência de percepções possível, um agente racional deve selecionar uma ação que se espera venha a maximizar sua medida de desempenho, dada a evidência fornecida pela sequência de percepções e por qualquer conhecimento interno do agente.Assim, a racionalidade em qualquer instante depende de quatro fatores: A medida de desempenho como critério para obtenção do sucesso da tarefa; O conhecimento prévio do agente com relação ao ambiente; As ações que o agente pode executar; A sequência de percepções que o agente tem até o momento.A racionalidade em um agente significa que ele buscará maximizar o desempenho esperado, não o desempenho real.Em outras situações, é necessário que o agente não reaja apenas às informações que são coletadas, mas também possa aprender a partir das suas percepções. Aliado a isso, temos o conceito de autonomia. A autonomia significa o quanto o agente depende de um conhecimento prévio ou deve aprender ao longo da sua tarefa para compensar premissas incorretas que foram planejadas.NATUREZA DOS AMBIENTESNa modelagem de um agente racional, precisamos definir de maneira tão completa e precisa possível o ambiente de tarefa. O ambiente de tarefa pode ser definido por meio do PEAS (Performance, Environment,Actuators and Sensors – Desempenho, Ambiente, Atuadores e Sensores). Tipo de Agente Medida de desempenho Ambiente Atuadores Sensores Sistema de diagnóstico médico Paciente saudável, minimizar custos Quarto de hospital, paciente, equipe Mostrar perguntas, testes, diagnósticos, tratamentos Entrada por teclado, voz, descoberta de informação Sistema de xadrez Calcular a jogada ótima, ganhar a partida Tabuleiro 8x8, peças de xadrez, posições iniciais, jogadas possíveis Braço articulado para mover as peças Câmera para ver as posições das peças PROPRIEDADES DOS AMBIENTES DE TAREFAS Critérios Descrição Exemplo Completamente observável x parcialmente observável Se os sensores do agente acessam de forma completa os estados do ambiente em cada instante, o ambiente é completamente observável. Se houver ruído, sensoriamento impreciso ou lacunas nos estados, é parcialmente observável. Um jogo de xadrez á completamente observável. Um sistema de busca na internet é parcialmente observável. Determinístico x Estocástico Se o próximo estado é completamente determinado pelo estado atual e pela ação executada pelo agente, o ambiente é dito determinístico, senão, é estocástico. Se o sistema é determinístico mas apresenta elementos estocásticos, o ambiente é dito estratégico. O exemplo do robô aspirador de pó é determinístico. Um carro com direção autônoma é estocástico. Episódico x Sequencial Num ambiente de tarefa episódico, o agente experimenta os eventos de maneira atômica, com os episódios começando com a percepção do agente e na execução de uma única ação. Num ambiente sequencial, há a dependência dos estados atuais com os estados anteriores. Um jogo de xadrez é sequencial. Um robô aspirador de movimento aleatório é episódico. Estático x Dinâmico Caso o ambiente se altere enquanto o agente está executando a tarefa, ele é dinâmico. Se o ambiente não se modifica ao longo da execução, é estático (Há situações em que os ambientes podem ser caracterizados como semidinâmicos) Um jogo de xadrez é estático. Um carro com direção autônoma é dinâmico (ou semidinâmico, considerando as rotas predefinidas). Discreto x Contínuo Refere-se ao modo como o tempo é considerado, e também ao estado do ambiente e das percepções e ações. Uma sequência de estados discretos muda de forma brusca de um estado para outro. Uma sequência de estados contínua muda de forma suave. Um jogo de xadrez é considerado discreto. Um sistema de refrigeração de temperatura pode ser contínuo. Individual x Multiagente Se no ambiente existe apenas um agente atuando para resolver o problema, ou se o sistema considerado é multiagente. Um jogo de xadrez pode ser um agente individual (Se um agente joga contra outro, é multiagente). Um sistema de busca na internet pode ser multiagente por utilizar vários bots que encontram e organizam a informação. ESTRUTURAS DE AGENTESOs agentes podem ser classificados em quatro tipos: Agentes reativos simples;Os agentes reativos simples selecionam as ações a serem executadas com base na percepção atual, desconsiderando o histórico de percepções. Podem ser implementados utilizando as regras de produção ou regras se-então. Agentes reativos baseados em modelo;Em um ambiente caracterizado por ser observável parcialmente, se o agente puder manter internamente estados internos que sejam dependentes da sequência de percepções, ele pode lidar de forma mais efetiva na resolução do problema. Nesse caso, o agente trabalha com um estado interno que é dependente das informações sobre como o mundo (ambiente) evolui. Um agente que tem o conhecimento de “como o mundo funciona”, possui o que se denomina de modelo do mundo. Assim, o agente que utiliza este modelo é chamado de agente reativo baseado em modelo. Agentes baseados em objetivos;Ter o conhecimento do estado atual do ambiente não é condição suficiente para que se decida o que fazer. Além de o agente saber uma descrição do estado atual, é necessário ainda alguma informação quanto aos objetivos que se relacionam a situações ou cenários desejáveis. Uma tomada de decisão baseada em objetivos é diferente da utilização de regras se-então, por envolver uma consideração sobre o futuro. O agente então se pergunta: “o que vai acontecer se eu fizer esta ação ou aquela outra?” ou “isso irá me fazer feliz?”. Tais informações nos agentes reativos não são representadas de maneira explícita, devido ao mapeamento direto das percepções para as ações. Ainda que o agente baseado em objetivos possa parecer menos eficiente, ele tende a ser mais flexível. O conhecimento que dá o suporte às suas decisões é representado explicitamente, podendo ser atualizado ou modificado.Os objetivos permitem que se distingam entre estados “felizes e “infelizes” de forma binária. Quando um agente precisa lidar com mais de um objetivo, diferentes objetivos podem entrar em contradição ou nenhum deles pode ser alcançado com certeza, então é necessário especificar o programa com uma função que possa lidar com situações de forma mais adequada ou útil. Agentes baseados na utilidade.Uma função de utilidade permite quantificar o mapeamento de um estado ou uma sequência de estados em um número que descreve o grau de “felicidade” alcançado. Dessa forma, uma especificação de uma função de utilidade permite a tomada de decisões racionais em dois casos em que os objetivos são inadequados: Quando são contraditórios e apenas alguns deles podem ser alcançados; Quando há vários objetivos e nenhum deles pode ser alcançado com certeza.No primeiro caso, uma função de utilidade pode especificar o grau de compromisso mais apropriado. No segundo caso, uma função de utilidade pode fornecer um número que expresse um grau de probabilidade de sucesso que possa ponderar a importância dos objetivos.AGENTES COM APRENDIZAGEMO agente com aprendizagem permite ir além do conhecimento prévio na construção do agente, dotando-o de mecanismos para que possa aprender na experiência com o ambiente, tornando-se mais competente o longo da sua operação. Um agente de aprendizado pode ser dividido em quatro elementos conceituais: Elemento de desempenho: é a parte considerada até agora sobre agentes, que recebe as percepções e decide qual ação executar. Crítico: elemento do agente que informa como o agente está se comportando em relação ao seu padrão constante de desempenho. Elemento de aprendizado: utiliza a informação proveniente do crítico para modificar o elemento de desempenho em direção a um melhor funcionamento no futuro. Gerador de problemas: elemento responsável para sugestão de novas regras e ações que podem levar a novas experiências.Aula 3RESOLUÇÃO DE PROBLEMAS POR BUSCAOs agentes inteligentes mais simples, os reativos, conferem as suas ações ao mapeamento direto dos estados. Em ambientes nos quais tal mapeamento é grande demais, tanto em termos de memória quanto de tempo de processamento, os agentes não são eficientes. Nestes casos, os agentes que são baseados em objetivos saem-se melhor por considerarem os possíveis cenários e o quanto os resultados são bons ou não.Os agentes de resolução de problemas tomam decisões sobre os próximos passos, encontrando as sequências de ações que resultam estados desejáveis. Um algoritmo de busca recebe na sua entrada um problema e apresenta na sua saída uma solução, descrita sob a forma de uma sequência de ações definidas.Um problema pode ser definido de maneira formal em quatro componentes:Um estado inicial: o estado no qual o agente começa.Uma função sucessor: Dado um estado particular x, SUCESSOR(x) retorna um conjunto de pares ordenados &lt;ação,sucessor&gt; em que cada ação é uma das ações válidas no estado x, e cada sucessor pode ser alcançado partindo-se de x. O estado inicial e a função sucessor definem o espaço de estados do problema, ou seja, o conjunto de todos os estados acessíveis, tendo como partida o estado inicial. O espaço de estados representa um grafo no qual os nós são os estados e os arcos entre os nós são as ações.O teste de objetivo: determina se um estado é um estado objetivo. Em alguns casos, um objetivo pode ser definido como uma propriedade abstrata e não por um estado ou conjunto de estados específicos.A função de custo: também chamada de função de custo de caminho, que atribui um custo numérico a cada caminho. O agente irá escolher, portanto, uma função de custo que irá significar a sua própria medida de desempenho.Definidos os quatro elementos da formulação do problema, uma solução para um problema é um caminho que leva o agente desde o estado inicial até o estado objetivo. Considerando a qualidade da solução, a qual é medida pela função custo, uma solução ótima é aquela que apresenta o menor custo dentre todas as soluções possíveis.O problema do caixeiro viajante é uma extensão do problema de roteirização, em que todos os pontos de uma rede precisam ser visitados, em vez de apenas alguns. Este problema demonstra a explosão combinatória que pode acontecer, mesmo o problema tendo poucas instâncias para resolução. A quantidade de possibilidades de rotas por todos os pontos é da ordem de (n-1)!BUSCA DE SOLUÇÕESO propósito da busca é fazer esta expansão de forma contínua, avaliando os nós gerados, escolhendo um especificamente e verificando se o nó é um estado objetivo ou não. Nesse processo, a escolha de qual estado expandir é determinada pela estratégia de busca.Um algoritmo de resolução de problemas resulta uma solução ou uma falha. As falhas podem acontecer devido ao algoritmo ficar paralisado em um loop infinito e, assim, nunca retornar uma saída. A avaliação de desempenho de um algoritmo pode ser feita a partir de quatro aspectos:Completeza: o algoritmo de busca oferece a garantia de encontrar uma solução quanto ela existir?Otimização: A estratégia encontra a solução ótima?Complexidade de tempo: Quanto tempo é dispendido para encontrar uma solução?Complexidade de espaço: Quanto de memória é necessária para a execução da busca?ESTRATÉGIAS DE BUSCAAs estratégias de busca dividem-se em duas classes: estratégias sem informação ou estratégias cegas e estratégias com informação ou busca heurística. As estratégias se diferenciam conforme a ordem de expansão dos nós da árvore de busca. As estratégias sem informação dividem-se em: Busca em extensão ou amplitude;A busca em extensão ou amplitude é uma estratégia simples na qual o nó raiz é expandido inicialmente, depois os sucessores do nó raiz, depois os sucessores dos sucessores do nó raiz e assim por diante. A busca em extensão é completa: se o nó objetivo estiver em uma profundidade finita d, a busca em extensão encontrará após a expansão de todos os nós mais rasos, considerando que o fator de ramificação b seja finito. O nó objetivo mais raso não significa que seja o nó ótimo. A busca em extensão será ótima se o custo do caminho for uma função não decrescente da profundidade do nó, como por exemplo, se o custo for o mesmo para todas as ações. Busca de custo uniforme;A busca de custo uniforme difere da busca em extensão por considerar a expansão do nó com o custo mais baixo. Este tipo de busca não se importa com o número de passos em um caminho, mas apenas com o custo total. Pode-se garantir a completeza desde que o custo em cada passo seja maior ou igual a um valor constante positivo pequeno denominado aqui de ε. Esta condição garante o caráter ótimo, significando que o custo é crescente à medida que se percorre o caminho. Busca em profundidade;A estratégia de busca em profundidade expande sempre o nó mais profundo na borda atual da árvore de busca. A busca vai prosseguindo até o nível mais profundo da árvore, onde não existem mais nós sucessores. Após visitar os nós mais profundos, a busca retorna ao nível mais raso, que ainda possui nós não explorados. Uma das vantagens da busca em profundidade é que ela possui requisitos de memória pequenos em relação às outras estratégias. Só é necessário armazenar um único caminho do nó raiz até o nó sendo visitado. À medida que os nós e seus descendentes são explorados, eles podem ser removidos da memória. A desvantagem da estratégia de busca em profundidade é que ela pode descer um caminho muito longo (ou ainda infinito), podendo ficar paralisada, quando o nó objetivo poderia estar bem próximo do nó raiz da árvore de busca. Busca em profundidade limitada;A abordagem da busca em profundidade limitada permite que atenuemos o problema das árvores muito grandes ou ilimitadas, delimitando a profundidade a um valor máximo x. Ou seja, os nós na profundidade x são tratados como se não tivessem nós sucessores. Ele permite resolver o problema dos percursos infinitos, mas pode trazer um fator de incompleteza, ou seja, se x &lt; d, então o objetivo mais raso estaria além do limite imposto. Quando se tem algum conhecimento sobre o problema, pode-se impor um limite à estratégia de busca em profundidade. Busca de aprofundamento iterativo;Esta estratégia é uma variação da busca em profundidade, que procura aumentar gradualmente o limite de profundidade a partir do nó raiz, depois 1, depois 2, e assim sucessivamente, até que encontre um objetivo. Isso deverá ocorrer quando o limite da profundidade alcançar d, a profundidade do nó objetivo mais raso. A estratégia de aprofundamento iterativo combina os benefícios da busca em profundidade e da busca em extensão. Os requisitos de memória também são modestos. Assim como na busca em extensão ou amplitude, o algoritmo é completo quando o fator de ramificação for finito, e ótimo quando o custo do caminho é uma função não decrescente em relação à profundidade do nó. A complexidade de tempo da busca em aprofundamento iterativo é melhor que a da busca em extensão. De forma geral, a busca por aprofundamento iterativo em profundidade é o método de busca sem informação preferido quando há um espaço de busca muito grande e a profundidade da solução dentro da árvore não é conhecida. Busca bidirecional;A noção na estratégia de busca bidirecional é a execução de duas buscas que acontecem simultaneamente, uma de forma direta, partindo do estado inicial como temos visto até agora, e outra que parte do objetivo, acontecendo a parada quando as buscas se encontram em um estado intermediário. A motivação principal é que uma busca que tenha uma expansão bd/2 + bd/2 é bem menor do que bd. Por exemplo, se o fator de ramificação b = 10 e a profundidade d = 6, numa busca em extensão padrão, teríamos um total de N = 11.111.101 nós (mais de 11 milhões de nós), enquanto que na busca bidirecional (considerando agora a profundidade d = 3, duas vezes) teríamos N = 22.202 nós. Busca em Extensão ou Amplitude.As estratégias de busca sem informação tendem a ser ineficientes na maioria dos casos. Estratégias de busca que utilizam algum conhecimento específico do sistema pode ser uma melhor opção mais eficiente. As estratégias neste caso apresentam uma abordagem denominada de busca pela melhor escolha. Esta busca considera um algoritmo que é uma especialização do algoritmo geral da busca em árvore, em que um nó é selecionado para expansão com base em uma função de avaliação f(n). Na verdade, não há de fato uma melhor escolha, mas a escolha que parece ser a melhor, conforme a função de avaliação.Existem dois tipos de busca com informação: a busca gulosa e o algoritmo A* (chamado de “A-estrela”).A busca gulosa é uma estratégia que tenta expandir o nó mais próximo à meta, na suposição de que levará provavelmente a uma solução de forma rápida, avaliando apenas a função heurística: f(n) = h(n).A busca A* é a estratégia mais conhecida de busca pela melhor escolha. A avaliação da busca combina o custo para alcançar cada nó, dado por g(n), e o custo para ir do nó em questão até o objetivo h(n) na forma: f(n) = g(n) + h(n). Assim, f(n) representa o custo estimado da solução de custo mais baixo passando pelo nó n.FUNÇÕES HEURÍSTICASA definição de uma função heurística h(n) irá depender da natureza do problema de busca. Vimos que uma boa função heurística requer uma heurística admissível, cujo comportamento nunca superestime o custo para se alcançar o objetivo (RUSSELL; NORVIG, 2004, p. 97). Assim, a modelagem de uma função heurística requer uma dose de bom senso no estudo das características do problema.Aula 4SISTEMAS ESPECIALISTASDentro da linha de pesquisa simbólica da IA, os Sistemas Especialistas (SE) são programas de computador que imitam o comportamento de especialistas humanos dentro de um domínio específico de conhecimento. Podemos afirmar que SE é uma técnica da IA desenvolvida para resolver problemas em um determinado domínio, cujo conhecimento utilizado é obtido de pessoas que são especialistas naquele domínio.COMPONENTES DE UM SISTEMA ESPECIALISTADe forma geral, um sistema especialista pode ser dividido em três módulos: uma base de conhecimento, um quadro negro e um mecanismo de inferência (também chamado de motor de inferência). A base de conhecimento é onde fica armazenado o conhecimento obtido do domínio no qual atua o SE, traduzido na forma de regras, e também uma memória de trabalho. No quadro negro, as informações são alimentadas ao sistema com relação às variáveis que são lidas do ambiente. O mecanismo de inferência é o responsável pelo encadeamento e teste das regras, fornecendo um resultado em função dos fatos alimentados ao sistema especialista.graph LR A[Base de Conhecimento]&lt;--&gt;|Verificar fatos| B[Quadro Negro] A &lt;--&gt; C[Mecanismos de inferência] A &amp; C &lt;--&gt; |Buscar novas regras|B C &lt;--&gt;|Análise de regras|BA base de conhecimento contém as condições expressas nas regras que se referem às perguntas. Estas perguntas envolvem variáveis que precisam ser instanciadas (receber valores) e passar logo após por um processo de inferência. O motor de inferência controla, portanto, a atividade do sistema especialista, ocorrendo em ciclos que se constituem de três fases:1) A seleção das regras a partir dos dados correspondentes de entrada;2) A resolução de conflitos indicando quais regras serão efetivamente executadas, a partir de priorização e ordenação;3) A ação propriamente dita.ETAPAS PARA CONSTRUÇÃO DE UM SISTEMA ESPECIALISTA1) Identificação e definição do domínio do problema;a. são identificadas possíveis variáveis e possibilidade de divisão do problema a ser abordado em subproblemas.2) Aquisição do Conhecimento;a. é considerada a parte mais sensível no desenvolvimento de um SE, muitas vezes o gargalo do processo. Essa dificuldade está relacionada muitas vezes com a dificuldade de transmissão do conhecimento por parte do especialista; ou porque o conhecimento não é bem definido, ou porque é difícil expressar este conhecimento em palavras. A aquisição de conhecimento é realizada geralmente por meio de entrevistas e interações com especialistas do domínio. A aquisição de conhecimento consiste, assim, na coleta e análise de informações de um ou mais especialistas e qualquer outra fonte, possibilitando a produção de documentos.3) Organização e Representação do Conhecimento;a. A organização do conhecimento de um SE é feita de fatos e regras. Um fato é uma forma de conhecimento declarativo. Fatos são usados para descrever relacionamentos entre estruturas de conhecimento mais complexas e controlar o uso destas estruturas durante a resolução de problemas. Em IA e SE, um fato é às vezes referenciado como uma proposição. Uma proposição é uma declaração que pode ser verdadeira ou falsa. A representação do conhecimento em um SE utiliza, como visto anteriormente, regras. Regras são sequências lógicas compostas por premissas (antecedentes) e conclusões (consequentes). É comum o uso da expressão condicional SE-ENTÃO para representar regras dentro de um sistema especialista. As regras podem ser deterministas ou probabilísticas.4) Implementação do SE;a. Para a fase de implementação, é realizada aqui a escolha de uma linguagem de programação ou pacote (muitas vezes chamado de shell) pelo analista, na implementação do sistema. As linguagens utilizadas para codificar sistemas especialistas geralmente diferem das linguagens convencionais, tais como C ou Java, e tal escolha pode implicar no desenvolvimento do próprio mecanismo de inferência do SE. As shells apresentam vários benefícios no desenvolvimento de um SE, pois já implementam o motor de inferência. Um exemplo de shell é o Expert SINTA.5) Testes e Validação.EXEMPLO DE SISTEMA ESPECIALISTAgraph TD A[A-&gt;B SE renda &gt; 5000 ENTÃO perguntar sobre Prestação de carro SENÃO SAÍDA] --&gt; B[B-&gt;C SE Prestação do Carro &lt; 10% da renda ENTÃO perguntar sobre prestação da casa SENÃO SAÍDA] B --&gt; C[C-&gt;D SE Prestação da Casa&lt;20% da renda ENTÃO conceder empréstimo SENÃO SAÍDA] C --&gt;D[D Conceder linha de crédito] D --&gt;E[D-&gt;E SE D perguntar sobre tempo de trabalho] E --&gt;F[E-&gt;F SE tempo&gt;=4 anos ENTÃO conceder linha de 10.000 SENÃO Executar G] F --&gt;G[F Limite de 10.000] F --&gt;H[G-&gt;H SE tempo&lt;4 anos ENTÃO Perguntar sobre outras dívidas] H --&gt;I[H-&gt;F SE outras dívidas&lt;5% da renda ENTÃO Executar F SENÃO Executar I] I --&gt;G I --&gt;J[I Limite de 3.000]PROGRAMAÇÃO LÓGICA COM PROLOGUma das principais ideias subjacentes da programação em lógica é de que um algoritmo é constituído por dois elementos disjuntos: a lógica e o controle. O componente lógico corresponde à definição do que deve ser solucionado. O componente de controle estabelece como a solução pode ser obtida.Quando programando em PROLOG, o programador precisa somente descrever o componente lógico de um algoritmo, deixando o controle da execução para ser exercido pelo sistema de programação em lógica utilizado. A atividade do programador passa a ser simplesmente a especificação do problema que deve ser solucionado.Assim, um programa em lógica é a representação de um problema expresso por meio de um conjunto finito de um tipo especial de sentenças lógicas denominadas de cláusulas.Ao contrário de um programa em linguagens como C ou Java, um programa em lógica não é a descrição de um procedimento para se obter a solução de um problema; o sistema é inteiramente responsável pelo procedimento a ser adotado na execução. Por isso, é dito que o paradigma fundamental da programação em lógica é o da programação declarativa, em oposição à programação procedural, típica das linguagens convencionais como C ou Java. O ponto focal da programação em lógica consiste em identificar a noção de computação com a noção de dedução.Uma cláusula em PROLOG pode ser de três tipos: Fatos: Denotam uma verdade incondicional; Regras: Definem as condições que devem ser satisfeitas para que uma declaração seja considerada verdadeira; Consulta: Interrogação ao programa para verificar a verdade do conhecimento nele contido. Cláusula Exemplo Descrição Fato pai(joão, luiz). Este fato é traduzido como “João é o pai de Luiz”. Regra filho(X,Y) :- pai(Y,X). Se X é filho de Y, então Y é pai de X. O sinal “:-“ funciona como uma “seta à esquerda”, donde a conclusão à direita é obtida a partir das premissas que estão na direita. Consulta ?- filho(luiz, joão). True A consulta tenta obter se, a partir dos fatos e das regras existentes na base de conhecimento, Luiz é filho de João. A regra acima deduz um novo fato, a partir do fato e da regra anterior. Uma cláusula é dividida nos seguintes componentes: Corpo: lista de objetivos separados por vírgulas, que devem ser interpretadas por conjunções; Cabeça: contém o resultado do corpo, inferido a partir dos objetivos.Um fato contém apenas “cabeça”. A consulta só possui o “corpo”. Uma regra contém tanto cabeça quanto corpo.Uma variável é composta de uma cadeia de letras, dígitos e do caractere “_”. O caractere “_” sozinho significa uma variável anônima, que é utilizada no caso de uma determinada variável não ter importância para o processo de dedução de uma solução. O fator chave que diferencia em PROLOG uma variável de uma constante é a primeira letra da variável sempre estar em maiúsculas (“caixa alta”).Aula 5INTRODUÇÃO A REDES NEURAIS ARTIFICIAISO trabalho em Redes Neurais Artificiais (RNA) tem sido motivado desde o começo pelo reconhecimento de que o cérebro humano processa informações de uma forma inteiramente diferente de um computador convencional. O cérebro é um computador altamente complexo, não linear e paralelo possui a capacidade de organizar seus constituintes estruturais, os neurônios, de forma a realizar certos processamentos tais como reconhecimento de padrões, percepção e controle motor, de forma mais rápida que o mais rápido computador existente.Podemos conceituar uma rede neural artificial como um processador maciçamente e paralelamente distribuído constituído de unidades de processamento simples, que têm a propensão natural para armazenar conhecimento experimental e torná-lo disponível para o uso. Parte da linha de pesquisa conexionista.Uma rede neural artificial tem uma série de propriedades:Não linearidade: neurônios podem ser lineares ou não lineares, dessa forma, permitem aproximações robustas de funções de mapeamento que tenham característica não linear.Mapeamento Entrada-Saída: A rede aprende a partir de exemplos, estabelecendo mapeamento entre os padrões apresentados na entrada com as saídas dadas pelos exemplos.Adaptabilidade: redes neurais podem ser treinadas e armazenar o conhecimento nos pesos sinápticos, podendo se adaptar caso o conjunto de amostras utilizado para o treinamento se modifique ao longo do tempo.Resposta a Evidências: uma rede neural pode perfazer uma tarefa de seleção de um padrão, mas também informar sobre o grau de confiança ou crença referente ao padrão escolhido.Informação Contextual: o conhecimento é armazenado na própria estrutura e pela ativação da rede neural.Tolerância a falhas: redes que sejam implementadas em hardware são tolerantes a falhas, em caso de neurônios ou conexões que possam ser danificados, ou mesmo em software utilizando técnicas de poda de redes, que reduzem a quantidade de neurônios ou sinapses, mantendo a mesma condição de performance.Uma rede neural artificial tem a sua construção dependente de alguns elementos:Número de camadas: as RNA possuem pelo menos uma camada de entrada, de onde recebe os sinais ou características das amostras, e uma camada de saída que apresenta os padrões ou classes, mapeados para os conjuntos de treinamento. Também podem possuir uma ou mais camadas ocultas, como no caso do perceptron multicamada e das redes de base radial.Quantidade de neurônios por camada: a quantidade de neurônios irá depender da natureza do problema sendo abordado. A camada de entrada terá tantos neurônios conforme as características das amostras do conjunto de treinamento. A camada de saída terá os neurônios referentes às classes a que pertencem as amostras do conjunto de treinamento. A camada oculta ou escondida pode ter a quantidade de neurônios variável, conforme a característica do mapeamento que se deseja.Tipo de função de transferência: a função de transferência define a ativação do neurônio. Podem ser utilizadas funções discretas (tais como a função degrau, utilizada no perceptron a ser explicado adiante) ou funções contínuas (como a função sigmoide para o perceptron multicamada).Método de treinamento: ao longo dos anos foram desenvolvidos diversos métodos ou algoritmos de treinamento. Dentre os métodos mais utilizados está o algoritmo de retropropagação (backpropagation), que utiliza a informação do erro na atualização dos pesos.As RNA podem aprender de diversas formas:Aprendizagem por correção de erros: a informação do erro é utilizada para modificar os pesos sinápticos.Aprendizagem baseada em memória: um grande número de exemplos de entrada e saída são armazenados, e uma amostra é comparada com a sua vizinhança para se identificar a classe à qual pertence.Aprendizagem hebbiana: com base nos estudos de Hebb, utiliza uma regra associativa, que aumenta a força dos pesos positivamente correlacionados ou diminui daqueles negativamente correlacionados.Aprendizagem competitiva: neste tipo de aprendizagem, os neurônios competem entre si, tendo-se um vencedor que estará ativo em um certo instante (aprendizagem denominada também de winner-takes-all).Aprendizagem de Boltzmann: aprendizagem com características estocáticas derivada das ideias da mecânica estatística. Nesse caso, os neurônios constituem uma estrutura recorrente e operando de maneira binária, controlados por uma função de energia. A atualização dos pesos se dá por correlação, operando em duas condições: uma condição presa (os neurônios visíveis estão presos a estados específicos) e outra condição livre (todos os neurônios podem operar livremente).A aprendizagem ainda pode ser caracterizada como supervisionada (em que há o feedback que retorna à rede para orientar o treinamento) e não supervisionada (a rede aprende de forma auto-organizada). Quanto às tarefas que podem ser executadas por uma RNA estão: Associação de padrões; Reconhecimento de padrões; Aproximação de funções; Controle; Filtragem.O PERCEPTRONO perceptron foi um dispositivo eletrônico inventado em 1957 por Frank Rosenblatt (1928-1971). O perceptron foi construído de acordo com princípios biológicos e que mostrava capacidade de aprendizado. Era organizado em três camadas de unidades (ou neurônios): unidades sensoriais (S), associativas (A) e geradoras de respostas (R), alimentada à frente.O perceptron obtém os sinais do ambiente por meio das entradas, nas quais são apresentados os valores correspondentes aos padrões que queremos classificar, por exemplo, valores de pixels de imagem ou características de um produto.Fazendo parte da estrutura interna do perceptron, temos os pesos ou sinapses. Os pesos assumirão valores tais que, quando aplicarmos um padrão na entrada, obteremos uma saída intermediária d. O aprendizado da rede ficará armazenado nos pesos e seus valores são obtidos mediante um processo de treinamento. O valor w0. é chamado de bias, sendo fixo e entendido como uma espécie de ajuste fino, o qual não multiplica com entrada nenhuma.A saída intermediária d é calculada mediante o somatório da multiplicação entre cada entrada e seu peso. Ou seja,d = w1x1 + w2x2 + w3x3 + w4x4 + w5x5 + w0Após o cálculo da saída intermediária d, precisamos então calcular agora a saída ativada o (do inglês output). Como visto na figura 3, a saída ativada o depende do resultado da saída intermediária d. Caso o resultado obtido em d for maior ou igual a 0 (zero), o será igual a +1(um); se d for menor que 0 (zero), o será igual a –1 (menos um).PERCEPTRON MULTICAMADAO perceptron multicamada se diferencia do perceptron simples por incluir camadas escondidas ou ocultas na RNA. Com a inclusão de camadas ocultas, o número de pesos ou sinapses aumenta consideravelmente. A consequência disso é a possibilidade de melhorar o mapeamento das entradas com as saídas. Um perceptron simples trabalha de forma linear, enquanto que o perceptron multicamada tem condições de lidar com conjuntos de treinamento cuja separabilidade seja não linear.A arquitetura com camadas ocultas requer algoritmos de aprendizagem que contemplem a atualização dos pesos relacionados às camadas internas. O processo de ativação acontece primeiramente nas camadas ocultas para depois chegar até a camada de saída. A retroalimentação do erro também é feita nos pesos que conectam a(s) camada(s) oculta(s).A dinâmica do perceptron multicamada envolve o processamento de dois tipos de sinais se propagando pela rede:Sinal funcional: é o sinal apresentado à camada de entrada referente aos atributos do vetor de amostras, que propaga-se para a frente na rede, nó por nó, ativando os neurônios até a camada de saída.Sinal de erro: tem origem em um neurônio da camada de saída, porém se propagando para trás na rede, ajustando os valores dos pesos ou sinapses.Normalização: A utilização do perceptron multicamada para vários tipos problemas requer que os valores dos neurônios das camadas de entrada e saída sejam modificados para trabalhar numa faixa específica, que facilite a codificação do algoritmo e evite possíveis erros relacionados com overflow de variáveis. A fórmula que poderemos utilizar para a normalização será:\\(x_{\\text{normalizado}}=\\frac{x_{\\text{entrada}}-x_{\\text{min}}}{x_{\\text{max}}-x_{\\text{min}}}\\)Aula 6INTRODUÇÃO A ALGORITMOS GENÉTICOSAs pesquisas de IA, dentro da linha evolucionária, baseiam-se na observação de mecanismos evolutivos da natureza, incluindo auto-organização e comportamento adaptativo. Os modelos mais conhecidos de algoritmos evolucionários são os algoritmos genéticos, a programação genética e as estratégias evolucionárias.Um algoritmo genético (AG) faz parte da classe de algoritmos de busca. O algoritmo procura uma solução dentro de um espaço para um problema de otimização. Assim, os algoritmos genéticos podem ser uma boa opção para efetuar a busca em problemas considerados intratáveis.Podemos afirmar que um AG é considerado um algoritmo de busca em feixe estocástica, em que os estados sucessores são criados a partir da combinação de dois (ou mais) estados “pais”, em vez de serem criados a partir da variação de um único estado. Temos assim uma analogia com a seleção natural proveniente da biologia. A busca em feixe se dá pelo uso de uma população inicial gerada aleatoriamente, que evolui ao longo das “gerações” (iterações do algoritmo). A produção de uma nova população é avaliada por uma “função objetivo”, ou “função de fitness”. Essa função retorna à nova população, priorizando os estados melhores.Dos principais fatores que têm feito dos AG uma técnica de busca bem-sucedida e utilizada, estão: Possui operacionalização simples; Baixa dificuldade de implementação; Apresenta alta eficácia com relação ao processo de busca na região onde provavelmente se encontra o valor máximo global; Útil quando se tem pouco ou mesmo nenhum conhecimento do problema, ou ainda quando tal conhecimento é impreciso.Pelas suas características, os AGs fazem parte dos métodos probabilísticos de busca e otimização. Os AGs utilizam o conceito de probabilidade, mas não são considerados simples buscas aleatórias. Ao contrário, eles direcionam a busca para regiões onde é mais provável encontrar uma solução ótima. Diferente das técnicas de busca convencionais, as principais diferenças residem em: “A busca da melhor solução é feita sobre uma população de pontos e não sobre um único ponto (busca em feixe)”; “Os AGs perfazem uma busca cega, sendo a única exigência o conhecimento da função objetivo de cada indivíduo, não sendo necessária nenhuma informação adicional”; “Os AGs usam operadores estocásticos ou probabilísticos e não regras determinísticas na direção de uma busca altamente exploratória e estruturada; as informações das gerações anteriores são acumuladas, auxiliando a direcionar estas buscas”.Passos genéricos para o Algoritmo Genético:1. Gera-se aleatoriamente uma população de candidatos a solução do problema.2. Enquanto não satisfaz as condições de terminação (cada iteração e geração):(a) Gera-se uma nova população inicialmente vazia.(b) Enquanto a nova população não estiver completa:i. Executa a seleção de dois indivíduos aleatoriamente da população atual, dando preferência na seleção àqueles indivíduos que possuem maior fitness.ii. Executa o crossover dos dois indivíduos, conforme um ponto de corte, para obter dois novos indivíduos.(c) Concede a cada membro da nova população a chance da operação de mutação.(d) Substitui a população atual com a nova população.3. Escolhe o indivíduo da população com a melhor avaliação de fitness para ser a solução do problema.População é o conjunto de candidatos a soluções do problema em questão. Por meio das sucessivas gerações, novos candidatos são gerados na população, ao passo que outros desaparecem, ou seja, são descartados da população. Uma solução na população é denominada indivíduo. A adaptação ou adequação (fitness), relacionada a um indivíduo, significa a qualidade dessa medida representada por esse indivíduo. “Quanto melhor a solução, maior será a sua adaptação. É claro que isso depende das características do problema a ser resolvido”.Os indivíduos que fazem parte de um AG precisam de uma codificação que o simbolize no espaço possível de indivíduos que caracterizam o problema. Essa codificação é feita utilizando-se cromossomos. Um cromossomo é a tradução das características do indivíduo no alfabeto utilizado pelo AG. Podemos concluir que um cromossomo é uma sequência de bits, sendo constituídos por “genes” que se referem a cada bit. Os algoritmos geralmente utilizam como alfabeto a codificação binária (0’s e 1’s) para sua representação. Um cromossomo terá também um comprimento fixo de bits ou genes.Os operadores mais comuns utilizados nos AG para criar os novos indivíduos através das gerações são: Seleção: Os indivíduos mais adaptados (ou seja, aqueles que apresentam melhor fitness) são selecionados para gerarem a descendência. Um dos métodos mais utilizados para perfazer a seleção é o método da roleta viciada ou roleta ponderada. Esse método dá mais probabilidade para que um indivíduo de maior fitness seja escolhido em contrapartida a outro elemento que tenha menor fitness. Isso não quer dizer que os indivíduos que possuam menor fitness não passem para a próxima geração, mas que a probabilidade de fazerem parte dessa nova geração é reduzida. Cruzamento ou crossover: O crossover ou cruzamento ocorre pela mistura de duas soluções ou indivíduos, com o objetivo de criar dois novos indivíduos. Esse cruzamento tende a formar novos indivíduos, que possuem características dos “pais”, e que têm a possibilidade de atender melhor o fitness. O crossover atua considerando dois indivíduos pais, assumindo um ponto de corte em seus cromossomos e intercalando as partes, resultando novos indivíduos. AGs podem ter pontos de corte fixos ou aleatórios ao longo das gerações. Mutação: Durante cada geração, existe uma pequena chance de que um indivíduo dentro da população sofra uma mutação, que vai mudar a característica do indivíduo levemente. A mutação embute no AG uma característica totalmente aleatória. Conforme uma taxa especificada no algoritmo, alguns genes dentro dos cromossomos são escolhidos de forma randômica e alterados para outros valores permitidos pelo alfabeto do cromossomo.Uma variável relevante para o funcionamento do AG é o tamanho da população. O aumento dos indivíduos em uma população permitirá o alcance de um número maior de soluções possíveis, implicando assim na variabilidade de alternativas oferecidas pelo AG. Isso permitirá que as melhores soluções, que estejam próximas de uma solução ótima (se esta existir) sejam criadas. Portanto, o tamanho da população deve ser grande, levando-se em conta as restrições físicas (GOMEZ, 2005). O que limita o tamanho da população é o tempo que vai demorar o AG na sua execução, e a quantidade de memória para guardar a população.AG EM JAVABiblioteca Java API for Genetic Algorithms (JAGA)." }, { "title": "Anotações sobre Estruturas de Dados", "url": "/posts/estrutura-dados/", "categories": "Estudos-faculdade", "tags": "dados", "date": "2020-02-07 08:00:00 -0300", "snippet": "1 Estruturas de dados e análise de complexidadeDEFINIÇÃO: ESTRUTURA DE DADOSTodo o dado atômico é aquele no qual o conjunto de dados manipulados é indivisível, ou seja, você trata-os como sendo um único valor. Por sua vez, dados complexos são aqueles cujos elementos do conjunto de valores podem ser decompostos em partes mais simples. Se um dado pode ser dividido, isso significa que ele apresenta algum tipo de organização estruturada e, portanto, é chamado de dado estruturado, o qual faz parte de uma estrutura de dados.Estruturas de dados homogêneas são aquelas que manipulam um só tipo de dado. Você já deve ter tido contato com esse tipo de dado ao longo de seus estudos anteriores em programação. Vetores são estruturas homogêneas de dados. Um vetor será sempre unidimensional. Se desejarmos trabalhar com duas dimensões, trabalhamos com matrizes e, mais do que duas dimensões denominamos de tensores. Vetor é um tipo de estrutura de dados linear que necessita de somente um índice para indexação dos endereços dos elementos. O vetor contém um número fixo de células. Cada célula armazenará um único valor, sendo todos estes valores do mesmo tipo de dados. Quando declaramos uma estrutura de vetor, na memória do programa ele é inicializado (alocado) a partir da primeira posição (endereço da primeira célula). Cada outra célula, a partir da segunda, possui um endereço de referência relativoà primeira célula endereçada. Esse endereço é calculado considerando a posição da primeira célula, acrescido do tamanho em bytes de cada célula, tamanho que depende do tipo de dado armazenado no vetor.Chamamos isto de alocação sequencial.Uma matriz é uma estrutura de dados homogênea, linear, com alocação sequencial e bidimensional. Para cada uma das dimensões da matriz, é necessário utilizar um índice diferente. Também podemos afirmar que cada dimensão de uma matriz é na verdade um vetor. Em outras palavras, uma matriz é um vetor de vetor. Considerando nosso exemplo bidimensional, nossa matriz é composta, portanto, por dois vetores. Podemos generalizar a forma de cálculo de cada posição na memória de uma matriz pela Equação 2:𝐸𝑛𝑑𝑒𝑟𝑒ç𝑜𝑖,𝑗 = 𝐸𝑛𝑑𝑒𝑟𝑒ç𝑜0,0 + (Í𝑛𝑑𝑖𝑐𝑒𝑙𝑖𝑛ℎ𝑎 ∗ 𝐶 ∗ 𝑇𝑎𝑚𝑎𝑛ℎ𝑜𝐵𝑦𝑡𝑒𝑠)+ (í𝑛𝑑𝑖𝑐𝑒𝑐𝑜𝑙𝑢𝑛𝑎 ∗ 𝑇𝑎𝑚𝑎𝑛ℎ𝑜𝐵𝑦𝑡𝑒𝑠).Estruturas de dados heterogêneas, também conhecidas como registros (ou structs na linguagem de programação C).ANÁLISE DE COMPLEXIDADE DE ALGORITMOSAo analisarmos o desempenho de um algoritmo, existem dois parâmetros que precisam ser observados: Tempo de execução – quando tempo um código levou para ser executado; Uso de memória volátil – a quantidade de espaço ocupado na memória principal do computador; Acerca do tempo de execução, um fator bastante relevante nesse parâmetro é o tamanho do conjunto de dados de entrada.O custo em tempo de execução de um algoritmo é o tempo que ele demora para encerrar a sua execução. Podemos medir de forma empírica esse tempo de execução. As linguagens de programação, e até o próprio compilador, fornecem recursos e ferramentas capazes de mensurar esses tempos.Como forma de abstrair nossa análise do hardware e de softwares que são alheios ao nosso desenvolvimento, podemos encontrar matematicamente o custo de um algoritmo, encontrando uma equação que descreve o seu comportamento em relação ao desempenho do algoritmo. Encontrar esse custo é prever os recursos que o algoritmo utilizará. A função custo T(n) de um algoritmo qualquer pode ser dada como: 𝑇(𝑛) = 𝑇𝑡𝑒𝑚𝑝𝑜 + 𝑇𝑒𝑠𝑝𝑎ç𝑜.Para encontrarmos esse custo em tempo de execução, consideramos as seguintes restrições em nossas análises: Nossos códigos rodarão em um, e somente um, microprocessador por vez;· Não existirão operações concorrentes, somente sequenciais; Consideraremos que todas as instruções do programa contêm um custo unitário, fixo e constante.Uma instrução será uma operação ou manipulação simples realizada pelo programa, como: atribuição de valores, acesso a valores de variáveis, comparação de valores e operações aritméticas básicas.Perceba que o pior caso e o melhor caso resultam em duas funções de custo diferentes.ANÁLISE ASSINTÓTICA DE ALGORITMOSNesse tipo de análise, encontraremos uma curva de tendência aproximada do desempenho de um algoritmo. A análise baseia-se na extrapolação do conjunto de dados de entrada, fazendo-os tenderem ao infinito e permitindo que negligenciemos alguns termos de nossas equações. Em outras palavras, descartamos de nossas equações os termos que crescem lentamente à medida que nosso conjunto de dados de entrada tende ao infinito.Para obtermos o comportamento assintótico de qualquer função, mantemos somente o termo de maior grau (maior crescimento) da equação, negligenciando todos os outros, inclusive o coeficiente multiplicador do termo de maior grau.a. GRANDE-O (BIG-O): Define o comportamento assintótico superior; É o pior caso de um algoritmo; Mais instruções sendo executadas.b. GRANDE-ÔMEGA: Define o comportamento assintótico inferior; É o melhor caso do algoritmo (caso ótimo); Menos instruções sendo executadas.c. GRANDE-TETA: Define o comportamento assintótico firme; Caso médio de um algoritmo. É o comportamento considerando a grande maioria dos casos.Vamos trabalhar com o a notação Big-O, que é a notação mais empregada em análises de algoritmos e nos diz que um código nunca será pior do que a situação mostrada nesta notação, podendo, no entanto, ser melhor, dependendo do conjunto de dados de entrada.RECURSIVIDADEA recursão é o processo de definição de algo em termos de si mesmo. Um algoritmo recursivo é aquele que utiliza a si próprio para atingir algum objetivo, ou obter algum resultado. Em programação, a recursividade está presente quando uma função realiza chamadas a si mesma.Percebemos o interessante desempenho da função recursiva, porém, como o algoritmo recursivo está abrindo muitas instâncias de uma mesma função, e para cada nova instância temos suas variáveis locais sendo alocadas novamente, isso significa um aumento do uso de memória desse programa. Portanto, deve-se tomar cuidado com a possibilidade de estouro da pilha de memória em aplicações recursivas.2 Algoritmos de ordenação e buscaAlgoritmos de ordenaçãoCada dado pertencente a uma coleção de dados deve conter um número de registro (chave). Esta chave serve para identificar de forma única um dado dentro de toda a coleção. Todos os dados que estão vinculados a uma chave são chamados de dado satélite.Uma maneira de otimizarmos um algoritmo é, em vez de permutarmos toda a coleção de dados satélite de cada entrada de dados, vincular uma variável do tipo ponteiro a cada registro. Assim, permutamos e organizamos somente estes ponteiros, não precisando realocar todo o conjunto de dados satélite em memória, reduzindo o consumo de recursos, aumentando a eficiência o desempenho do processo.Um algoritmo de ordenação é um método que descreve como é possível colocar, em uma ordem específica, um conjunto de dados qualquer.Algoritmo de ordenação por troca (bubble sort)Apesar de ser o algoritmo de ordenação mais simples, e frequentemente o mais utilizado para o entendimento do processo de ordenação, este é um algoritmo computacionalmente muito caro e muito ineficiente. Notadamente porque emprega dois laços de repetição aninhados.Dentro do laço interno, existe um teste condicional que compara o valor de uma posição do vetor com o próximo valor, efetuando uma troca entre eles, caso necessário, utilizando uma variável auxiliar.Conforme vimos, o algoritmo proposto continua testando se os valores estão posicionados corretamente, mesmo quando o vetor já está ordenado. O que constitui desperdício de recursos computacionais.Podemos solucionar este problema e otimizar o desempenho de nosso código, bem como trocar nosso laço externo do tipo para por um laço enquanto(ou mesmo um repita). Neste laço de enquanto, continuaremos fazendo nossa contagem que vai até o tamanho do vetor, exatamente como antes, mas também acrescentamos outra condição, uma variável do tipo lógico com dois estados, inicializada com nível lógico baixo e que se mantém neste valor ao menos que exista uma troca. Portanto, enquanto houver trocas, seu valor será de nível alto. Quando o nível lógico volta a ser baixo, o laço encerrará precocemente, economizando nas iterações desnecessárias.A complexidade assintótica para o pior caso do método de ordenação por troca, tanto para a versão original quanto para a versão aprimorada será igual.Lembrando que um laço de repetição só tem impacto no desempenho assintótico do algoritmo caso estejam aninhados, ou seja, um inserido no outro. Percebemos a existência de dois laços de repetição aninhados. Portanto, temos para Big-O: 0𝐵𝑢𝑏𝑏𝑙𝑒𝑆𝑜𝑟𝑡(𝑛²).Analogamente, a versão aprimorada também tem dois laços aninhados, resultando na mesma complexidade para o pior caso. Se a complexidade é a mesma, por que então utilizamos a versão aprimorada? Porque para as situações em que o pior caso não ocorrerá, a nova versão se sairá melhor.Algoritmo de Ordenação por intercalação (merge sort)Este algoritmo de ordenação trabalha com a divisão da estrutura de dados em partes menores, empregando uma técnica chamada de dividir para conquistar. Para tal, empregam-se funções recursivas para a realização desta tarefa.O processo do merge sort consiste em dividir uma estrutura de dados de tamanho n (um vetor por exemplo) em n partes de tamanho unitário. Ou seja, o conjunto de dados inicial vai sendo dividido ao meio até que restem somente partes indivisíveis. Quando duas partes subsequentes atingirem tamanho um, elas realizam o processo chamado de intercalação. De forma simples, podemos entender a intercalação como a ordenação (crescente ou decrescente) seguida da agregação das partes para formarem um vetor maior.Para encontrarmos a complexidade assintótica para o pior caso do merge sort, precisamos, primeiro, analisar a complexidade individual de ambas funções propostas. Temos a função merge sendo chamada recursivamente. A complexidade assintótica para o pior caso de uma função recursiva será 𝑂(𝑙𝑜𝑔(𝑛)).A função merge também faz a chamada de outra função, a intercala. Esta função opera de forma iterativa. Não temos laços encadeados, portanto a complexidade para um único laço será 𝑂(𝑛).Como a função intercala está inserida na função merge, para encontrar a complexidade assintótica Big-Oh resultante, multiplicamos a complexidade de ambas funções. A complexidade para o pior do merge sort é superior em tempo de execução se comparado com o bubble sort. 0𝑀𝑒𝑟𝑔𝑒𝑆𝑜𝑟𝑡(𝑛. log(𝑛))Algoritmo de ordenação rápida (quick sort)O quick sort é bastante empregado em virtude de sua eficiência e facilidade de implementação. A ordenação rápida trabalha com o conceito de pivô, em que um elemento do conjunto de dados é selecionado para servir como referência de comparação para os outros valores.A ordenação ocorre quando o método divide a estrutura de dados em duas partes, semelhante ao merge sort, porém esta divisão não necessariamente ocorre no ponto central do vetor.Diferentemente do merge sort, o objetivo deste algoritmo não é quebrar o vetor no menor tamanho possível, mas sim dividi-lo para encontrar o elemento pivô. Para uma ordenação crescente, os elementos à esquerda do pivô devem sempre ser menores do que ele, e os à direita, maiores que o pivô. O algoritmo é aplicado de forma recursiva nas partes divididas até que a estrutura esteja ordenada.A complexidade final para o quick sort será 𝑂𝑄𝑢𝑖𝑐𝑘𝑆𝑜𝑟𝑡(𝑛2)Algoritmos de buscaAlgoritmos de busca servem para localizar um valor específico em um conjunto de dados. Assim como apresentado nos algoritmos de ordenação, a quantidade de algoritmos de busca disponível é diversa, e cada um destes algoritmos apresentará vantagens e desvantagens, além de desempenhos distintos e, consequentemente, aplicações diferentes.Busca sequencial A busca sequencial tem como fim introduzir o assunto de algoritmos de busca. A proposta do algoritmo de busca sequencial consiste em realizar uma busca em um conjunto de dados (ordenado ou não), empregando ao menos um laço de repetição que fará a varredura do conjunto de dados (lógica iterativa). Para cada iteração, temos uma comparação simples entre o elemento a ser localizado e cada elemento deste conjunto de dados. A complexidade assintótica para o tempo de execução da busca sequencial, com vetor ordenado ou não, será sempre 𝑂(𝑛).Busca binária A busca binária que trabalha com o conceito de dividir um conjunto de dados sempre ao meio e comparar o ponto central com o valor buscado é o conhecido processo de dividir para conquistar. Se este ponto central for menor ou maior que o valor buscado, a região de busca do vetor é limitada para o ramo esquerdo ou direto do conjunto de dados. Com esta proposta, a busca binária é capaz de atingir seu objetivo mais rapidamente e, ainda, trabalhar com recursividade, tornando o método mais eficiente se comparado ao sequencial. Uma característica importante é que a busca binária só funciona com conjuntos de dados já ordenados, caso contrário, a verificação feita com o ponto central não seria possível. Portanto, se o conjunto de dados não estiver ordenado, ele primeiro precisa ser ordenado para depois ser buscado. A busca binária apresenta como complexidade assintótica 𝑂(𝑙𝑜𝑔𝑛).3 Listas, pilhas e filasConceito de listas encadeadasNem todas as estruturas de dados são sequenciais. Existem estruturas de dados com alocação não sequencial. Em estruturas de dados com alocação não sequencial, cada dado (ou conjunto de dados) pode estar posicionado em qualquer parte da memória destinada a um programa em execução.Além dos dados úteis, cada elemento da lista ainda precisa manter pelo menos um endereço armazenado. Esse endereço corresponderá ao endereço do próximo elemento da lista. Dessa forma, cada elemento da lista sabe onde o próximo está e todos estão conectados (virtualmente) por meio desses endereços, ou ponteiros, armazenados.Para uma lista, o conceito de índice é inexistente. Em uma lista, cada elemento contém o endereço do próximo elemento. Portanto, somente o elemento atual conhece o subsequente. Assim, a única forma de acessarmos, por exemplo, o terceiro elemento dessa lista seria iniciarmos no primeiro elemento e, por meio do acesso aos endereços para os próximos elementos, passarmos de um elemento para o seguinte até atingirmos o elemento desejado. Esse tipo de lista é chamado de encadeado por esse motivo, já que os elementos estão encadeados por meio do endereço do elemento seguinte.Uma das grandes vantagens do uso de listas encadeadas está na possibilidade de alocação dinâmica de memória e no dinamismo de manipulação dos dados dessa lista, o que torna fáceis a inserção e a remoção de novos elementos.Dentre as desvantagens das listas está o desempenho para acesso aos dados.As listas podem ser homogêneas ou heterogêneas e armazenar qualquer tipo de dado.Lista simplesmente encadeada (linked list)Cada elemento dela aponta e conhece somente o próximo elemento da lista. Para tal, cada nó necessita ter um único ponteiro, com o endereço do próximo elemento. Em programação, podemos representar cada elemento da lista encadeada como sendo um registro. Esse registro conterá todos os dados que se deseja armazenar, sejam quais forem seus tipos, e também um ponteiro. Esse ponteiro conterá o endereço para o próximo elemento da lista. O tipo desse ponteiro deverá ser igual ao do registro criado.A lista encadeada simples pode ser classificada em dois tipos: as não circulares e as circulares.O primeiro elemento da lista é chamado de início ou de head (cabeça) da lista. Esse primeiro elemento é o único que sempre será conhecido pelo programa que está manipulando uma determinada lista. Todos os outros dados da lista são descobertos à medida que os elementos da lista vão sendo acessados.Em uma lista simples não circular, o último elemento não apontará para nada (ponteiro nulo). De uma forma diferente, a lista simples circular difere da não circular somente pelo ponteiro do último nó. Esse ponteiro, ao invés de apontar para o nulo, irá apontar para o primeiro elemento da lista, fechando um círculo.Inserindo um novo elemento no início da lista encadeada simples não circularPasso 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na lista. Nesse momento, ele ainda está fora da lista.Passo 2: fazer o ponteiro do novo elemento apontar para o head.Passo 3: transformar o novo elemento no novo head da lista.Inserindo um novo elemento no fim da lista encadeada simples não circularPasso 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na lista. Nesse momento ele ainda está fora da lista.Passo 2: realizar uma varredura, usando um laço de repetição e começando no head, até localizar um elemento que aponte para o nulo. Esse elemento será o último e a inserção do novo elemento ocorrerá após ele.Passo 3: fazer esse último elemento apontar para o nosso novo valor. O novo valor, como será então o último, irá apontar para o nulo.Inserindo um novo elemento no meio da lista encadeada simples não circularPasso 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na lista. Nesse momento, ele ainda está fora da lista.Passo 2: realizar uma varredura, usando um laço de repetição e começando no head até localizar a posição desejada.Passo 3: fazer o elemento da posição anterior apontar para o novo elemento e fazer o novo elemento apontar o antigo da posição desejada.Lista duplamente encadeada (doubly linked list)Uma lista duplamente encadeada é assim chamada pois cada elemento dela aponta e conhece o próximo elemento da lista, bem como o elemento imediatamente anterior a ele na lista. Para tal, cada nó necessita ter dois ponteiros (anterior e próximo).Em programação, podemos representar cada elemento da lista encadeada como sendo um registro. Esse registro conterá todos os dados que se deseja armazenar, sejam quais forem seus tipos, e também os dois ponteiros. Um ponteiro conterá o endereço para o próximo elemento da lista e o outro, o endereço para retornar ao elemento anterior. O tipo desse ponteiro deverá ser igual ao do registro criado.A lista encadeada dupla pode ser classificada em dois tipos: as não circulares e as circulares. Em uma lista dupla não circular, o último elemento apontará para o nulo. De uma forma diferente, a lista dupla circular difere da não circular somente pelo ponteiro próximo do último nó. Esse ponteiro, ao invés de apontar para o nulo, irá apontar de volta para o primeiro elemento da lista, fechando um círculo novamente.Inserindo um novo elemento no início da lista encadeada duplaPasso 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na lista. Nesse momento, ele ainda está fora da lista.Passo 2: fazer o ponteiro próximo do novo elemento apontar para o head. Fazer o ponteiro anterior ao novo elemento apontar para o nulo. Fazer o ponteiro anterior ao head apontar para o novo elemento.Passo 3: transformar o novo elemento no novo head da lista.Inserindo um novo elemento no fim da lista encadeada duplaPasso 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na lista. Nesse momento, ele ainda está fora da lista.Passo 2: realizar uma varredura na lista existente, iniciando no head, até localizar o elemento com ponteiro próximo nulo (último elemento).Passo 3: fazer o elemento encontrado, com ponteiro próximo nulo, apontar para o novo elemento. Fazer o ponteiro anterior ao novo elemento apontar para o último elemento. Fazer o ponteiro próximo do novo elemento apontar para o nulo.Inserindo um novo elemento no meio da lista encadeada duplaPasso 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na lista. Nesse momento, ele ainda está fora da lista.Passo 2: executar uma varredura na lista existente, iniciando no head, até localizar a posição desejada (posição 2).Passo 3: utilizando uma variável de lista auxiliar, fazer a inserção do elemento no meio. O elemento da posição 1 irá apontar para o novo elemento, com seu ponteiro próximo. O antigo elemento da posição 2 apontará, com seu anterior, também para o novo elemento. O novo elemento irá apontar, com seu ponteiro anterior, para o 9 e, com seu ponteiro próximo, para o 5.Pilha (stack)Uma pilha se comporta seguindo a regra chamada: o primeiro que entra é o último que sai. Em inglês, essa regra é chamada de first in last out (Filo).Em programação, podemos criar uma estrutura de dados que também funciona com esse princípio que acaba de ser explicado. Essa estrutura pode ser construída tanto com vetores quanto com listas encadeadas. Ambas funcionarão da mesma maneira detalhada anteriormente. As diferenças estarão nas características da estrutura de dados, características essas intrínsecas a elas. Vetores funcionarão com alocação sequencial da memória e tempo de acesso aos dados constante. Listas funcionarão com alocação dinâmica e tempo de acesso às informações 𝑂(𝑛).Dentre algumas aplicações comuns de pilhas está a própria técnica de programação chamada recursividade, já bastante desenvolvida nas aulas anteriores. Cada instância de uma função recursiva aberta é tratada como um novo elemento inserido na pilha. Esse novo elemento precisa ser resolvido para então desempilharmos os demais elementos e assim termos acesso ao elemento (outra função) que está abaixo, na pilha.Top, único elemento sempre conhecido globalmente pelo programa.Inserindo um novo elemento na pilha (empilhando/push)Passo 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na pilha. Nesse momento, ele ainda está fora da pilha.Passo 2: fazer o ponteiro do novo elemento apontar para o top.Passo 3: transformar o novo elemento no novo top da lista.Removendo um elemento da pilha (desempilhando/pop)Passo 1: localizar o topo da pilha.Passo 2: transformar o elemento subsequente ao topo no novo topo.Passo 3: liberar da memória o topo antigo, para que ele não ocupe espaço desnecessário na memória do programa.Fila (Queue)Uma fila se comporta seguindo a regra chamada: o primeiro que entra é o primeiro que sai. Em inglês, essa regra é chamada de first in first out (Fifo).Em programação, podemos criar uma estrutura de dados que também funciona com esse princípio que acaba de ser explicado. Essa estrutura pode ser construída tanto com vetores quanto com listas encadeadas.Dentre algumas aplicações comuns de filas na área de tecnologia, podemos citar o processo de fila de impressão, em uma rede. Cada arquivo que é colocado para imprimir, em uma mesma impressora, é inserido no final da fila. E o que está na frente da fila é removido (impresso) primeiro.Inserindo um elemento na fila (queuing)Passo 1: alocar o novo elemento na memória. Perceba que alocá-lo na memória ainda não significa inseri-lo na pilha. Nesse momento, ele ainda está fora da fila.Passo 2: varrer a fila até encontrar o ponteiro nulo (último elemento).Passo 3: fazer o ponteiro nulo do último elemento apontar para o novo elemento.Removendo da fila (dequeuing)Passo 1: localizar o head da fila.Passo 2: transformar o elemento subsequente ao head no novo head.Passo 3: liberar da memória o head antigo, para que ele não ocupe espaço desnecessário na memória do programa4 ÁrvoresÁrvore bináriaA árvore binária é uma estrutura de dados não linear organizada com elementos que não estão, necessariamente, encadeados, formando ramificações e subdivisões na organização da estrutura de dados. A árvore binária apresenta algumas características distintas, mesmo se comparada a outros tipos de árvores. Analisaremos algumas dessas características e conceituaremos alguns termos próprios referentes a árvores:· Nó raiz (root):1 nó original da árvore. Todos derivam dele;· Nó pai: nó que dá origem (está acima) a pelo menos um outro nó;· Nó filho: nó que deriva de um nó pai;· Nó folha/terminal: nó que não contém filhos.O que caracteriza uma árvore como binária é o número de ramificações de cada nó. Na árvore binária, cada nó apresenta nenhum, um ou no máximo dois nós chamados de nós filhos.Uma árvore binária apresenta como característica a inserção de valores de forma organizada. Um modo de inserção de valores é posicionar à esquerda de um nó pai, na árvore, somente valores menores do que ele. E os valores à direita devem ser maiores que o nó pai. Desse modo, valores menores sãosempre posicionados mais à esquerda da árvore e os maiores mais à direita. Esse tipo de inserção é também conhecido como Binary Search Tree (BST, árvore de busca binária).O objetivo de inserção na árvore é justamente facilitar a busca de dados posteriormente. Como os dados estarão colocados na árvore de uma forma organizada, saberemos que, ao percorrer as ramificações de uma árvore binária, localizaremos o valor desejado mais rapidamente pelas subdivisões.O grau de um nó na estrutura de dados em árvore corresponde ao número de subárvores que aquele nó terá. Em uma árvore binária, o grau máximo de cada nó será dois.Em uma árvore, conceituamos o nó raiz como sendo o nível zero da árvore. Todo novo conjunto de ramificações da árvore caracteriza mais um nível nessa árvore. Conhecendo os níveis, a altura de uma árvore será calculada ao tomarmos o maior nível dela e subtrairmos do primeiro nível (nível 0). É também possível encontrarmos a altura relativa entre dois níveis da árvore. Para isso, basta subtrairmos os valores desses níveis.Em programação, representamos cada elemento da árvore como sendo um registro que contém todos os dados que desejamos armazenar, além de dois ponteiros. Esses ponteiros conterão os endereços para os próximos elementos da árvore, ou seja, para os nós filhos daquele elemento.Sempre que um nó for folha, significa que ele está no nível mais alto da árvore e que, portanto, não terá filhos. Sendo assim, ambos os ponteiros serão nulos. Caso o nó não seja folha, ele sempre terá ao menos um ponteiro de endereço não nulo.Raiz (root), único elemento sempre conhecido globalmente pelo programa.Inserção de dadosEm uma árvore binária montada para funcionar como uma Binary Seach Tree (BST) não existem inserções no início, no meio nem no final da árvore como ocorre nas listas encadeadas. A inserção sempre é feita após um dos nós folha da árvore, seguindo a regra anteriormente explanada:• · Dados de valores menores cujos antecessores são inseridos no ramo esquerdo da árvore;• · Dados de valores maiores cujos antecessores são inseridos no ramo direito da árvore.Todo novo nó inserido vira um nó folha, porque ele é sempre inserido nos níveis mais altos da árvore. Todos os nós folha podem ser facilmente identificados em uma árvore como aqueles nós cujos ponteiros (esquerdo e direito) são nulos.Passo 1: Alocar o elemento na memória (fora da árvore);Passo 2: Encontrar a posição deste elemento na árvore;Passo 3: Fazer o ponteiro do nó-pai apontar para o novo elemento.Busca de dadosPasso 1: iniciando na raiz, testamos se ela é igual, maior ou menor que o valor 2. Caso fosse igual, nossa busca já poderia ser encerrada. Porém, o valor 8 é maior que 2. Isso significa que, caso o 2 exista nessa árvore, ele estará à esquerda do 8, e, portanto, devemos seguir pelo ramo esquerdo (ponteiro esquerdo);Passo 2: estamos no nível 1 da árvore e comparando o valor 2 com o valor 6. Novamente, verificamos se esse valor é maior, menor ou igual 2. O valor é maior do que 2. Portanto, novamente, caso o 2 exista nessa árvore, ele estará à esquerda de 6, e devemos seguir para a esquerda no próximo nível;Passo 3: estamos no nível 2 da árvore e comparamos o valor com o 2. Nesse caso, o valor é exatamente 2, e, portanto, podemos encerrar nossa busca na árvore binária.A busca binária delimita a região de busca sempre pela metade a cada nova tentativa, tornando possível localizar, para o pior caso assintótico, o dado em um tempo de execução O(logn).Uma árvore binária também apresenta para BigO a mesma complexidade O(logn), também delimitando a região de busca sempre pela metade a cada novo nível da árvore. Sendo assim, a árvore binária faz para as buscas em estruturas de dados dinâmicas o equivalente ao que a busca binária faz para conjuntos de dados sequenciais.Visualização de dadosUma árvore binária, depois de construída, pode ser listada/consultada e apresentada em uma interface. Porém, como a árvore não apresenta sequência/ordem fixas, podemos listar seus dados de algumas formas distintas. As consultas podem ser feitas:Em ordem: listamos os elementos iniciando pelos elementos da esquerda; depois, a raiz; e, por último, os elementos da direita. Dessa forma, os elementos listados são apresentados ordenados e de forma crescente;Em pré-ordem: listamos os elementos iniciando pela raiz, depois listamos os elementos da esquerda, e, por fim, os elementos da direita;Em pós-ordem: listamos os elementos iniciando pelos elementos da esquerda; depois, os da direita; e, por último, a raiz.Árvore de Adelson-Velsky e Landis (Árvore AVL)Uma árvore de Adelson-Velsky e Landis, também conhecida como árvore AVL, é uma árvore binária balanceada. Em uma árvore binária convencional, na medida em que temos muitas inserções de dados, podemos começar a ter algumas ramificações que se estendem muito em altura, gerando piora no desempenho do algoritmo.Ramificações muito altas acabam dificultando o sistema de busca em uma árvore, piorando o desempenho do algoritmo em termos de tempo de execução. A árvore AVL tem como objetivo melhorar esse desempenho balanceando uma árvore binária, evitando ramos longos e gerando o maior número de ramificações binárias possíveis.Sendo assim, a árvore AVL contém todas as características já apresentadas de uma árvore binária. A única característica adicional é que a diferença de altura entre uma subárvore direita e uma subárvore esquerda sempre deverá ser 1, 0 ou –1. Caso essa diferença resulte em outro valor, como 2 ou –2, a árvore deverá ser imediatamente balanceada (seus elementos deverão ser rearranjados) por meio de um algoritmo de balanceamento.· Passo 1: calculamos a altura relativa daquele elemento para o lado direito da árvore. Nesse caso, pegamos o nível mais alto do lado direito daquele elemento e subtraímos do nível do elemento desejado;· Passo 2: calculamos a altura relativa daquele elemento para o lado esquerdo da árvore. Nesse caso, pegamos o nível mais alto do lado esquerdo daquele elemento e subtraímos do nível do elemento desejado;· Passo 3: tendo as alturas direita e esquerda calculadas, fazemos a diferença entre elas (direta menos esquerda, sempre). Se o cálculo resultar em 2 ou –2, existe um desbalanceamento e uma rotação será necessária.Rotacionando a árvore binária Diferença de altura de um nó Diferença de altura entre o nó filho e o nó desbalanceado Tipo de rotação 2 1 Simples à esquerda 2 0 Simples à esquerda 2 -1 Dupla com filho para a direita e pai para a esquerda -2 1 Dupla com filho para a esquerda e pai para a direita -2 0 Simples à direita -2 -1 Simples à direita 5 GrafosEstrutura de dados que tem a sua construção sem um padrão definido e totalmente aleatória.Um grafo G é um conjunto de vértices conectados por meio de arestas sem uma distribuição fixa ou padronizada.Os vértices V de um grafo são seus pontos. Cada ponto pode ser um ponto de encontro entre caminhos (rotas) de um grafo, ou, então, o vértice pode conter informações relevantes para o grafo, como dados de informações de cadastros. Tudo depende da aplicação.As arestas E são as linhas de conexão entre os vértices. Cada aresta conecta dois vértices. Nem todo vértice precisa ter uma aresta conectada; ele pode permanecer isolado, caso o grafo assim seja construído.Chamamos de grafo completo quando existe uma, e somente uma aresta para cada par distinto de vértices; chamamos de grafo trivial aquele que apresenta um único vértice.Assim como tínhamos o grau de cada nó de uma árvore, em grafos também podemos encontrar o grau de cada nó de um vértice. O grau de um vértice nada mais é do que a soma de todas as arestas que incidem sobre ele.Dentre as particularidades da construção de grafos, podemos citar as arestas múltiplas. Arestas múltiplas são aquelas que estão conectadas aos mesmos vértices.Um laço acontece quando uma aresta contém somente um vértice ao qual se conectar, iniciando e terminando nele.Por fim, vemos um grafo desconexo. Nesse tipo de grafo, temos pelo menos um vértice sem nenhuma arestaPara finalizar a abordagem da teoria, precisamos entender que podemos atribuir pesos a nossas arestas. O peso da aresta representa um custo atrelado àquele caminho. Quando não indicamos nenhum peso nas arestas, assumimos que elas têm todas o mesmo valor. Quando damos um número para cada aresta, indicamos os valores no próprio desenho do grafo. Chamamos um grafo com pesos em arestas de grafo ponderado.Representação de grafosPodemos representar os grafos matematicamente ou graficamente. As representações matemáticas acabam por ser ideais para a implementação em um algoritmo, por exemplo, já que podem ser manipuladas da forma que o desenvolvedor necessitar.Matriz de incidênciasA representação de um grafo por uma matriz de incidências consiste em criar uma matriz de dimensão VxE, em que V é o número de vértices do grafo e E, o número de arestas.Ao analisar o grafo desenhado, devemos observar cada uma de suas arestas (colunas da matriz). Elas devem ser preenchidas segundo as possibilidades a seguir:0, caso o vértice (linha da matriz) não faça parta da ligação;1, caso o vértice (linha da matriz) faça parta da ligação;2, caso aquela aresta seja do tipo laço.Matriz de adjacênciasA representação de um grafo por uma matriz de adjacências consiste em criar uma matriz quadrada de dimensão V, em que V é o número de vértices do grafo.Assim como na representação anterior, povoamos nossa matriz com valores 0, 1 ou 2. A análise que fazemos para preenchimento da matriz é efetuada de uma forma diferente agora. Observamos cada uma das linhas dos vértices, e preenchemos na matriz:0, caso o outro vértice não tenha conexão com o vértice analisado;1, caso o outro vértice tenha conexão com o vértice analisado;2, caso o outro vértice tenha conexão com o vértice analisado e seja um laço.Lista de adjacênciasA representação de um grafo por uma lista de adjacências é muito adotada na área de programação, pois trabalha com listas encadeadas e manipulação de ponteiros de dados.A proposta dessa representação é criar um vetor (ou uma lista encadeada) do tamanho da quantidade de vértices existentes no grafo. Em cada posição desse vetor, teremos uma lista encadeada contendo os endereços dos vizinhos de cada vértice. Conceitualmente, vizinhos de um vértice são todos os vértices que se conectam diretamente a ele por meio de uma aresta.Assim, teremos uma lista encadeada de vizinhos para cada posição do vetor de vértices criado. Na lista, cada vizinho apontará para outro vizinho daquele mesmo nó.Podemos criar essa estrutura de duas formas distintas. Na primeira, declaramos um vetor de dimensão igual ao número de vértices de nosso grafo. Esse vetor será do tipo ponteiros de registros. Assim, cada posição do vetor poderá conter uma estrutura do tipo lista encadeada, armazenando o primeiro elemento dessa lista (head).De forma alternativa, também podemos substituir o vetor por uma estrutura do tipo lista. Assim, teremos duas listas encadeadas, uma chamada de vertical, contendo os vértices e os endereços para os primeiros vizinhos, e uma lista horizontal, contendo as listas de vizinhos de cada vértice.Algoritmo de busca em profundidade no grafoO algoritmo de busca em profundidade, também conhecido como Depth-First Search (DFS), apresenta uma lógica intuitiva e funcional para resolver esse problema de descoberta do grafo.A proposta desse algoritmo é partir de um vértice de origem e acessar a lista de adjacências desse vértice, ou seja, seus vizinhos. O primeiro vizinho detectado (mais adiante na lista encadeada do vértice de origem), será imediatamente acessado.Assim, cada novo elemento ainda não descoberto é selecionado a partir das listas encadeadas de cada vértice, até que o último seja encontrado. Os elementos descobertos vão sendo empilhados e desempilhados segundo as regras de uma estrutura do tipo pilha. Ou seja, só podemos voltar ao vizinho de um nó mais abaixo na pilha se resolvermos primeiro o elemento mais acima, no topo da pilha.Algoritmo de busca em largura no grafoO algoritmo de busca em largura, também conhecido como Breadth-First Search (BFS), trabalha com a ideia de visitar primeiro todos os vizinhos próximos do vértice selecionado antes de pular para o próximo vértice.Uma diferença interessante em relação à busca por profundidade é que a BFS trabalha com uma estrutura do tipo fila para indicar qual é o próximo vértice a ser acessado, enquanto na Depth-first Search (DFS) tínhamos uma estrutura de pilha.Perceba que temos também um vetor de distâncias. Esse vetor manterá armazenada a distância de cada vértice em relação ao vértice de origem, ajudando na decisão de qual será o próximo vértice a ser visitado.Algoritmo do caminho mínimo em grafo: DijkstraEsse algoritmo é o mais tradicional para realizar a tarefa de encontrar um caminho. Para realizar tal procedimento, podemos utilizar um grafo ponderado, ou seja, aquele com pesos distintos nas arestas.Todo esse algoritmo será apresentado utilizando uma métrica aditiva. Isso significa que essa métrica encontrará a menor rota considerando o menor peso somado entre os caminhos.Existem outros tipos de métricas. Na multiplicativa, por exemplo, o melhor caminho é encontrado calculando-se o produto dos pesos das arestas. O maior valor dentre os produtos é a melhor rota. Um exemplo dessa métrica é o limite de velocidade das estradas: quanto maior o limite, mais rápido o veículo anda, e, portanto, melhor é aquela rota/aresta.Como trabalharemos com um grafo ponderado, precisamos adaptar nossa lista de adjacências para que o registro também armazene os pesos das arestas.O algoritmo do caminho mínimo precisa calcular as menores rotas de um vértice para todos os outros. Portanto, um vetor com distâncias fica armazenado. Nesse vetor, todas as rotas iniciam com um valor infinito, ou seja, como se o caminho de um vértice até o outro não fosse conhecido. À medida que os trajetos vão sendo calculados, os pesos das rotas são alterados.6 HashsO objetivo da hash é construir uma estrutura de dados capaz de obter tempo de acesso constante às informações contidas nela, independentemente do tamanho do conjunto de dados.O vetor contendo os valores-chave é denominado de tabela hashing. Para cada palavra-chave, podemos ter a quantidade que necessitarmos de dados cadastrados referentes aquela chave, dados estes chamados de dados satélites.Tabelas hashing armazenam palavras-chave que servem para acessar dados satélite. Essas palavras-chave são armazenadas em posições de um vetor calculadas com base em funções hashing.Funções HashUm exemplo de função hash pode ser aquele que leva em consideração o resto de uma divisão para definir a posição na estrutura de dados. Porém uma função hash não apresenta uma fórmula definida, e deve ser projetada levando-se em consideração o tamanho do conjunto de dados, seu comportamento e os tipos de dados-chave utilizados.As funções hash são o cerne na construção das tabelas hashing, e o desenvolvimento de uma boa função de hash é essencial para que o armazenamento dos dados, a busca e o tratamento de colisões (assunto abordado no próximo tema) ocorram de forma mais eficiente possível. Uma boa função hash, em suma, deve ser:Fácil de ser calculada. De nada valeria termos uma função com cálculos tão complexos e lentos que todo o tempo que seria ganho no acesso a informação com complexidade 𝑂(1), seria perdido calculando uma custosa função de hash;Capaz de distribuir palavras-chave o mais uniforme possível;Capaz de minimizar colisões. Os dados devem ser inseridos de uma forma que as colisões sejam as mínimas possíveis, reduzindo o tempo gasto resolvendo colisões e também reavendo os dados;Capaz de resolver qualquer colisão que ocorrer;O método da divisãoUm tipo de função hash muito adotada é o método da divisão, em que dividimos dois valores inteiros e usamos o resto dessa divisão como a posição desejada.Quando nossas palavras-chave são valores inteiros, dividimos o número pelo tamanho do vetor e usamos o resto dessa divisão como a posição a ser manipulada na tabela hashing. Caso uma palavra-chave adotada seja um conjunto grande de valores inteiros (como um número telefônico ou CPF por exemplo), poderíamos somar esses valores agrupados (em pares ou trios) e também dividir pelo tamanho do vetor, obtendo o resto da divisão.De modo geral, quando precisamos mapear um número de chaves em m espaços (como os de um vetor) pegando o resto da divisão entre ambos, chamamos isso de método da divisão. Esse método é bastante rápido, uma vez que requer unicamente uma divisão. ℎ(𝑘) = 𝑘 𝑀𝑂𝐷 𝑚Existem alguns valores de m que devem ser minuciosamente escolhidos para não gerar povoamentos de tabelas hash ruins. Por exemplo, utilizar 2 ou múltiplos de 2 para o valor de m tende a não ser uma escolha. Isso porque o resto da divisão por dois, ou qualquer múltiplo seu, sempre resultará em um dos bits menos significativos, gerando um número bastante elevado de colisões de chaves.Em hash precisamos trabalhar com números naturais para definir as posições na tabela, uma vez que linguagens de programação indexam as estruturas de dados (como vetores e matrizes) usando esse tipo de dado numérico. Desse modo, precisamos que nossas chaves sejam também valores naturais. Caso não sejam, precisamos encontrar uma forma de transformá-las para que sejam.Para chaves com caracteres alfanuméricos, podemos adotar a mesma Equação, fazendo pequenas adaptações. Convertemos os caracteres para números decimais seguindo uma codificação (tabela ASCII, por exemplo), somamos os valores, dividimos pelo tamanho do vetor e obtemos o resto da divisão como posição de inserção da palavra-chave na tabela hashing.Adotar números primos, especialmente aqueles não muito próximos aos valores de potência de 2, tende a ser uma boa escolha para o tamanho do vetor com palavras-chaves alfanuméricas.Por fim, quando trabalhamos com valores-chave sendo conjuntos de caracteres, devemos tomar cuidado com palavras que contenham as mesmas letras, mas em ordens diferentes (anagrama). Por exemplo, uma palavra-chave com quatro caracteres chamada ROMA poderá gerar o mesmo resultado que uma palavra-chave chamada AMOR, pois os caracteres são os mesmos rearranjados de outra maneira. Uma função de hash deve ser cuidadosamente definida para tratar este tipo de problema caso ele venha a ser recorrente; caso contrário, teremos excessivas colisões.O método da multiplicaçãoEsse método de construção de funções hash funciona da maneira que, primeiro, multiplicamos a chave k por uma constante A. Essa constante deve estar em um intervalo 0 &lt; 𝐴 &lt; 1 e extrair a fração de kA. Em seguida, multiplicamos esse valor por m e arredondamos o resultado para baixo. ℎ(𝑘) = ⌊𝑚(𝑘 𝐴 𝑀𝑂𝐷 1)⌋Esse método apresenta como desvantagem o fato de ser mais lento para execução em relação ao método da divisão, pois temos mais cálculos envolvidos no processo, porém tem a vantagem de que o valor de m não é crítico, não importando o valor escolhido.Em contraponto ao método de divisão, normalmente adotamos um múltiplo de 2 para seu valor, devido à facilidade de implementação. A constante A, embora possa ser qualquer valor dentro do intervalo 0&lt;A&lt; 1, é melhor com alguns determinados valores. Segundo Knuth (1998), um ótimo valor para essa constante é A=(√5−1)/2≅0,618.Hashing universalConsiderando que uma chave k qualquer tem a igual probabilidade de ser inserida em qualquer uma das posições de um vetor, em um pior cenário seria possível que um conjunto de chaves a serem inseridas caiam sempre na mesma posição do vetor, caso utilizem a mesma função hash h(k). Portanto a complexidade para a inserção nessa hash será 𝑂(𝑛). Podemos evitar esse tipo de problema escolhendo uma função hashing aleatoriamente dentro de um universo H de funções. A esta solução chamamos de hashing universal.Na hashing universal, no início da execução de um algoritmo de inserção, sorteamos aleatoriamente uma função de hash dentro de uma classe de funções cuidadosamente desenvolvida para a aplicação desejada. A aleatoriedade evita que qualquer entrada de dado resulte no pior caso. É bem verdade que a aleatoriedade poderá nunca resultar em um caso perfeito, em que nenhuma colisão ocorre, mas teremos sempre uma boa situação média.Existe outro método bastante conhecido de implementação de hash universal que emprega matrizes aleatórias.Tabela Hashing de endereçamento aberto e tentativa linearA tabela hash pode ser implementada de diferentes formas. A implementação impacta diretamente em como os dados são inseridos e no tratamento das colisões de hashs.Podemos desenvolver uma tabela hashing por meio de uma implementação utilizando endereçamento aberto. Nesse tipo de implementação, a tabela é um vetor de dimensão m e todas suas chaves são armazenadas no próprio vetor. O endereçamento aberto é bastante empregado quando o número de hashs a serem armazenadas é pequeno se comparado com o tamanho do vetor.É possível implementá-la utilizando uma estrutura heterogênea do tipo registro, em que temos como campos um valor para ser usado como palavra-chave, podendo ser um inteiro ou alfanumérico, por exemplo. E temos também um campo que mantém o status daquela posição, representando se ele está livre, ocupado por uma chave ou se a chave daquela posição já foi removida.Colisões: quando uma palavra-chave deve ser posicionada em um espaço do vetor em que já está ocupado.Na tentativa linear, sempre que uma colisão ocorre, tenta-se posicionar a nova chave no próximo espaço imediatamente livre do vetor.Caso o algoritmo de tentativa linear fique buscando uma posição vazia indefinidamente até chegar ao final do vetor e não a encontre, ele retorna ao início e busca até voltar à posição inicialmente testada. Caso nenhum local livre seja localizado, a palavra-chave não pode ser inserida.Para a tentativa linear, todas as funções de manipulação da tabela de hash (inserção, remoção e busca de um elemento) apresentam risco de colisão para cada tentativa de manipulação.Embora essas funções apresentem no melhor caso complexidade constante, não podemos garantir que elas terão sempre esse tempo, uma vez que o risco de colisão é sempre iminente, independentemente da operação.Além disso, a tratativa linear funciona com agrupamentos primários de dados, ou seja, podem ocorrer longos trechos de endereços ocupados em sequência. Como a tentativa linear testa um elemento por vez, sequencialmente, a complexidade para o pior caso sempre será 𝑂(𝑛) para todas as funções apresentadas (inserção, busca e remoção).Tabela Hashing de endereçamento aberto e tentativa quadráticaNa tentativa quadrática, sempre que uma colisão ocorre, tenta-se posicionar a nova chave no próximo espaço que está d posições de distância do primeiro testado, em que 1 ≤ 𝑑 ≤ 𝑇𝐴𝑀𝐴𝑁𝐻𝑂_𝑉𝐸𝑇𝑂𝑅.A análise para o pior case da tentativa quadrática não difere da tentativa linear. A inserção, busca e remoção apresenta complexidade BigO 𝑂(𝑛). Este método acaba por ser mais eficiente em tempo de execução somente para situações de casos médios.Tabela Hashing com endereçamento em cadeiaPodemos implementar uma tabela hashing empregando conceitos de listas encadeadas. Nesse cenário, temos também um vetor de dimensão m para representar a tabela, porém cada posição do vetor armazenará um endereço para o início de uma lista encadeada, de forma semelhante ao que trabalhamos na construção de uma lista de adjacências em grafos.A forma como as colisões são tratadas por esse tipo de endereçamento é diferente. Nele, não é necessário encontrarmos uma nova posição no vetor para alocarmos o elemento colidido. Basta inseri-lo na mesma posição calculada, mas como mais um elemento da lista encadeada simples. A inserção é dada sempre antes do Head.Note que, sempre que necessário buscar uma chave desse vetor, basta recalcular a posição usando a função hashing e, em seguida, varrer a lista encadeada simples daquela posição até localizar a palavra-chave correspondente.A complexidade para o endereçamento de cadeia apresenta tempo constante para o pior caso 𝑂(1) para a inserção na tabela. Esse valor é constante, pois a inserção consiste somente em calcular a função hashing e inserir no Head da lista da posição correspondente, sem a necessidade de varredura da lista nem de tratamento de colisões.Para a remoção da lista, o pior cenário seria a necessidade de varrer uma lista encadeada de uma posição buscando um elemento que está na última posição dessa lista simplesmente encadeada. Portanto, a complexidade está atrelada ao número de palavras-chave (números de elementos) de cada lista encadeada, resultando em 𝑂(𝑛)." }, { "title": "Anotações sobre Fundamentos de Sistemas de Informação", "url": "/posts/fundamentos-sistemas-informacao/", "categories": "Estudos-faculdade", "tags": "gestão", "date": "2020-01-31 08:00:00 -0300", "snippet": "Baseado no livro: LAUDON, K. C.; LAUDON, J. P. Sistemas de Informação Gerenciais. 11ª edição. São Paulo: Pearson Education do Brasil, 2014.Parte I - Sistemas de informação na era digitalCapítulo 1 - Os sistemas de informação empresariais na sua carreiraTrês mudanças na área de tecnologia: a plataforma digital móvel, o uso crescente de “big data” nos negócios e o crescimento da computação em nuvem.Objetivos organizacionais dos sistemas de informação: excelência operacional; novos produtos, serviços e modelos de negócio; relacionamento mais estreito com clientes e fornecedores; melhor tomada de decisões; vantagem competitiva; sobrevivência.Tecnologia de informação (TI): todo o hardware e software de que uma empresa necessita para atingir seus objetivos organizacionais.Sistema de informação (SI): conjunto de componentes inter-relacionados que coletam (ou recuperam), processam, armazenam e distribuem informações destinadas a apoiar a tomada de decisões, a coordenação e o controle em uma organização. Além disso também auxiliam os gerentes e trabalhadores a analisar problemas, visualizar assuntos complexos e criar novos produtos.Dados - Entrada - processamento - saída - feedback - informaçãoAmbiente: organizações, tecnologia e pessoas.Abordagem de resolução de problemas.graph LR A[Identificação do problema] --&gt;B[Propostas de solução] B --&gt; C[Avaliação das propostas e escolha de solução] C --&gt;D[Implementação] D --&gt;|Feedback| A &amp; B &amp; CResolução de problemas: um processo, não um evento.Capítulo 2 - E-business global e colaboraçãograph TD A[Sistemas de informação] --&gt;B[Soluções de negócios] B --&gt; C[Desafios Organizacionais] C --&gt;D[Pessoas] D --&gt;A E[Organização] --&gt;A F[Tecnologia] --&gt;AUma empresa é uma organização formal cujo objetivo é produzir produtos ou prestar serviços a fim de gerar lucro.graph LR A[Manufatura e produção] --&gt; E((Produto ou serviço)) B[Vendas e marketing] --&gt;E C[Recursos humanos] --&gt;E D[Finanças e contabilidade] --&gt;EAs quatro funções básicas de uma empresaProcessos de negócio: tarefas e passos concretos que descrevem como o trabalho é organizado em uma empresa.graph TD A[Gerência sênior] subgraph Gerência média B[Cientistas e trabalhadores do conhecimento] end subgraph Gerência operacional C[Trabalhadores de serviço e de produção e trabalhadores de dados] end A --- B --- CNíveis de uma empresagraph LR subgraph Ciência e tecnologia subgraph Economia subgraph Mudanças internacionais subgraph Política A((Organização)) --- B(Clientes) A --- C(Fornecedores) A --- D(Concorrentes) A --- E(Órgãos reguladores) A --- F(Acionistas) end end end endO ambiente de negóciosTipos de sistemas de informação empresariais: Sistemas de processamento de transações (SPTs); Sistemas de inteligência empresarial (BI); Sistemas de informação gerenciais (SIG); Sistemas de apoio à decisão (SADs); sistemas de apoio ao executivo (SAE); sistemas integrativos (ERP); sistemas de gestão da cadeia de suprimentos (SCM); sistemas de gestão do relacionamento com o cliente (CRM); sistemas de gestão do conhecimento (SGCs).Programadores: especialistas técnicos altamente treinados que elaboram as instruções dos softwares de computadores.Analistas de sistemas: sua tarefa é traduzir os problemas e as necessidades da empresa em requisitos de informações e sistemas.Capítulo 3 - Conquistando vantagem competitiva com os sistemas de informaçãoEstratégias de sistemas de informação para lidar com as forças competitivas: Estratégia básica: alinhe a TI com os objetivos do negócio; Liderança em custos; Diferenciação de produto; Foco em nichos de mercado; Maior intimidade com cliente e o fornecedor; Força competitiva Impacto da Internet Produtos ou serviços substitutos Permite que novos substitutos surjam com novas abordagens para atender necessidades e executar funções. Poder de barganha dos clientes A disponibilidade de informações globais sobre preços e produtos leva o poder de barganha para o consumidor. Poder de barganha dos fornecedores A internet tende a aumentar o poder de barganha sobre os fornecedores na aquisição de produtos e serviços; entretanto, os fornecedores também podem se beneficiar das barreiras reduzidas à entrada e da eliminação de distribuidores e de outros intermediários entre eles e sua clientela. Ameaças de novos entrantes A internet reduz as barreiras à entrada nos mercados, bem como a necessidade de uma força de vendas, acesso a canais e estrutura física. Ela oferece tecnologia direcionadora do processo de negócio que torna as demais tarefas mais fáceis. Posicionamento e rivalidade entre os concorrentes existentes Amplia a abrangência geográfica do mercado, aumenta o número de concorrentes e reduz as diferenças entre eles, tornando mais difícil manter as vantagens operacionais, aumentando a competição por preço. Impacto da Internet nas forças competitivas e na estrutura do setor.Benchmarking: processo de comparar a eficiência e efetividade dos próprios processos de negócios com determinados padrões.Capítulo 4 - Questões éticas e sociais nos sistemas de informaçãoAs cinco dimensões morais da era da informação: Direitos e deveres sobre a informação. Que direitos sobre a informação relativa a si própria os indivíduos e as organizações possuem? O que podem proteger? Direitos e deveres sobre a propriedade. Como os tradicionais direitos de propriedade intelectual serão protegidos em uma sociedade digital na qual identificar e prestar contas da propriedade é difícil, mas ignorar os direitos sobre ela é tão fácil? Prestação de contas e controle. Quem deverá prestar contas e ser responsabilizado por danos causados aos direitos individuais e coletivos sobre a informação e a propriedade? Qualidade do sistema. Que padrões de qualidade de dados e sistemas devem ser exigidos para proteger os direitos individuais e a segurança da sociedade? Qualidade de vida. Que valores devem ser preservados em uma sociedade baseada na informação e no conhecimento? Quais instituições devem ser protegidas contra a violação? Que valores e práticas culturais são apoiados pela nova tecnologia de informação? Responsabilidade: significa que você aceita os custos, os deveres e as obrigações potenciais pelas decisões que toma.Prestação de contas (accountability): significa que existem mecanismos a postos para determinar quem realizou a ação responsável.Obrigação de indenizar (liability): amplia o conceito de responsabilidade para a área das leis; é uma característica de sistemas políticos nos quais há um conjunto de leis que permite que os indivíduos reparem os danos causados a eles por outros agentes, sistemas ou organizações.Análise ética: Identifique e descreva claramento os fatos; Defina os conflitos ou dilema e identifique os valores de ordem mais elevada envolvidos; Identifique os interessados; Identifique as alternativas razoáveis a adotar; Identifique as potenciais consequências das suas opções. Princípios éticos eletivos: Faça aos outros o que gostaria que fizessem a você (a regra de ouro). Se uma ação não é correta para todos, então não é correta para ninguém (imperativo categórico de Immanuel Kant). Se uma ação não puder ser realizada repetidamente, então não deve ser realizada nunca (regra da mudança de Descartes). Realize a ação que produza o valor mais alto ou maior (o princípio utilitário). Realize a ação que cause o menor dano ou que tenha o menor custo potencial (princípio da aversão ao risco). Pressuponha que praticamente todos os objetos tangíveis e intangíveis pertençam a alguém, salvo declaração em contrário (essa é a regra ética “não existe almoço grátis”). As dimensões morais dos sistemas de informação: privacidade, liberdade e propriedade intelectual.Direitos sobre a propriedade: segredos comerciais; direito autoral; patentes.Crime e abuso digital. Exclusão digital.Riscos para a saúde: LER, STC e tecnoestresse.Parte II - Infraestrutura da tecnologia da informaçãoCapítulo 5 - Infraestrutura de TI: hardware e softwareComponentes da infraestrutura de TI: Hardware; Software; Gerenciamento de dados; Redes; Serviços.Tendências de software: software de código aberto; ferramentas e serviços baseados em nuvem;.Planejamento de capacidade e escalabilidade.Custo total de propriedade de ativos tecnológicos (TCO).Utilização de provedores de serviços tecnológicos. Terceirização.Capítulo 6 - Fundamentos da inteligência de negócios: gestão da informação e de banco de dadosUm banco de dados é um conjunto de arquivos relacionados entre si com registros sobre pessoas, lugares ou coisas. Entidades e atributos.Os bancos de dados relacionais organizam os dados em tabelas bidimensionais (denominadas relações) com colunas e linhas (entidades e seus atributos). As linhas também são chamadas de registros ou tuplas. Todas as tabelas possuem um campo-chave, um identificador exclusivo chamado de chave primária. A relação entre tabelas é esclarecida por diagramas entidade/relacionamento (DER). Sistema de gestão de banco de dados (DBMS).Big Data; Data warehouse; Data mart; Hadoop (processamento de big data); Computação em memória (in-memory computing); Plataformas analíticas.Ferramentas analíticas: Processamento analítico on-line (Olap); Data mining; Text mining; Web mining.Capítulo 7 - Telecomunicações, Internet e tecnologia sem fioSistema operacional de rede (NOS). Hubs são dispositivos muito simples que conectam os componentes de rede, enviando um pacote de dados para todos os outros dispositivos conectados. O switch é mais inteligente do que um hub, pois pode filtrar e encaminhar dados para um destinatário específico na rede. Um roteador é um processador de comunicações usado para encaminhar pacotes de dados por diferentes redes, assegurando que a mensagem enviada chegue ao endereço correto. Rede definida por software (SDN).Principais tecnologias de rede digital: computação cliente-servidor; comutação de pacotes; TCP/IP e conectividade.Capítulo 8 - Segurança em sistemas de informaçãoO termo segurança abarca as políticas, os procedimentos e as medidas técnicas usadas para impedir acesso não autorizado, alteração, roubo ou danos físicos a sistemas de informação.Os controles, por sua vez, consistem em todos os métodos, as políticas e os procedimentos organizacionais que garantem a segurança dos ativos da organização, a precisão e a confiabilidade de seus registros contábeis e a aderência operacional aos padrões administrativos.Hackers e crimes de informática: spoofing (disfarce); sniffing (farejador); ataque de recusa de serviço (DoS); ataque distribuído de recusa de serviço (DDoS); roubo de identidade; phishing; pharming; fraude do clique.Política de segurança e Plano de recuperação de desastres.Uma auditoria de sistemas de informação avalia o sistema geral de segurança da empresa e identifica todos os controles que governam sistemas individuais de informação.Tecnologias e ferramentas para garantir a segurança dos recursos de informação: gestão de identidade e autenticação; firewalls, sistemas de detecção de intrusão e softwares antivírus; criptografia e infraestrutura de chave pública; certificados digitais.Como assegurar a disponibilidade do sistema: sistemas de computação tolerantes a falhas; computação orientada a recuperação; inspeção profunda de pacotes (DPI).Downtime refere-se a períodos em que um sistema não está operante.Parte III – Principais aplicações de sistemas para a era digitalCapítulo 9 – Conquistando excelência operacional e intimidade com o cliente: aplicações integradasSoftware integrado baseia-se em uma suíte de módulos de software integrados e um banco de dados comum central que coleta e fornece dados para diversas aplicações que podem suportar quase todas as atividades de negócios internas da empresa. Quando novas informações são fornecidas por um processo, elas são disponibilizadas imediatamente para outros processos de negócio. Sistemas integrados ajudam na centralização organizacional, pois aplicam processos de negócios e padrões de dados uniformizados em toda a empresa, além de utilizar uma única plataforma tecnológica. Válidos para toda a empresa, os dados gerados pelos sistemas integrados ajudam os gestores a avaliar o desempenho organizacional.Os sistemas de gestão da cadeia de suprimentos automatizam o fluxo de informações entre os membros da cadeia de suprimentos; com isso, esses membros podem usar essas informações para tomar decisões mais acertadas sobre quando e quanto comprar, produzir ou expedir. As informações mais precisas proporcionadas pelos sistemas de gestão da cadeia de suprimentos reduzem a incerteza e o impacto do efeito chicote. Os softwares de gestão de cadeia de suprimentos dividem-se em software de planejamento e software de execução da cadeia de suprimentos. A tecnologia da Internet facilita a gestão de cadeias de suprimentos globais, pois permite que organizações de diferentes países se conectem e compartilhem informações. A melhor comunicação entre os membros da cadeia também facilita a resposta eficiente ao cliente e a transição para um modelo orientado pela demanda.Sistemas de gestão do relacionamento com o cliente (CRM) integram e automatizam muitos processos voltados ao cliente nas áreas de vendas, marketing e atendimento, proporcionando uma visão válida para toda a empresa. As organizações podem usar esse conhecimento sobre o cliente quando interagem com ele para oferecer melhores serviços ou vender novos produtos e serviços. Esses sistemas também identificam clientes lucrativos ou não lucrativos, bem como oportunidades para reduzir a taxa de cancelamento (churn rate). Os principais pacotes de software de gestão do relacionamento com o cliente oferecem recursos tanto para o CRM operacional quanto para o CRM analítico. Muitas vezes, incluem módulos para gerenciar o relacionamento com parceiros de venda (gestão do relacionamento com parceiro) e para a gestão de relacionamento com o funcionário.É difícil implementar aplicações integradas. Elas exigem profundas mudanças organizacionais, pesados investimentos em novos softwares e cuidadosa avaliação sobre como esses sistemas melhorarão o desempenho organizacional. As aplicações integradas não podem agregar valor se forem implementadas sobre processos falhos ou se as empresas não souberem como usar esses sistemas para avaliar as melhorias no desempenho. Os funcionários precisam ser preparados para os novos procedimentos e papéis. A gestão de dados também merece atenção especial.As aplicações integradas são agora mais flexíveis, disponíveis na Web e podem ser integradas com outros sistemas, usando serviços Web e arquitetura orientada a serviços (SOA). Elas também têm código aberto e versões sob demanda capazes de serem executadas em infraestruturas de nuvem ou em plataformas móveis. O software CRM acrescentou recursos de redes sociais para aumentar a colaboração interna, aprofundar as interações com os clientes e utilizar dados das redes sociais. Versões de código aberto, para plataformas móveis e em nuvem de alguns desses produtos estão se tornando disponíveis.Capítulo 10 – Comércio eletrônico: mercados digitais, mercadorias digitaisO comércio eletrônico envolve transações comerciais realizadas digitalmente entre uma organização e outra ou entre uma organização e um indivíduo. As características distintivas da tecnologia de comércio eletrônico incluem ubiquidade, alcance global, padrões universais de tecnologia, riqueza, interatividade, densidade da informação, recursos para personalização e customização, além de tecnologia social. O comércio eletrônico tem se tornado cada vez mais social, móvel e local.Mercados digitais são considerados mais “transparentes” do que os tradicionais. A assimetria de informação, os custos de transação, busca e menu e a possibilidade de alterar os preços dinamicamente conforme as condições de mercado são reduzidos. Mercadorias digitais, como música, vídeos, software e livros, podem ser entregues por meio de uma rede digital. Uma vez que um produto digital tenha sido produzido, o custo de entregar esse produto digitalmente é extremamente baixo.Os principais 2 modelos de negócios no comércio eletrônico são lojas virtuais (e-tailers), corretoras de transações, criadores de mercado, provedores de conteúdo, provedores de comunidade virtual, provedores de serviços e portais. Os principais modelos de receita são propaganda, vendas, assinatura, free/freemium, taxa por transação e afiliação.A Internet oferece novas formas de identificação e comunicação com milhões de clientes potenciais a custos infinitamente mais baixos do que os praticados na mídia tradicional. Técnicas de crowdsourcing utilizando a “sabedoria das massas” ajudam as empresas a aprender mais sobre seus consumidores de modo a aprimorar a oferta de produtos e aumentar o valor do consumidor. Técnicas de alvo comportamental aumentam a eficiência de anúncios em forma de banners, mídia rica e vídeos. O comércio social usa redes sociais e sites de redes sociais para melhorar o direcionamento de produtos e serviços.O comércio eletrônico B2B gera eficiência, pois permite que as empresas localizem fornecedores, solicitem cotações, façam pedidos e rastreiem encomendas em trânsito eletronicamente. Os e-marketplaces oferecem um marketplace único e digital para um grande número de compradores e vendedores. Redes setoriais privadas conectam uma empresa aos seus fornecedores e a outros parceiros de negócios estratégicos, com o objetivo de desenvolver cadeias de suprimento altamente eficientes e responder com rapidez às demandas do consumidor.O m-commerce é especialmente adequado a aplicativos baseados em localização, tais como encontrar hotéis e restaurantes locais, monitorar o tráfego local e as condições climáticas e fazer um marketing personalizado, de acordo com a localização. Celulares e computadores de mão estão sendo usados para pagamento móvel de contas, transações bancárias e acionárias, atualizações na programação de meios de transporte e downloads de conteúdo digital, como músicas, jogos e videoclipes. O m-commerce demanda a existência de portais e sistemas de pagamentos digitais que possam lidar com microtransações. Os recursos de GPS dos smartphones possibilitam os serviços geossociais, de geopublicidade e de geoinformação.A construção bem-sucedida de uma presença no comércio eletrônico requer uma compreensão clara sobre os objetivos de negócios a serem alcançados e a escolha das plataformas, atividades e cronograma adequados para atingir esses objetivos. Uma presença no comércio eletrônico inclui não apenas um site corporativo, mas também uma presença no Facebook, Twitter e em outros sites de redes sociais e apps de smartphones.Capítulo 11 – Aprimorando a tomada de decisão e a gestão do conhecimentoAs decisões podem ser estruturadas, semiestruturadas ou não estruturadas. As decisões estruturadas são mais frequentes no nível operacional da organização, e as não estruturadas, no nível estratégico. Elas podem ser tomadas por indivíduos ou grupos, por funcionários ou gerentes operacionais, de nível médio e seniores. Existem quatro estágios na tomada de decisão: inteligência, concepção, seleção e implementação.A inteligência e a análise empresarial prometem entregar informações corretas, quase em tempo real aos profissionais que tomam decisão, e as ferramentas analíticas podem ajudá-los a compreender rapidamente as informações e a tomarem a ação. Um ambiente de inteligência empresarial consiste em dados do ambiente empresarial, na infraestrutura de inteligência empresarial, em um conjunto de ferramentas de BA (Business Analytics), nos usuários e métodos gerenciais, em uma plataforma de entrega de inteligência empresarial (SIG, SAD, ou SAE) e na interface do usuário. Há seis funcionalidades analíticas que os sistemas de inteligência empresarial entregam para atingir esses fins: relatórios de produção predefinidos, relatórios parametrizados, painéis e scorecards, consultas e buscas específicas, a capacidade de drill-down para obter visualizações detalhadas dos dados, bem como a capacidade de modelar cenários e criar previsões. A análise de inteligência empresarial está começando a lidar com o Big Data. A análise preditiva e a análise de localização são recursos analíticos importantes.Sistemas de informações gerenciais (SIG) que produzem relatórios de produção pré-embalados são normalmente utilizados para apoiar a gerência operacional e de nível médio, cuja tomada de decisão é bastante estruturada. Para a tomada de decisões não estruturadas, analistas e “super usuários” empregam sistemas de apoio à decisão (SAD), com poderosas ferramentas de análise e de modelagem, incluindo planilhas e tabelas dinâmicas. Executivos seniores que tomam decisões não estruturadas usam painéis e interfaces visuais de exibição de indicadores-chave de desempenho que afetam a rentabilidade global, o sucesso e a estratégia da empresa. O balanced scorecard (estrutura de operacionalização do plano estratégico de uma empresa, focando os resultados mensuráveis em quatro dimensões do desempenho da empresa: financeiro, processos de negócios, clientes e aprendizado e crescimento) e a gestão do desempenho empresarial são duas metodologias utilizadas no projeto de sistemas de apoio ao executivo (SAE).Sistemas de apoio à decisão em grupo (SADG) ajudam as pessoas a se reunir em grupo e a tomar decisões de forma mais eficiente. O SADG apresenta recursos especiais de sala de conferências na qual os participantes contribuem com suas ideias utilizando computadores em rede e ferramentas de software para organização de ideias, coleta de informações, classificação e definição de prioridades, bem como documentação das reuniões.Sistemas especialistas capturam o conhecimento tácito proveniente de domínio limitado de perícia humana e expressam esse conhecimento na forma de regras. A estratégia para pesquisar a base de conhecimento é chamada de mecanismo de inferência. O raciocínio baseado em casos representa o conhecimento organizacional na forma de um banco de dados de casos que pode ser continuamente expandido e refinado.A lógica difusa é uma tecnologia de software para expressar o conhecimento na forma de regras usando valores subjetivos ou aproximados. Redes neurais consistem em um conjunto de software e hardware que tenta imitar os processos de raciocínio do cérebro humano. Elas são famosas por sua capacidade de aprender sem programação e de reconhecer padrões em quantidades gigantescas de dados.Algoritmos genéticos desenvolvem soluções para problemas particulares usando processos geneticamente fundamentados, tais como adaptação, recombinação e mutação. Agentes inteligentes são programas de software com bases de conhecimento embutidas ou aprendidas que realizam tarefas específicas, repetitivas e previsíveis para um usuário individual, um processo de negócio ou uma aplicação de software.Sistemas integrados de gestão do conteúdo fornecem bancos de dados e ferramentas para organizar e armazenar documentos estruturados e conhecimento semiestruturado, tal como e-mail ou mídia rica. Sistemas de rede de conhecimento oferecem listas e ferramentas para localizar os funcionários da empresa com conhecimentos especializados e que são fontes importantes de conhecimento tácito. Muitas vezes, tais sistemas incluem ferramentas de colaboração em grupo, portais para simplificar o acesso à informação, ferramentas de busca e para classificar as informações com base em uma taxonomia apropriada à organização. Sistemas de gestão do aprendizado oferecem ferramentas para gestão, disponibilização, controle e avaliação de vários tipos de treinamento e aprendizado dos funcionários.Sistemas de trabalhadores do conhecimento apoiam a criação de novos conhecimentos e sua integração à organização. Exigem fácil acesso a bases de conhecimentos externas; um hardware poderoso, capaz de comportar software com potentes recursos gráficos, de análise, gestão de documentos e comunicações; e uma interface amigável ao usuário.Parte IV – Como desenvolver e gerenciar sistemasCapítulo 12 – Como desenvolver sistemas de informação e gerenciar projetosOs principais passos de resolução de problemas para o desenvolvimento de novos sistemas de informação são: (I) definir e compreender o problema; (2) desenvolver soluções alternativas; (3) avaliar e escolher a solução; e (4) implementar a solução. O terceiro passo abrange a avaliação da viabilidade técnica, financeira e organizacional de cada alternativa. O quarto passo abarca a finalização das especificações de projeto, a aquisição de hardware e software, testes, a oferta de treinamento e documentação, a conversão e a avaliação da solução de sistema uma vez que ela entre em produção.O ciclo de vida de sistemas exige que eles sejam desenvolvidos em estágios formais, que devem evoluir em sequência e ter resultados definidos; cada um precisa ser formalmente aprovado antes que o próximo se inicie. O ciclo de vida de sistemas é rígido e dispendioso, mas adequado para grandes projetos.A prototipagem consiste em desenvolver um sistema experimental de maneira rápida e barata, para que os usuários finais interajam com ele e o avaliem. O protótipo é refinado e aperfeiçoado até que os usuários sintam que ele atende a todas as suas necessidades, podendo ser usado como modelo para criar o sistema final. Os sistemas desenvolvidos pelo usuário final podem ser criados de modo rápido e informal utilizando ferramentas de software de quarta geração. O desenvolvimento pelo usuário final pode melhorar a determinação de requisitos e reduzir o acúmulo de tarefas da aplicação.Pacotes de software aplicativo eliminam a necessidade de escrever programas durante o desenvolvimento do sistema de informação. Esses pacotes são úteis se a empresa não conta com uma equipe de sistemas de informação ou com recursos financeiros suficientes para desenvolver um sistema sob medida.O outsourcing (terceirização) consiste em usar um fornecedor externo para desenvolver (ou operar) esses sistemas de informação. Se for adequadamente gerenciado, o outsourcing pode poupar custos de desenvolvimento de aplicações ou permitir que as organizações desenvolvam aplicações sem uma equipe interna de sistemas de informação.Desenvolvimento rápido de aplicações, projeto conjunto de aplicações (JAD), plataformas baseadas em nuvem e componentes de software reutilizáveis (incluindo serviços da Web) podem ser usados para acelerar o processo de desenvolvimento de sistemas. O desenvolvimento de aplicativos móveis deve considerar múltiplas plataformas, tamanhos menores de tela e a necessidade de preservar os recursos.As duas principais metodologias para modelagem e projeto de sistemas de informação são as metodologias estruturadas e o desenvolvimento orientado a objetos. As metodologias estruturadas enfocam separadamente os dados e processos de modelagem. O diagrama de fluxo de dados é a principal ferramenta para a análise estruturada, enquanto o diagrama de estrutura é a principal ferramenta para representar o projeto de software estruturado. No desenvolvimento orientado a objetos, um sistema é um conjunto de objetos que combinam processos e dados.Para determinar se um sistema de informação é um bom investimento para a empresa, é preciso calcular seus custos e benefícios. Os benefícios tangíveis são quantificáveis, e os intangíveis não podem ser imediatamente quantificados, mas podem proporcionar vantagens quantificáveis no futuro. Benefícios que superem os custos devem, então, ser analisados por meio de métodos de orçamento de capital para se ter certeza de que representam um bom retorno sobre o capital investido da empresa. As organizações devem desenvolver planos de sistemas de informação que descrevam como a tecnologia de informação apoia o plano de negócios e a estratégia global da empresa. Análise de carteira (portfólio) e modelos de pontuação (scoring) podem ser usados para avaliar projetos e sistemas de informação alternativos.Os projetos de sistemas de informação, bem como todo o processo de implementação, devem ser gerenciados como uma mudança organizacional planejada com base na análise de impacto organizacional. Suporte e controle gerenciais do processo de implementação são essenciais, assim como mecanismos para tratamento do nível de risco em cada novo projeto de sistema. Os riscos sofrem influência do tamanho do projeto, de sua estrutura e do nível de conhecimento técnico das equipes de sistemas de informação e projetos. Planejamento formal e ferramentas de controle (dentre elas, gráficos de Gantt e PERT) controlam a alocação de recursos e as atividades específicas do projeto. Os usuários podem ser encorajados a assumir papéis ativos no desenvolvimento de sistemas e a se envolver nas fases de instalação e treinamento. Projetos de sistemas de informações globais devem envolver unidades locais no processo de planejamento sem ceder o controle do projeto a interesses limitados." }, { "title": "Anotações sobre Javascript", "url": "/posts/javascript/", "categories": "Estudos-faculdade", "tags": "javascript, web", "date": "2020-01-24 09:00:00 -0300", "snippet": "Comentários// This is an in-line comment./* This is amulti-line comment */ Declaração de variáveisvar ourName; Tipos: undefined, null, boolean, string, symbol, bigint, number, and object.Variable names can be made up of numbers, letters, and $ or _, but may not contain spaces or start with a number.In JavaScript all variables and function names are case sensitive.Write variable names in JavaScript in camelCase.In JavaScript, you can escape a quote from considering it as an end of string quote by placing a backslash () in front of the quote.var sampleStr = “Alan said, \"Peter is learning JavaScript\".”;Introdução ECMAScript é uma especificação de linguagem script criada pela Ecma International, utilizada por linguagens como: ActionScript, JScript e Javascript. Javascript é uma linguagem de funções de primeira classe e funções de ordem maior, pois é possível atribuir funções a variáveis, retornar funções de outras funções e passar funções como parâmetro para outras funçõesLinguagem de programação executada no lado cliente. Código desprotegido. Linguagem interpretada.Script – interpretada em tempo de execuçãoTipagem fraca e dinâmicaCase SensitiveComentários: //linha /* bloco */Babeljs.io para converter implementações novas em antigas Closure ou escopo léxico é a capacidade da função “lembrar” do seu contexto de criação. Hoisting ou içamento é a capacidade do JavaScript elevar a criação de variáveis e funções ao topo do escopo de suas criações. Existem dois tipos de Hoisting: hoisting de variável e hoisting de função.Curryng e ImutabilidadeDentro do HTML&lt;script&gt; \tfunction nomeDaFuncao (parametros) {codigo}&lt;/script&gt; &lt;script&gt; language=\"javascript\" src=\"\"&lt;/script&gt; &lt;img src=\"\" onmousemove=\"nomeDaFuncao\" onmouseout=\"\" onclick=\"\"&gt;&lt;/img&gt;Comandos iniciais window.alert(\"Olá mundo\");   window.prompt(\"Olá mundo\");   window.confirm(\"Olá mundo?\");   document.write(\"Olá mundo, hoje é dia\" + Date());   document.getElementById(\"\").src = \"\";   console.log('')   Number.parseInt(n) //converter string em int   Number.parseFloat(n) //converter string em float   Number(n) //converter string para número com tipo altomático   String(n) ou n.toString() //converter número para String   typeof var //retorna o tipo da variável   throw new Error ('mensagem de erro') // indica o erro no console Atributos e funções internas.length: tamanho da string .toUpperCase(): string em letras maiúsculas .toLowerCase(): string em letras minúsculas .toFixed(numero de casas).replace('.',','): para definir quantas casas decimais, e trocar ponto por vírgula. .toLocaleString('pt-br' , {style: 'currency', currency: 'BRL'}) //para exibir na forma monetária .includes(\"\"):verificação de string, resultado bool .indexOf('busca', posicaoInicial): mapeamento da string para retornar busca .lastIndexOf() busca reversa, começando do fim .substring(,): retornar uma parte da string .replace(,) .slice(,) para criar um novo array, valor final não incluso .push() inclui um novo elemento no final do array .pop() remove o ultimo item do array .sort() ordenar elementos .filter() .forEach() .getHour() .getFullYear() .innerHTML para editar o html .innerText para editar texto simples na página .createElement .appendChild() adicionar elemento filho .focus() .disabled = true//false new Date() Tanto as propriedades .value, .textContent, e .innerHTML servem para definir um novo valor ou recuperar o valor atual.Tipos de dadosstring, number, boolean, null, undefined, symbol, Object, Function, Array.var cria variáveis globais let cria variáveis locais var alfa = \"strings\"; var num = 50.03; var bol = true; var objetoarray = new Array(\"Maçã\", \"Laranja\", \"Uva\"); var objeto = new Object () const a = 3.14Array é um objeto. objeto[0]. objeto[1]. objeto[2] Nomes de variáveis podem começar com letra, $ ou _. Não podem começar com números, mas podem conter números, acentos e símbolos. Não podem conter espaços e nem usar palavras reservadas.Template string: uma forma mais fácil de concatenar strings: ${s}Valores falsosfalse: the boolean value false0: the number zero‘’: the empty string, a string with no charactersNaN : stands for “Not a Number”, usually caused by math errorsundefined: a variable’s value before it is assigned a valuenull: a blank value that can be assigned to a variableOperadores = atribuição soma ou concatenação de strings subtração multiplicação / divisão real% resto da divisão inteira** potenciaçãoPrecedências: () *** / % o que vier antes da esquerda pra direita+-++ incremento de 1(executado depois de outras operações se estiver do lado direito da variável. pode ser ++x)– decremento de 1(igual anterior)+= soma com o valor a direita e atualiza a variável-= subtrai o valor a direita e atualiza a variável*= same/= same%= sameRelacionais== mesmo valor mesmo que tipos diferentes=== mesmo valor e mesmo tipo!= diferentes em valor!== diferentes em valor e em tipo&lt; menor que maior que&lt;= menor igual = maior igualLógicos! negação&amp; e ou &amp;&amp; e verificando a primeira condição e já resultando falso se for o caso   ou verificando a primeira condição e já resultando verdadeiro se for o caso Precedência: aritméticosrelacionais!&amp;&amp;   Comandos de decisão e controleComandos de decisãoif(condição) {}else if(condição) {}else{}switch(valor){case 0 …break; default} Operador ternário substitui if elsetest ? doThisIfTrue : elseDoThis Comandos de repetição - laços - iteraçõesfor(inicialização; condição; incremento) {}for(elemento in array) {}while(condição) {}do {} while(condição) Comandos de controlebreak interrompe repetiçãocontinue interrompe a execução atual da repetição mas permite a continuação do laçoFunções e exceçõesCriando funçõesfunction nomeDaFuncao(parâmetros) {} FunçõesChamada - parâmetro - ação - retornoFunção literal:function ação (param) {return res}ação(5) //chamadaFunções podem ser tratadas como objetos, e receber atributos. Podem ser anônimas. Podem ser passadas como parâmetro para outras. Todas as funções possuem um atributo .name. Apenas funções criam escopos de variáveis (ECMA antigo). Nas versões novas o let cria variáveis em escopo de função. As funções também possuem o atributo .argument que apresenta os parâmetros que foram passados.A herança em JavaScript ocorre por meio do seu protótipo.Funções auto executáveis: Immediately-invoked function expression IIFE:(function(){}) {}Funções que se auto invocam, para não poluirmos o escopo global desnecessariamente. É interessante perceber que esse tipo de função só tem valor quando estamos desenvolvendo para o browser, onde tudo fica “pendurado” no objeto principal chamado window. Se estivéssemos desenvolvendo para NodeJS, por exemplo, essa preocupação não existiria. Função construtora de objetos personalizados function Construtora() { //funções construtoras com nomes em letra maiúscula, por convenção. Atributos criados com var são locais e privados. var atributoPrivado this.atributo = 1; this.metodo = function(){} } para criar os objetos sempre use o new Construtora(), para evitar problemas de referência com o this.Tratando exceçõestry{//código a ser testado} catch(e) {//tratamento do erro}DOMEntendendo o DOMDocument Object Model - apenas no navegadorÁrvore DOM: window (location; document; history)document(html) //// html(head; body)Métodos de acesso: Por marca: getElementsByTagName(‘tag’)[n] Por ID: getElementById() Por Nome: getElementsByName()[] Por Classe:getElementsByClassName()[] Por Seletor: querySelector(‘identificação no css’) /// querySelectorAll(‘body.caixa’) .[name].value  Acessando atributos no HTMLAlgumas propriedades podem ser acessadas e modificadas usando o DOM 0 e DOM 2 $elemento.id //0 $elemento.maxLength = 10 //0 $elemento.getAttribute('readonly') //2 $elemento.setAttribute('id', 'myId') //2   Eventos DOMListeners no JavaScript:a.addEventListener(‘mouseenter’, functionname)mouseentermousemovemousedownmouseupclickmouseout Caixas de diálogoAlerta: exibir mensagem na tela. alert(mensagem)Confirmação: solicita confirmação do usuário. confirm(mensagem)Solicitação de informação. prompt(mensagem, valorinicial) EventosSituações que disparam um código. Chamadas no HTML:onBlur: foco sai do elemento.onChange: elemento muda de valor.onClick: Elemento é clicado.onFocus: Foco é colocado no elemento.onLoad: Página é carregada.onUnload: Usuário clica para destino fora da página.onMouseOver: Mouse entra na área do elemento.onMouseOut: Mouse deixa a área do elemento.onMouseDown: Mouse clica no elemento (ida).onMouseUp: Mouse clica no elemento (volta).onKeyPress: Tecla é digitada no elemento.onKeyDown: Tecla é digitada no elemento (ida).onKeyUp: Tecla é digitada no elemento (volta).onSubmit: Elemento é enviado. Extras• Redirecionar para URL– location.href(URL)• Abrir nova janela– open(URL)• Interagindo com marcações HTML– Atributo id do HTML– document.getElementById(id)• Agendamento de tarefas– setTimeout(funcao, tempoMilisegundos) Formulários• Objeto de acesso ao documento HTML– document• Objeto de acesso aos formulários– document.forms[name]• Acessando campos de um formulário– document.forms[name].namedocampo• Principais propriedades dos campos– value: conteúdo do campo– length: tamanho do campo– checked: informa se o campo está checado– selectedIndex: número da opção selecionada DOM level 0 - alguns problemasNo html No JS—————————- —————— &lt;p onclick=”função()” p.onclick=funcaoDOM level 2 - mais recomendadop.addEventListener(“click”, funcao, bool capture);Propagação de eventos: capacidade dos eventos de percorrerem a estrutura do HTML, desde o elemento original até o nível mais alto (body). Bool capture: valor padrão é falso. Altera a propagação dos eventos.Objeto Event: objeto passado por parâmetro para a função que foi atrelada, nos fornecendo várias informações adicionais sobre o evento em si. Este objeto varia de acordo com o tipo de evento. document.addEventListener('click', function (objetoEvento){ console.log(objetoEvento); console.log(objetoEvento.currentTarget); console.log(objetoEvento.target); objetoEvento.stopPropagation(); //interrompe a propagação do evento }) Delegação: técnica que consiste em atrelar o evento a um elemento mais alto e verificar qual foi o elemento clicado. ul.addEventListener('click', function (objetoEvento){ console.log(objetoEvento.target); //retorna qual li foi clicada console.log(objetoEvento.target.nodeName) //retorna o tipo do elemento objetoEvento.stopPropagation(); //interrompe a propagação do evento }) Variáveis compostasVetores e arraysConjuntos de dadosArray[]Objeto{}Construtor: new Object()Objetos armazenam atributos e métodos (funções)É possível criar um array de objetos. [{},{},{}]Alguns objetos são relativos ao ambiente de hospedagem (ex: window.alert(‘’) só para navegador)StringsLiterais var meuTexto = “Olá Mundo!”;Objetos var meuTexto = new String(“Olá Mundo!”);Métodos e Propriedades: .length //tamanho da string .toUpperCase() //string em letras maiúsculas .toLowerCase() //string em letras minúsculas .replace('.',',') //para substituir caracteres .includes(\"\") //verificação de string, resultado bool .indexOf('busca', posicaoInicial) //mapeamento da string para retornar busca .lastIndexOf() //busca reversa, começando do fim .substring(,) //retornar uma parte da string .slice(,) //para criar um novo array, valor final não incluso - posições ordenadas .split() //retorna um array separando as partes da string original .valueOf() //retorna o valor primitivo NumberLiterais var meuNum = 123;Objetos var meuNum = new Number(“123”);Métodos e Propriedades:MAX_VALUE //pripriedade estática, do construtor MIN_VALUE //pripriedade estática, do construtor toFixed() //para definir quantas casas decimais são exibidas toPrecision() //arredonda para um valor definido de casas decimais String(n) ou n.toString() //converter número para String, pode ser usado para converter para hexadecimal, binário etc toExponential() //retorna a notação científica do número MathMétodos e propriedades são estáticos, ou seja, pertencem ao próprio construtor.Math.min() //retorna o menor valor Math.max() //retorna o maior valor Math.round() //arredondar Math.floor() //arredondar para menos Math.ceil() //arredondar para mais Math.pow(,) // retorna a potência Math.sqrt() //retorna a raiz quadrada Math.cbrt() //retorna raiz cubica Math.random() //retorna um aleatorio Math.PI //retorna o valor de PI " }, { "title": "Anotações sobre Recuperação de banco de dados e segurança", "url": "/posts/recupera%C3%A7%C3%A3o-banco-dados-seguran%C3%A7a/", "categories": "Estudos-faculdade", "tags": "banco-de-dados, segurança", "date": "2020-01-17 09:00:00 -0300", "snippet": "Estratégias de recuperação: Se houver dano extensivo a uma grande parte do banco de dados devido a uma falha catastrófica, como uma falha de disco, o método de recuperação restaura uma cópia antiga do banco de dados que teve backup para o arquivamento (normalmente, fita ou outro meio de armazenamento off-line de grande capacidade) e reconstrói um estado mais recente, reaplicando ou refazendo as operações das transações confirmadas do log em backup, até o momento da falha. Quando o banco de dados no disco não está danificado fisicamente, por conta de uma falha não catastrófica, a estratégia de recuperação é identificar quaisquer mudanças que possam causar uma inconsistência no banco de dados. Por exemplo, uma transação que atualizou alguns itens do banco de dados no disco, mas não confirmou as necessidades de ter suas mudanças revertidas ao desfazer suas operações de gravação. Pode também ser preciso refazer algumas operações a fim de restaurar um estado consistente do banco de dados; por exemplo, se uma transação tiver sido confirmada, mas algumas de suas operações de gravação ainda não tiverem sido gravadas em disco. Para a falha não catastrófica, o protocolo de recuperação não precisa de uma cópia de arquivamento completa do banco de dados. Em vez disso, as entradas mantidas no log do sistema on-line no disco são analisadas para determinar as ações apropriadas para recuperação. Técnicas de atualização:Atualização adiadaNão atualizam fisicamente o banco de dados no disco até que uma transação atinja seu ponto de confirmação; então as atualizações são registradas no banco de dados. Antes de atingir a confirmação, todas as atualizações de transação são registradas no espaço de trabalho de transação local ou nos buffers da memória principal que o SGBD mantém (o cachê da memória principal do SGBD). Antes da confirmação, as atualizações são gravadas persistentemente no log e, após a confirmação, elas são gravadas no banco de dados no disco. Se uma transação falhar antes de atingir seu ponto de confirmação, ela não terá alterado o banco de dados de forma alguma, de modo que o UNDO não é necessário. Pode ser preciso um REDO para desfazer o efeito das operações de uma transação confirmada com base no log, pois seu efeito pode ainda não ter sido registrado no banco de dados em disco. Assim, a atualização adiada também é conhecida como algoritmo NO-UNDO/REDO.Atualização imediataO banco de dados pode ser atualizado por algumas operações de uma transação antes que a transação alcance seu ponto de confirmação. Porém essas operações também precisam ser registradas no log no disco ao forçar a gravação antes que elas sejam aplicadas ao banco de dados no disco, tornando a recuperação ainda possível. Se uma transação falhar depois de gravadas algumas mudanças no disco, mas antes de atingir seu ponto de confirmação, o efeito de suas operações no banco de dados precisa ser desfeito; ou seja, a transação deve ser revertida. No caso geral da atualização imediata, tanto UNDO quanto REDO podem ser exigidos durante a recuperação. Essa técnica, conhecida como algoritmo UNDO/REDO, requer as duas operações durante a recuperação, e é usada na prática. Uma variação do algoritmo, em que todas as atualizações precisam ser registradas no banco de dados em disco antes que a transação se confirme, requer apenas UNDO, de modo que é conhecido como algoritmo UNDO/NOREDO.Não atualizam fisicamente o banco de dados no disco até que uma transação atinja seu ponto de confirmação; então as atualizações são registradas no banco de dados. Antes de atingir a confirmação, todas as atualizações de transação são registradas no espaço de trabalho de transação local ou nos buffers da memória principal que o SGBD mantém (o cachê da memória principal do SGBD). Antes da confirmação, as atualizações são gravadas persistentemente no log e, após a confirmação, elas são gravadas no banco de dados no disco. Se uma transação falhar antes de atingir seu ponto de confirmação, ela não terá alterado o banco de dados de forma alguma, de modo que o UNDO não é necessário. Pode ser preciso um REDO para desfazer o efeito das operações de uma transação confirmada com base no log, pois seu efeito pode ainda não ter sido registrado no banco de dados em disco. Assim, a atualização adiada também é conhecida como algoritmo NO-UNDO/REDO.\tO banco de dados pode ser atualizado por algumas operações de uma transação antes que a transação alcance seu ponto de confirmação. Porém essas operações também precisam ser registradas no log no disco ao forçar a gravação antes que elas sejam aplicadas ao banco de dados no disco, tornando a recuperação ainda possível. Se uma transação falhar depois de gravadas algumas mudanças no disco, mas antes de atingir seu ponto de confirmação, o efeito de suas operações no banco de dados precisa ser desfeito; ou seja, a transação deve ser revertida. No caso geral da atualização imediata, tanto UNDO quanto REDO podem ser exigidos durante a recuperação. Essa técnica, conhecida como algoritmo UNDO/REDO, requer as duas operações durante a recuperação, e é usada na prática. Uma variação do algoritmo, em que todas as atualizações precisam ser registradas no banco de dados em disco antes que a transação se confirme, requer apenas UNDO, de modo que é conhecido como algoritmo UNDO/NOREDO.Algoritmo de recuperação ARIES: o ARIES é um algoritmo de recuperação projetado para trabalhar com uma estratégia de roubo, sem imposição. Quando o gerenciador de recuperação é ativado após uma falha, o reinício ocorre em três fases: Análise: Identifica as páginas sujas no pool de buffers (isto é, alterações que não foram gravadas no disco) e as transações ativas no momento da falha. Refazer: Repete todas as ações, partindo de um ponto apropriado no log, e restaura o banco de dados para o estado em que ele estava no momento da falha. Desfazer: Desfaz as ações das transações que não foram efetivadas, para que o banco de dados reflita apenas as ações das transações efetivadas. Princípios do algoritmo de recuperação ARIES: Gravação antecipada do Log (Write-Ahead Logging, WAL): Qualquer alteração em um objeto de banco de dados é primeiramente gravada no log; o registro que está no log deve ser gravado em um meio de armazenamento estável, antes que a alteração no objeto de banco de dados seja gravada no disco. Repetição do Histórico durante a fase Refazer: Na inicialização após uma falha, o ARIES refaz todas as ações do SGBD antes da falha e coloca o sistema de volta no estado exato em que se encontrava no momento da falha. Ele então desfaz as ações das transações que ainda estavam ativas no momento da falha (cancelando-as efetivamente). Registro das alterações durante a fase Desfazer: As alterações feitas no banco de dados, enquanto uma transação é desfeita, são registradas para garantir que essa ação não seja repetida no caso de reinícios (causando falhas) repetidos.A parte mais recente do log, chamada de cauda do log, é mantida na memória principal, e é periodicamente gravada no armazenamento estável. Desse modo, os registros do log e os registros dos dados são gravados no disco com a mesma granularidade (páginas ou conjuntos de páginas). Todo registro de log recebe um id exclusivo, chamado de número de sequência de log (NSL).Tabelas relacionadas à recuperação:Tabela de transações: Essa tabela contém uma entrada para cada transação ativa. A entrada contém (dentre outras coisas) o id da transação, o status e um campo chamado último NSL, que é o NSL do registro de log mais recente dessa transação. O status de uma transação pode indicar que ela está em andamento, foi efetivada ou foi cancelada. (Nos dois últimos casos, a transação será removida da tabela quando certas etapas de ‘limpeza’ forem completadas.) Tabela de páginas sujas: Essa tabela contém uma entrada para cada página suja no pool de buffers; isto é, cada página com alterações ainda não refletidas no disco. A entrada contém um campo NSLreg, que é o NSL do primeiro registro de log que fez a página tornar-se suja. Note que esse NSL identifica o registro de log mais recente que talvez tenha que ser refeito para essa página durante o reinício a partir de uma falha.Discos rígidos espelhados – arquitetura RAID - (Redundant Array Inexpensive/Independent Disk, ou “Conjunto Redundante de Discos Econômicos/Independentes”).Controle de concorrênciaAplicação de diversas técnicas que são usadas para garantir a propriedade de não interferência ou isolamento das transações executadas simultaneamente.O protocolo de bloqueio mais amplamente usado é o bloqueio de duas fases restrito, ou Strict 2PL (do inglês, Strict Two-Phase Locking). Se uma transação T quer ler (respectivamente, modificar) um objeto, ela primeiro solicita um bloqueio compartilhado (respectivamente, exclusivo) sobre o objeto. Todos os bloqueios mantidos por uma transação são liberados quando a transação termina. Uma transação que tenha um bloqueio exclusivo também pode ler o objeto; não é exigido um bloqueio compartilhado adicional. Uma transação que solicita um bloqueio é suspensa até que o SGBD seja capaz de garantir-lhe o bloqueio solicitado. O SGBD monitora os bloqueios que concedeu e garante que, se uma transação mantiver um bloqueio exclusivo sobre um objeto, nenhuma outra transação manterá um bloqueio compartilhado ou exclusivo sobre o mesmo objeto. Os pedidos para adquirir e liberar bloqueios podem ser inseridos automaticamente nas transações pelo SGBD; os usuários não precisam se preocupar com esses detalhes. Na verdade, o protocolo de bloqueio só permite intercalações “seguras” de transações. Se duas transações acessam partes completamente independentes do banco de dados, elas obtêm concorrentemente os bloqueios que precisam e seguem seu caminho normalmente. Por outro lado, se duas transações acessam o mesmo objeto e uma quer modificá-lo, suas ações são efetivamente ordenadas em série – todas as ações de uma dessas transações (aquela que recebe primeiro o bloqueio sobre o objeto comum) são concluídas antes (que esse bloqueio seja liberado) e que a outra transação possa prosseguir.Outro conjunto de protocolos de controle de concorrência, utiliza rótulos de tempo (timestamp). Um rótulo de tempo é um identificador exclusivo para cada transação gerado pelo sistema. Os valores de rótulo de tempo são gerados na mesma ordem que os tempos de início de transação.Performance – conhecer técnicas de otimização de consultas (consultas, índices) Enumerar planos alternativos para avaliar a expressão. Normalmente, o otimizador considera um subconjunto de todos os planos possíveis, pois o número deles é muito grande. Estimar o custo de cada plano enumerado e escolher o plano com o custo estimado mais baixo.Para serem realizadas, as consultas SQL são otimizadas pela sua decomposição em um conjunto de unidades menores chamadas blocos. Um otimizador de consultas relacional típico se concentra na otimização de um único bloco por vez. Para isso, uma consulta é decomposta em blocos, e a otimização de um único bloco pode ser compreendida em termos de planos constituídos de operadores da álgebra relacional.Para cada nó na árvore, devemos estimar o custo da execução da operação correspondente. Os custos são afetados significativamente pelo fato de se usar pipelining ou se relações temporárias são criadas para passar a saída de um operador para seu ascendente. Para cada nó na árvore, devemos estimar o tamanho do resultado e verificar se ele está ordenado. Esse resultado é a entrada para a operação que corresponde ao ascendente do nó corrente e, por sua vez, o tamanho e a ordem afetam a estimativa de tamanho, o custo e a ordem do ascendente.Utilização de índices nos SGBDRs:IBM DB2: Ao criar um índice, o usuário pode especificar um conjunto de colunas ‘de inclusão’ que devem ser mantidas no índice, mas que não fazem parte da chave do índice. Isso possibilita que um conjunto mais rico de consultas somente de índice seja manipulado, pois as colunas acessadas frequentemente são incluídas no índice, mesmo que não façam parte da chave.Microsoft SQL Server: Considerada uma classe interessante de planos somente de índice, suponha uma consulta que seleciona atributos salário e idade a partir de uma tabela, dado um índice em salário e outro em idade.SQL Server: Associando as entradas por junção no rid dos registros de dados para identificar os pares (salário, idade) que aparecem na tabela.Representação de índice: Caminho de acesso com um único índice: Se vários índices correspondem às condições de seleção na cláusula WHERE, cada índice correspondente oferece um caminho de acesso alternativo. Um otimizador pode escolher o caminho de acesso que, segundo sua estimativa, vai resultar na recuperação do menor número de páginas, e pode aplicar projeções e termos de seleção não primários (isto é, partes da condição de seleção que não correspondem ao índice), e pode passar a calcular as operações de agrupamento e agregação (ordenando nos atributos de GROUP BY). Caminho de acesso com vários índices: Se vários índices usando as alternativas (2) ou (3) para entradas de dados corresponderem à condição de seleção, cada índice poderá ser usado para recuperar um conjunto de rids. Podemos fazer a intersecção desses conjuntos de rids e, depois, ordenar o resultado pelo id da página (supondo que a representação de rid inclua o id da página) e recuperar as tuplas que satisfazem os termos da seleção primária de todos os índices correspondentes. Todas as projeções e termos de seleção não primários podem, então, ser aplicados, seguidos das operações de agrupamento e agregação. Caminho de acesso com índice ordenado: Se a lista de atributos de agrupamento for um prefixo de um índice de árvore, o índice pode ser usado para recuperar as tuplas na ordem exigida pela cláusula GROUP BY. Todas as condições de seleção podem ser aplicadas em cada tupla recuperada, os campos indesejados podem ser removidos e as operações agregadas podem ser calculadas para cada grupo. Essa estratégia funciona bem para índices agrupados. Caminho de acesso somente de índice: Se todos os atributos mencionados na consulta (nas cláusulas SELECT, WHERE, GROUP BY ou HAVING) estiverem incluídos na chave de pesquisa para algum índice denso na relação da cláusula FROM, uma varredura somente de índice poderá ser usada para calcular as respostas. Como as entradas de dados no índice contêm todos os atributos de uma tupla necessários para essa consulta e há apenas uma entrada de índice por tupla, nunca precisamos recuperar tuplas reais da relação. Usando apenas as entradas de dados do índice, podemos executar os passos a seguir, conforme for necessário, em determinada consulta: aplicar as condições de seleção, remover os atributos indesejados, ordenar o resultado para obter agrupamento e calcular as funções agregadas dentro de cada grupo. Essa estratégia somente de índice funciona mesmo que o índice não corresponda às seleções da cláusula WHERE. Se o índice corresponder à seleção, precisamos examinar apenas um subconjunto das entradas de índice; caso contrário, devemos percorrer todas as entradas de índice. Em qualquer caso, podemos evitar a recuperação de registros de dados reais; portanto, o custo desta estratégia não depende de o índice ser agrupado. Além disso, se é um índice de árvore e a lista de atributos na cláusula GROUP BY forma um prefixo da chave do índice, podemos recuperar as entradas de dados na ordem necessária para a cláusula GROUP BY e, com isso, evitar a ordenação. Data warehouseUm data warehouse tem a característica distintiva de servir principalmente para a aplicação de apoio à decisão, sendo utilizados para recuperar dados e não para processamento de transação de rotina, o que implica diretamente que os data warehouse são muito distintos dos bancos de dados tradicionais em sua estrutura, funcionamento, desempenho e finalidade.OLAP – Processamento analítico on-line: É um termo usado para descrever a análise de dados complexos do data warehouse. Nas mãos de trabalhadores do conhecimento habilidoso, as ferramentas OLAP utilizam capacidades de computação distribuída para análises que exigem mais armazenamento e poder de processamento do que pode estar localizada econômica e eficientemente em um desktop individual.DSS sistema de apoio à decisão: Também conhecido como sistema de informações executivas. Não confunda com sistemas de integração empresarial; ajudam os principais tomadores de decisões de uma organização com dados de nível mais alto em decisões complexas e importantes.Mineração de dados: É usada para descoberta do conhecimento – o processo de procurar novo conhecimento imprevisto nos dados. Estudaremos sobre este assunto em breve.Mineração de dados\tÉ usada para descoberta do conhecimento – o processo de procurar novo conhecimento imprevisto nos dados. Estudaremos sobre este assunto em breve.Banco de dados tradicionais versus data warehouse: Banco de dados tradicionais: O suporte para processamento de transação on-line (OLTP) que lida com inserções, atualizações e exclusões, enquanto também tem suporte para requisitos de consulta de informação. Os bancos de dados relacionais tradicionais são utilizados para processar consultas que podem tocar em uma pequena parte do banco de dados e transações que lidam com inserções ou atualizações no processo de algumas duplas por relação, assim eles não podem ser utilizados para OLPA, DSS ou mineração de dados. Data warehouses: São projetados exatamente para dar suporte à extração, processamento e apresentação eficiente para fins analíticos e de tomada de decisão. Em comparação com os bancos de dados tradicionais, os data warehouses em geral contêm quantidades muito grandes de dados de várias fontes, que podem incluir bancos de dados de diferentes modelos de dados, e às vezes arquivos adquiridos de sistemas e plataformas independentes.Modelagem de dados para data warehousePara modelagem de dados deve ser levada em consideração a tipologia. Em modelos multidimensionais ocorre o relacionamento dos dados em matrizes multidimensionais, que são chamadas de cubo de dados. Também pode ocorrer de haver mais de três dimensões e, nesse caso, a nominação é hipercubo.A mudança de hierarquia de uma orientação unidimensional para outra é algo feito com facilidade em um cubo de dados com uma técnica chamada de giro, que também pode ser chamada de rotação. Nessa técnica, o cubo de dados pode ser imaginado girando para mostrar uma orientação diferente dos eixos.Modelos multidimensionais atendem prontamente a visões hierárquicas, conhecidas como exibição roll-up ou exibição drill-down. Uma exibição roll-up sobe na hierarquia, agrupando em unidades maiores ao longo de uma dimensão. Uma exibição drill-down oferece a capacidade oposta, fornecendo uma visão mais detalhada.O modelo de armazenamento multidimensional envolve dois tipos de tabelas: a tabela de dimensão, que consiste em tuplas de atributos da dimensão, e a tabela de fatos, que pode ser imaginada como sendo tuplas, uma para cada fato registrado. Esse fato contém alguma variável observada e a identifica com ponteiros para tabelas de dimensão, podendo ser uma ou várias variáveis. A tabela de fatos contém os dados, e as dimensões identificam cada tupla nesses dados.Dois esquemas multidimensionais comuns são o esquema estrela e o esquema floco de neve. O esquema estrela consiste em uma tabela de fatos com uma única tabela para cada dimensão. O esquema floco de neve é uma variação do esquema estrela, em que as tabelas dimensões de um esquema estrela são organizadas em uma hierarquia ao normalizá-las.Projeto de data warehouse Os dados precisam ser extraídos de várias fontes heterogêneas. Por exemplo, banco de dados ou outras entradas de dados, como aquelas que contêm dados do mercado financeiro ou dados ambientais. Os dados precisam ser formatados por coerência dentro do data warehouse. Nomes, significados e domínios de dados de fontes não relacionadas precisam ser reconciliados. Por exemplo, empresas subsidiárias de grandes corporações podem ter diferentes calendários fiscais com trimestres terminados em datas diferentes, tornando difícil agregar dados financeiros por trimestre. Os dados precisam ser limpos para garantir a validade. A limpeza de dados é um processo complicado e complexo, que tem sido identificado como componente que mais exige trabalho na construção do data warehouse. A entrada de dados precisa ser examinada e formatada de modo consistente, sendo verificada a validade e a qualidade. Reconhecer dados errôneos e incompletos é difícil de automatizar, e a limpeza que requer correção de erro automática pode ser ainda mais complicada. Por exemplo, pode-se exigir que “Cidade=Campinas” junto com o “Estado=RJ” seja reconhecido como uma combinação incorreta. Depois que tais problemas tiverem sido resolvidos, dados semelhantes de fontes diferentes precisam ser coordenados para carregar no data warehouse. O processo de retornar dados limpos para origem é chamado de fluxo reverso. Os dados precisam ser ajustados ao modelo de dados do armazém. Baixar os dados de várias fontes que devem ser instalados no modelo de dados no data warehouse. Eles podem ter que ser convertidos de banco de dados relacionais, orientados a objetos ou legados (em rede e/ou hierárquico) para um modelo multidimensional. Os dados precisam ser carregados no data warehouse. O grande volume de dados torna a carga dos dados uma tarefa significativa; são necessárias ferramentas de monitoramento para cargas, bem como métodos para recuperação de cargas incompletas ou incorretas. Com o imenso volume de dados no data warehouse, a atualização incremental normalmente é a única técnica viável.Processos armazenamento de dados: Armazenamento dos dados de acordo com o modelo de dados do armazém; * Criação e manutenção das estruturas de dados exigidas; Criação e manutenção dos caminhos de acesso apropriados; Fornecimento de dados variáveis no tempo à medida que novos dados são incluídos; Suporte e atualização dos dados do data warehouse; Atualização dos dados; Eliminação dos dados.Elementos para projeto do data warehouse: Projeções de uso; O ajuste de modelo de dados; Características das fontes disponíveis; Projeto do componente de metadados; Projeto de componente modular; Projeto de facilidade de gerenciamento de mudança; Considerações de arquitetura distribuída e paralela.Existem duas arquiteturas distribuídas básicas: o data warehouse distribuídos e o data warehouse federado. Data warehouses em nível empresarial: São imensos projetos que exigem investimento maciço de tempo e recursos.Data warehouses virtuais: Oferecem visões de banco de dados operacionais que são materializadas para acesso eficienteData marts: Em geral são voltados para um subconjunto da organização como um departamento e possuem um foco mais estreito.Funcionalidades pré-programadas:Roll-up: Os dados são resumidos com generalização cada vez maior, por exemplo: semanal para trimestral para anual.Drill-down: Níveis cada vez maiores de detalhes são revelados (complemento de roll-up).Giro: É realizada a tabulação cruzada, também conhecida como rotação.Slice e dice: Operações de projeção são realizadas nas dimensões.Ordenação: Os dados são ordenados por valor ordinal.Seleção: Os dados estão disponíveis por valor ou intervalo.Atributos derivados (calculados): Atributos são calculados por operações sobre valores armazenados e derivados.Data MiningConsiste em encontrar tendências ou padrões interessantes em grandes conjuntos de dados para orientar decisões sobre atividades futuras. Há uma expectativa geral de que as ferramentas de mineração de dados deverão identificar esses padrões nos dados com entrada de usuário mínima. Os padrões identificados por essas ferramentas podem fornecer ao analista de dados ideias úteis e inesperadas que podem ser melhor investigadas subsequentemente, talvez se usando outras ferramentas de apoio à decisão.Objetivos da mineração de dados: previsão, identificação, classificação, otimização.Está relacionada à subárea da estatística chamada análise de dados exploratória, que tem objetivos semelhantes e conta com medidas estatísticas.Fases da descoberta de conhecimento nos bancos de dados (KDD - Knowledge Discovery in Database): Seleção dos dados, limpeza, mineração (enriquecimento e transformação), avaliação (limpeza).Nova informação gerada: regras de associação, padrões sequenciais e árvores de classificação.Conhecimento descoberto na mineração de dados: regras de associação, hierarquia de classificação, padrões sequenciais, padrões dentro da série temporal e agrupamento.Banco de dados distribuídosUma coleção de múltiplos bancos de dados logicamente interrelacionados, distribuídos por uma rede de computadores, e um sistema de gerenciamento de banco de dados distribuído – SGBDD.Fatores para distribuição dos dados: Maior disponibilidade, Acesso distribuído aos dados, Análise de dados distribuídos.Propriedade esperada de um SGBDD: Independência dos dados distribuídos e Atomicidade da transação distribuída.Condições mínimas para um BDD: Conexões de nós de banco de dados por uma rede de computadores, Inter-relação lógica dos bancos de dados conectados e Ausência de restrição de homogeneidade entre os nós conectados.Problemas abordados no controle de usuário e recuperação de dados: Manipulação de várias cópias de itens de dados, Falhas em pontos da rede, Falhas na comunicação, Falha em commit e Deadlock.Funções adicionais dos bancos de dados distribuídos: Acompanhar a distribuição de dados, Processamento de consulta distribuído, Gerenciamento de transação distribuído, Gerenciamento de dados replicado, Recuperação de banco de dados distribuído, Segurança e Gerenciamento de diretório (catálogo) distribuído.Vantagens dos bancos de dados distribuídos: Maior facilidade e flexibilidade de desenvolvimento da aplicação, Maior confiabilidade e disponibilidade, Maior desempenho e Expansão mais fácil.Funções necessárias de um BDD: Controle de distribuição, fragmentação e replicação dos dados por meio de extensão no catálogo do SGBDD. Capacidade de processar consultas distribuídas, acessando, por meio de uma rede de comunicação, localizações remotas para extrair os dados. Gerenciamento de consultas e transações que acessam dados a partir de vários locais, ao mesmo tempo em que mantém o acesso sincronizado e a integridade do próprio banco de dados. Capacidade de decidir qual cópia de um item de dado que se encontra replicado deve ser considerada. Recuperação do banco de dados distribuído quando houver alguma falha ou colapso do sistema (os comumente denominados crashs). Segurança na execução de transações distribuídas e gerenciamento de privilégios de autorização/acesso por parte dos usuários. Gerenciamento do catálogo do banco de dados distribuído, de forma que contenha informação referente às localizações dos bancos. Esse catálogo pode ser geral a todo o banco ou local para cada nó da rede envolvida do processo.Desvantagens causadas por problemas com sistemas de gerenciamentos de bancos de dados federados: Diferenças nos modelos de dados, Diferenças nas restrições, Diferenças nas linguagens de consulta, Heterogeneidade semântica, Autonomia de projeto do sistema de bancos de dados.Desvantagens causadas por problemas encontrados no controle de concorrência e recuperação de um BDD: Lidar com múltiplas cópias dos itens de dados, Falha de sites individuais, Falha dos links de comunicação, Confirmação distribuída e Deadlock distribuído.Dois tipos de arquiteturas de sistema multiprocessador: Arquitetura de memória compartilhada (altamente acoplada) e Arquitetura de disco compartilhado (livremente acoplada)." }, { "title": "Anotações sobre Interação Humano-Computador", "url": "/posts/intera%C3%A7%C3%A3o-humano-computador/", "categories": "Estudos-faculdade", "tags": "design, ihc", "date": "2020-01-10 09:00:00 -0300", "snippet": "Design de sistemas interativos Design centrado no humano Diferenciar a interface com pessoas (interfaces de usuário) da interface entre componentes (como as redes); O Design é um processo criativo que se preocupa em produzir algo novo. Ele consiste em uma atividade social com consequências sociais, trata da mudança consciente e da comunicação entre os designers e as pessoas que usarão o sistema. Análise PACT (Pessoas, Atividades, Contextos e Tecnologias) O design conceitual trata da concepção de um sistema em termos abstratos e considera quais informações e funções são necessárias para que o sistema atinja seu propósito. Ele trata da decisão sobre quem terá de saber como usar o sistema e se ocupa em chegar a uma conceptualização clara de uma solução de design e de como ela será comunicada às pessoas, a fim de desenvolvam um modelo mental claro. O design físico, por sua vez, preocupa-se com o modo como as coisas funcionarão e com o detalhamento da aparência e da percepção do produto. Ele trata de estruturar as interações em sequências lógicas e de esclarecer e apresentar a alocação de funções e conhecimento entre pessoas e dispositivos. Existem 3 componentes no design físico: Design operacional: O design operacional preocupa-se em especificar como tudo funciona e como o conteúdo é estruturado e armazenado. Adotar uma visão funcional de uma atividade significa focar os processos e o movimento (ou fluxo) em um sistema. Por exemplo, uma atividade pode ser desencadeada em um determinado dia ou em um determinado horário; outra pode ser desencadeada pela chegada de uma pessoa ou de um documento. Design representacional: O design representacional preocupa-se com a escolha de cores, formas, tamanhos e leiaute da informação. Ele se preocupa com estilo e estética e é particularmente importante em questões como atitudes e sentimentos das pessoas, mas também para a recuperação eficiente de informação. O estilo está relacionado à apresentação geral do sistema. Ele parece antiquado e pesado ou é ágil, harmonioso e moderno? Que humores e sentimentos o design provoca? Muitos sistemas procuram fazer a interação ser envolvente, mas há os que querem que ela seja instigante e outros que buscam o entretenimento. Em aplicações de multimídia e jogos isso é particularmente importante. Design de interação: O design de interação, nesse contexto, preocupa-se com a alocação de funções para os agentes humanos ou para a tecnologia e também com a estruturação e sequência das interações. A alocação de funções tem um impacto significativo em quão fácil e agradável de usar é um sistema. Designers criam tarefas para pessoas pela maneira como alocam funções. Por exemplo, considere a atividade de fazer um telefonema. Conceitualmente falando, certas funções são necessárias: indicar o desejo de fazer um telefonema, ligar-se à rede, informar o número de telefone, fazer a conexão. Um design tem de ser visualizado, tanto para ajudar o designer a clarear suas próprias ideias quanto para que outras pessoas possam avaliá-las. A antecipação preocupa-se em encontrar a mídia apropriada para demonstrar as ideias de design. O meio deve ser apropriado para o estágio do processo, para a plateia, para os recursos disponíveis e para as perguntas que o designer está tentando responder. A avaliação está intimamente ligada à antecipação porque a natureza da representação usada afetará o que pode ser avaliado. O critério de avaliação também dependerá de quem poderá usar a representação. Todas as outras atividades de design são seguidas por uma avaliação. As atividades e os contextos nos quais elas acontecerão são antecipadas por meio de cenários de uso. Diferentes cenários concretos podem ser usados para antecipar como diferentes tecnologias poderiam funcionar para atingir o propósito central do sistema. Os designers precisam reconhecer que não estão criando para si mesmos. Eles criam personas para que possam colocar a si próprios no lugar dos outros. Cenário é o conhecimento adquirido sobre o usuário e suas necessidades. Cenários (e as personas a eles associadas) são uma técnica fundamental para o Design de Sistemas Interativos. São úteis para entendimento, antecipação, avaliação em ambos os designs (conceitual e físico): os quatro estágios-chave do Design de Sistemas Interativos São quatro tipos de cenários: histórias, cenários conceituais, cenários concretos e casos de uso. As histórias são experiências reais de pessoas. Os cenários conceituais são descrições mais abstratas das quais alguns detalhes foram retirados. Os cenários concretos são gerados a partir dos abstratos, acrescentando decisões de design e tecnologias específicas e, uma vez completos, eles podem ser usados como casos de uso. São descrições formais passadas aos programadores. A linguagem de design produzida consiste em um conjunto de padrões normais de interação e em atributos físicos (cores, formas, ícones etc.). Eles são todos reunidos com ações e objetos conceituais e, assim, a apresentação do design fica completa. Uma “linguagem de design” define os elementos-chave do design (como o uso da cor, estilo e tipos de botões, controles deslizantes e outros widgets etc.), bem como alguns princípios e regras para juntá-los. Ergonomia e Design Ergonômico Aspectos temporais das atividades O tempo de resposta necessário pelo sistema precisa ser considerado. Segundo DIX (2003), ele depende do tipo de atividade:  Espera-se um tempo de resposta em torno de 100 milissegundos para atividades de coordenação mão-olho (aquelas nas quais usamos os olhos para dirigir a atenção e as mãos para executar uma tarefa determinada).  Para uma atividade com relação entre causa e efeito, como clicar um botão e acontecer alguma coisa, espera-se um segundo. Qualquer coisa que leve mais de cinco segundos deixará as pessoas frustradas e confusas. Para coletar requisitos e opiniões sobre características do sistema, estão disponíveis vários questionários de usabilidade, pré-preparados e já validados. Dois exemplos são:  QUIS: Questionário de Satisfação para Interface de Usuário, do inglês Questionnaire for User Interface Satisfaction, da Universidade de Maryland;  SUMI: Inventário de Medição de Usabilidade de Software, do inglês Software Usability Measurement Inventory, da Universidade de Cork. Escalas de Likert Percepções do Design de Sistemas são frequentemente coletadas por meio da Escala de Likert (1932), que é a mais comum de uma série de métodos para a pesquisa de opinião. Pede-se que as pessoas indiquem sua concordância a uma afirmação usando uma escala de cinco pontos: concordo totalmente, concordo, neutro, discordo, discordo totalmente. Há também escalas de sete, quatro ou dez pontos. Esta área da IHC e do Design de Interação é frequentemente chamada de experiência do usuário (UX, do inglês User Experience), embora termos como experiência do cliente (CX, do inglês Customer Experience). Envolvimento diz respeito a garantir que a interação flua. Se a usabilidade se preocupa com a otimização ou o equilíbrio dos elementos PACT em um determinado domínio, o envolvimento acontece quando os elementos PACT estão verdadeiramente harmonizados. Nathan Shedroff, em seu livro Experience design (2001), apresenta um manifesto ao que ele vê como uma nova disciplina. Os elementos-chave de SHEDROFF para o envolvimento são: Identidade O senso de autenticidade é necessário para a identidade e expressão do eu, e frequentemente só é notado quando se fragmenta. SHEDROFF também está insinuando a ideia de que a identificação com alguma coisa é um elemento-chave do envolvimento. Por exemplo: você é uma pessoa MAC®, uma pessoa Windows® ou você não liga? Adaptatividade Adaptatividade diz respeito à mudança e personalização, com diferentes níveis de dificuldade, ritmo e movimento. O envolvimento não implica em tornar as coisas fáceis, mas, sim, em fazer coisas a serem experimentadas em muitos níveis de habilidade e prazer. Instrumentos musicais, muitas vezes, são citados como exemplos de ótimos designs de interação. Narrativa É o contar uma boa história com personagens, trama e suspense convincentes, mas não se limita apenas à ficção. Uma boa narrativa é tão importante para o vídeo promocional de uma empresa quanto a uma aula expositiva sobre design de interação, estrutura do menu de um telefone celular ou qualquer outro problema de design! Imersão É a sensação de estar totalmente envolvido dentro de algo, tomado e transportado para outro lugar. Ficamos imersos em todo tipo de coisa (por exemplo, lendo um livro) independente do meio. Fluxo É a alteração gradual de um estado para outro em movimento suave. Fluxo é um conceito importante introduzido pelo filósofo do design Mihaly Czikszentmihalyi: “O fluxo precisa de contexto”. Um rio, por exemplo, precisa das margens, caso contrário ele se espalhará em todas as direções até se tornar um pântano de água salobra.CCDD – Centro de Criação e Desenvolvimento Dialógico 7 Os fluxos influenciam uns aos outros. Quando você pede um livro da Amazon, o fluxo de dados na Internet tem um efeito externo, ou seja, ele faz com que um pacote seja colocado em um avião. Isso, por sua vez, apresenta consequências geográficas: o armazém onde seu pedido é atendido provavelmente fica perto de um aeroporto. Onde ocorrem cruzamentos regulares entre fluxos, surgem lugares. Fluxo é a percepção de envolvimento entre o tédio e a ansiedade, quando habilidades consumadas são aplicadas a desafios quase completamente controláveis. Tendemos a ter familiaridade com as noções psicológicas de “teoria da atividade”, “ações situadas” e “estruturas persistentes”. fluxo requer fixidez. Configurações intencionais persistentemente integradas, também conhecidas como arquitetura, proporcionam um contexto necessário para o fluxo. Um meio é envolvente: Se ele atrai as pessoas, Se parece cercar toda a atividade, Se estimula a imaginação. Um jogo de computador de animação envolvente permitirá a diferenciação de condições. Sendo assim, uma característica importante também é a integração da mídia. LAZZARO (2008) distingue a diversão em: árdua, fácil, séria e social. Cada um desses tipos libera emoções como: curiosidade, relaxamento, excitação e divertimento. Fisioprazer, Socioprazer, Psicoprazer e Ideoprazer Laddering – Esta técnica derivada da pesquisa de mercado pode ser eficaz para chegar às motivações e aos valores subjacentes das pessoas e é, portanto, particularmente útil ao explorar o ideoprazer. A ideia parte de um desejo ou rejeição específicos do produto, de uma série de “por quês” que são apresentados a um participante até ele não conseguir mais apresentar nenhuma explicação. Don Norman discute as experiências das pessoas em termos de elementos viscerais, comportamentais e reflexivos. No nível visceral está a estética perceptiva de uma experiência. No nível comportamental, há uma resposta emocional positiva oriunda da sensação de estar no controle e do entendimento por meio do uso. No nível reflexivo estão questões de valores pessoais e autoestima. A marca leva imediatamente a um senso de identidade, um dos aspectos-chave da experiência. Em contrapartida, a experiência afetará a marca. As experiências das pessoas em sua interação com produtos e serviços de marca criam os sentimentos e valores que elas têm por essas marcas. No design de serviços, os designers preocupam-se em fornecer recursos que permitam a interação entre pessoas e fornecedor. As pessoas não levam para casa um serviço – elas levam o resultado dele. DbL (do inglês Designing by Lifestyles) é uma abordagem de design voltada ao serviço na IHC na década de 2010. Uma característica-chave do design para novos ambientes é sobre o designer não poder “reunir” requisitos com base na observação das pessoas, ou entrevistando usuários de sistemas existentes. Os designers são solicitados a criar experiências e novos serviços. No entanto, como sabemos, o designer precisa entender as características das pessoas que usufruirão dos novos serviços e se envolverão com as novas experiências. o DbL usa quatro técnicas capacitadoras de antecipação, permitindo a prototipação rápida de ideias e o envolvimento de pessoas com designs em desenvolvimento: Os videocenários permitem ao designer antecipar futuras interações em vídeo. Os esboços de estilo são semelhantes aos moodboards e os sistemas Mágico de Oz substituem por um ser humano as tecnologias ainda não disponíveis. Ferramenta Premo Premo Emotion Measurement (premotool.com) Na abordagem de Design Centrado no Humano avalia-se o design desde as primeiras ideias. Existem dois tipos principais de avaliação:  Uma é feita com um especialista em usabilidade (ou designer de interação) para revisar alguma forma de versão antecipada de um design: são os métodos baseados em especialista.  Outra implica recrutar pessoas para usar uma versão antecipada do sistema: são os métodos com participantes. No design com abordagem participativa, os stakeholders ajudam os designers a estabelecer metas para o trabalho de avaliação. Princípios abrangentes de usabilidade, que são: Aprendabilidade Efetividade Acomodação 1. Visibilidade 5. Navegação 10.Flexibilidade 2. Consistência 6. Controle 11.Estilo 3. Familiaridade 7. Retorno 12.Sociabilidade 4. Affordance 8. Recuperação     9. Restrições   A acessibilidade diz respeito à remoção de barreiras que, de outra forma, excluiriam totalmente algumas pessoas de usar o sistema. A usabilidade referese à qualidade da interação em termos de parâmetros, como o tempo consumido na realização de tarefas, o número de erros cometidos e o tempo necessário para tornar um usuário competente. A aceitabilidade refere-se à adequação para o propósito no contexto de uso. Inclui também as preferências pessoais que contribuem para que um usuário “simpatize” ou não com um artefato.Princípios do design universal Uso equitativo: o design não prejudica ou estigmatiza nenhum grupo de usuários Flexibilidade no uso: o design acomoda uma ampla variedade de preferências e habilidades individuais Uso simples e intuitivo: o uso do design é fácil de entender, independentemente da experiência, do conhecimento, das habilidades linguísticas ou do nível de concentração do usuário no momento Informação perceptível: o design comunica a informação necessária efetivamente ao usuário, independentemente das condições do ambiente ou das habilidades sensoriais do usuário. Tolerância ao erro: o design minimiza perigos e consequências adversas de ações acidentais ou não intencionais Baixo esforço físico: o design pode ser usado eficiente e confortavelmente, e com um mínimo de fadiga Tamanho e espaço para aproximação e uso: tamanho apropriado e espaço são oferecidos para aproximação, alcance, manipulação e uso, independentemente do tamanho do corpo, postura ou mobilidade do usuário O Modelo de Aceitação de Tecnologia (TAM, do inglês Technology Acceptance Model) é uma maneira de avaliar as tecnologias e se elas serão aceitas pelas comunidades. Ele teve sua origem em estudos empresariais e não em computação ou psicologia. O TAM avalia a aceitação de tecnologias a partir de duas perspectivas: facilidade de uso e eficácia. " }, { "title": "Anotações sobre Git/GitHub no Eclipse", "url": "/posts/git-github-eclipse/", "categories": "Estudos-faculdade", "tags": "git, java", "date": "2020-01-03 09:00:00 -0300", "snippet": "No Eclipse não é recomendado criar o projeto dentro do Workspace para integrar com o Git. Escolha outro diretório.Nas configurações do projeto, inclua user.name e user.email para identificação nos commitsClique com o botão direito no projeto - Opção Team - Opção Share ProjectMarque a opção: Use or create repository in parent folder of projectUtilize a Perspective Git do EclipseCommit: enviar um snapshot do projeto para o repositório.Head: commit ativoCheck-out para voltar aos commits anteriores, para consulta, sem alterar (ou pra criar outro branch para alteração)Git Staging para adicionar os arquivos do projeto ao controle de gestão. Desnecessário adicionar arquivos .class, pois eles são compilados a partir dos códigos fonte .java. Você pode incluir na pasta bin um arquivo .gitignore para que a pasta com todos os arquivos compilados seja ignorada.Operação clean: limpar alterações que ainda não foram enviados para commit.Nomear commits especiais: tags - #Operação revert: para eliminar alterações que já haviam sido consolidadas em commit, reverte para o commit anterior, mas não apaga o commit revertido, ele é mantido. O git apenas cria uma cópia da versão anterior e a marca como Head.Operação stash changes: O commit pressupõe o snapshot de uma funcionalidade pronta, então se você quiser guardar um trabalho em andamento, pode utilizar o stash changes. As alterações são removidas projeto principal, mas podem ser recuperadas no stashed commits.Recurso compare: compara arquivo alterado com a versão de algum commit.Recurso replace: substitui o arquivo alterado por um de algum commit.Linhas de desenvolvimento independentes com o uso de branchesGalhos ou ramos. O branch principal é chamado de Master.Juntando branches com o fast-forward merge: fazer check-out no commit que vai receber o merge.Excluindo branches que não são mais necessários: delete branchesUsando 3-way merge e resolvendo conflitos manualmente: fazer check-out no commit que vai receber o merge. Fazer o merge; resolver manualmente os conflitos sinalizados; fazer novo commit.Alterando a estrutura dos branches com o uso do rebaseUsando o rebase pra mover um branch para outro local - mudar o commit pai. Ajuda a limpar a estrutura dos commitsImportante manter o histórico do Master organizadoOperações mais comuns do interactive rebase (permite fazer uma limpeza no histórico): permite eliminar commits, fundir, pular, renomear, mudar o comentário etc.Trabalhando com repositórios remotosAdicionando repositórios remotos e realizando o fetch: Repositório clonado - cópia. Fetch - buscar do repositório remoto alguma alteração. Push - enviar alterações feitas para o repositório remoto.Ao receber um push, você pode substituir seu arquivo que foi alterado ou forçar um commit que mantem a sua versão.Não é recomendado fazer push em um repositório remoto local. Você deve avisar as pessoas para que elas façam fetch.Repositório central no GitHubElimine repositórios remotos locais do Eclipse, e trabalhe apenas com o central. Adicionar Remotes incorpora configuração automática com o GitHub.No repositório central você pode fazer push.Integrator Workflow: push bloqueado no repositório central. Desenvolvedores fazem pull request para o integrator aprovar as alterações para inclusão no repositório central. Baseadas nos cursos da Softblue" } ]
